<DashboardPluginModel description="" name="VIAOps - Signal Onboarding Service" is_init="false">
  <ModelInfo validated="true">
    <Properties>
    </Properties>
    <Widgets>
      <Widget name="ConfigSettingsWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[
        resize : function() {
        
        },
        
        setModel : function(values) {

        },
        
        getModel : function() {
            return this._selectedUUID;
        },
        
        _onSettingSelect : function(evt) {
            this._selectedUUID = null;
            var items = getSelectedItems(evt.grid, "__uuid__");
            if (items.length == 1) {
                this._selectedUUID = items[0].__uuid__;
            }
        },
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[            
            var settings = this.editorConfig.settings || {};
            this._settings = [];
            for (var uuid in settings) {
                var setting = settings[uuid];
                setting.__uuid__ = uuid;
                this._settings.push(setting);
            }
            this._settings.sort(function(a,b) {
                return a.description.localeCompare(b.description);
            });
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[
            var self = this;
            createSettingsGrid("settings", this.domNode, lang.hitch(this, "_onSettingSelect"), this._settings, function(widget) {
                
            });
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[
    function getSelectedItems(grid, keyField)
    {
        var items = [];
        for (var i=0; i<grid.collection.data.length; i++) {
            var item = grid.collection.data[i];
            if (grid.selection[item[keyField]] == true) {
                items.push(item);
            }
        }
        return items;
    }

    function createSettingsGrid(name, parentNode, onSelect, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/NumberTextBox",  "dijit/form/Select"], function(CheckBox, NumberTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [{
                field : "description",
                label : "Description",
                style : "font-family:monospace;cursor:pointer;width:300px;",
                sortable : true,
            }, {
                field : "algorithm",
                label : "Algorithm",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
            }, {
                field : "thresholdPolicy",
                label : "Threshold Policy",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
            }];

            var store = GridUtil.createGridStore("__uuid__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "single", onSelect, null);
            callback({
                store : store,
                grid  : grid,
            });
        });
    }
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="config-setting-widget" style="width:100%;height:100%;border:none;background-color:white;">
    <style>
    </style>
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="DeriveWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#constructor">
          <![CDATA[            
            this.sleTypeFieldMap = config.sleTypeFieldMap;
            this.data = config.data || [];
            this.columns = config.columns || [];
            this.sleSchema = config.sleSchema || [];
            this.sleProperties = config.sleProperties || [];
            this.isRowDisable = config.isRowDisable;
            this.isRowSelectable = config.isRowSelectable;
            this.isRowDeletable = config.isRowDeletable;
            this.onChange = config.onChange;
            this.onSelectionChange = config.onSelectionChange;

            this.typeFieldMap = {};
            for (var pro in this.sleTypeFieldMap) {
                this.typeFieldMap[this.sleTypeFieldMap[pro]] = pro;
            }]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[            
            var self = this;
            require([
                (window.vtAppId ||  '/vitria-oi/app/dojoclient') + "/html/scripts/Jquery/src/jquery.js", 
                "af/components/sle/SingleLineEditor", 
                "spark/utils/FunctionUtil"
            ], function(Jquery, SingleLineEditor, FunctionUtil) {
                self.SingleLineEditor = SingleLineEditor;
                self.FunctionUtil = FunctionUtil;
                FunctionUtil.loadFunctionList(function(funcList){
                    self.sleFunctionList = funcList;
                    self.buildLayout();
                });
            });]]>
        </CodeText>
        <CodeText segment="#destroy">
          <![CDATA[            var self = this;
            this.data.forEach(function(data) {
                self._destroyDataWidget(data);
            });
            ]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[        
        _dataMap: {},
        _selections: [],
        buildLayout: function() {
            var self = this;

            this._buildHeader();
            this.data.forEach(function(data) {
                self._buildRow(data);
            });
        },

        addItem: function(data) {
            this.data.push(data);
            this._buildRow(data);
            if (this.onChange) {
                this.onChange();
            }
        },

        deleteItem: function(data) {
            this.data.splice(this.data.indexOf(data), 1);
            this._destroyDataWidget(data);
        },

        _destroyDataWidget: function(data) {
            var itemInfo = this._dataMap[data.__index__];
            for (var pro in itemInfo.widgetMap) {
                var widget = itemInfo.widgetMap[pro];
                if (widget != null && widget.destroy) {
                    widget.destroy();
                }
            }
            $(itemInfo.div).remove();
        },

        _buildHeader: function() {
            var self = this;
            this.columns.forEach(function (column) {
                self._buildHeaderItem(column);
            });
        },

        _buildHeaderItem: function(column) {
            var div = domConstruct.create("div", {
                'class': 'vertical-flex derive-header-item',
                'style': column.style,
                'innerHTML': column.label
            });
            $(this._header).append(div);
        },

        _buildRow: function(data) {
            var self = this;
            var itemInfo = {
                div: null,
                widgetMap: {}
            };
            var div = null;
            if (this.isRowDisable(data)) {
                div = domConstruct.create("div", {
                    'class': 'horizontal-flex derive-row reserved-row'
                });
            } else {
                div = domConstruct.create("div", {
                    'class': 'horizontal-flex derive-row'
                });
            }
            itemInfo.div = div;

            if (this.isRowSelectable && this.isRowSelectable(data)) {
                $(div).click(function(event) {
                    if (event.ctrlKey) {
                        if (self._selections.indexOf(data) >= 0) {
                            $(div).removeClass("selected");
                            self._selections.splice(self._selections.indexOf(data), 1);
                        } else {
                            $(div).addClass("selected");
                            self._selections.push(data);
                        }
                    } else {
                        $(".derive-widget .derive-row").removeClass("selected");
                        $(div).addClass("selected");
                        self._selections = [data];
                    }
                    
                    if (self.onSelectionChange) {
                        self.onSelectionChange(self._selections);
                    }
                });
            }

            this._body.appendChild(div);
            var self = this;
            this.columns.forEach(function(column) {
                itemInfo.widgetMap[column.field] = self._buildRowItem(column, data, function() {
                    if (self.typeFieldMap[column.field]) {
                        var sleField = self.typeFieldMap[column.field];
                        var itemInfo = self._dataMap[data.__index__];
                        itemInfo.widgetMap[sleField].onChangeTargetType(data[column.field] || "string");
                    }
                    if (self.onChange) {
                        self.onChange(self.data);
                    }
                }, div);
            });
            this._dataMap[data.__index__] = itemInfo;
        },

        _buildRowItem: function(column, data, onChange, parent) {
            var self = this;
            var div = this._buildItemDiv(column, parent);
            if (this.isRowDisable(data) || (column.canEdit && !column.canEdit(data, data[column.field]))) {
                return this._buildTextItem(column, data, div);
            } else {
                switch (column.type) {
                    case 'text':
                        return this._buildTextInputItem(column, data, false, onChange, div);
                        break;
                    case 'select':
                        return this._buildSelectItem(column, data, onChange, div);
                        break;
                    case 'sle':
                        return this._buildSleEditorItem(column, data, onChange, div);
                        break;
                    case 'checkbox':
                        return this._buildCheckboxItem(column, data, null, onChange, div);
                        break;
                    default:
                        return this._buildTextInputItem(column, data, false, onChange, div);
                        break;
                }
            }
        },

        _buildItemDiv: function(column, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex derive-row-item',
                'style':  column.style
            });
            parent.appendChild(div);
            return div;
        },

        _buildTextItem: function(column, data, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex',
                'innerHTML': data[column.field] || ""
            });

            parent.appendChild(div);
        },

        _buildCheckboxItem: function(column, data, label, onChange, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex'
            });
            parent.appendChild(div);

            var checkBoxDiv = domConstruct.create("div", {
                'class': 'horizontal-flex'
            });
            div.appendChild(checkBoxDiv);
            var checkbox = FormUtil.createCheckBox("", checkBoxDiv, data[column.field], null, function(value) {
                data[column.field] = value.value;
                onChange(value.value);
            });

            if (label != null && label != "") {
                var checkBoxLabel = domConstruct.create("div", {
                    'class': 'horizontal-flex',
                    'innerHTML': label
                });
                div.appendChild(checkBoxLabel);
            }

            return checkbox;
        },

        _buildTextInputItem: function(column, data, disable, onChange, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex'
            });
            parent.appendChild(div);

            return FormUtil.createTextBox('', div, data[column.field] || "", null, null, disable, function(value) {
                data[column.field] = value.value;
                onChange(value.value);
            });
        },

        _buildSelectItem: function(column, data, onChange, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex'
            });
            parent.appendChild(div);

            return FormUtil.createSingleSelect(column.field, div, column.options, data[column.field], null, null, function(value) {
                data[column.field] = value.value;
                onChange(value.value);
            });
        },

        _buildSleEditorItem: function(column, data, onChange, parent) {
            var div = domConstruct.create("div", {
                'class': 'horizontal-flex'
            });
            parent.appendChild(div);

            var sleEditor = new this.SingleLineEditor({
                schema: this.sleSchema,
                functionList: this.sleFunctionList,
                properties: this.sleProperties,
                validateProperty:true,
                text: data[column.field] || "",
                targetType: data[this.sleTypeFieldMap[column.field]],
                allowEmpty: false,
                sourceSparkType: "DStream",
                wordWarp : false,
                onChange : function (text){
                    data[column.field] = text;
                    onChange(text);
                }
            }, div)
            return sleEditor
        }]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="derive-widget" style="width:100%;height:100%;border:none;background-color:white;">
    <style>
        .horizontal-flex {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        
        .vertical-flex {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-content: center;
            box-sizing: border-box;
        }

        .derive-widget {
            justify-self: flex-start;
        }

        .derive-widget .header {
            width: 100%;
            height: 25px;
            border-bottom: 1px solid #148ac4;
            font-size: 14px;
            color: #148ac4;
        }

        .derive-widget .body {
            width: 100%;
            height: calc(100% - 25px);
            justify-content: flex-start;
            overflow-y: auto;
        }

        .derive-widget .derive-header-item {
            height: 100%;
            flex-grow: 1;
            flex-shrink: 1;
        }

        .derive-widget .derive-row {
            width: 100%;
            border-bottom: 1px solid #EDEDED;
            font-size: 12px;
            color: #000000;
            padding: 2px;
        }

        .derive-widget .derive-row.selected {
            background: rgba(20,138,196,0.6);
        }

        .derive-widget .derive-row:hover {
            background: rgba(20,138,196,0.2);
        }

        .derive-widget .derive-row-item {
            height: 100%;
            width: 100%;
            justify-content: flex-start;
            flex-grow: 1;
            flex-shrink: 1;
            padding-right: 5px;
        }

        .derive-widget .derive-row-item > div {
            width: 100%;
            height: 100%;
            justify-content: flex-start;
        }

        .derive-widget .container {
            justify-content: flex-start;
        }

        .derive-widget .reserved-row {
            background-color: rgba(0,0,0,.1);
            font-style: italic;
        }
    </style>
    <div class="vertical-flex container" style="width: 100%; height: 100%;">
        <div class="horizontal-flex header" data-dojo-attach-point="_header">
        </div>
        <div class="vertical-flex body" data-dojo-attach-point="_body">
        </div>
    </div>
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="QDCEditorWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[
        resize: function() {
            if (this._JSONEditor) {
                this._JSONEditor.resize();
            }
        },

        setModel: function(values) {

        },

        getModel: function() {
            if (this._type == "JSON") {
                return {
                    __index__: this.__index__,
                    type: "JSON",
                    name: "",
                    oper: "",
                    sql: "",
                    value: JSON.parse(this._JSONEditor.getValue())
                };
            } else if (this._isSQL) {
                return {
                    __index__: this.__index__,
                    type: "SQL",
                    name: this._name,
                    oper: this._oper,
                    sql: this._isSQL,
                    value: this._value,
                };
            } else if (this._isRegex) {
                return {
                    __index__: this.__index__,
                    type: "Regex",
                    name: this._name,
                    oper: this._oper,
                    sql: this._isSQL,
                    regex: this._isRegex,
                    value: this._value,
                };
            } else {
                var value = this._value;
                if (value != null && value.trim() != "") {
                    value = value.trim().split("\n");
                } else {
                    value = [];
                }
                return {
                    __index__: this.__index__,
                    type: "Value",
                    name: this._name,
                    oper: this._oper,
                    sql: this._isSQL,
                    regex: this._isRegex,
                    value: value,
                };
            }
        },

        _onChangeFullJSON: function(value) {
            if (value) {
                this._type = "JSON";
            } else if (this._isSQL) {
                this._type = "SQL";
            } else if (this._isRegex) {
                this._type = "Regex";
            } else {
                this._type = "Value";
            }

            if (this._type == "JSON") {
                domStyle.set(this._dimensionTB, "display", "none");
                domStyle.set(this._fullJSONTB, "display", "");
            } else {
                domStyle.set(this._fullJSONTB, "display", "none");
                domStyle.set(this._dimensionTB, "display", "");
            }

            if (this._type == "JSON") {
                var self = this;
                if (typeof this._value == "string") {
                    this._value = {};
                }
                var jsonText = JSON.stringify(this._value, null, "    ");

                if (!this._JSONEditor) {
                    createAceEditor(this._divFullJSONEditor, "ace/mode/json", jsonText, false, function(editor) {
                        self._JSONEditor = editor;
                        self._JSONEditor.on("change", function() {

                        });
                    });
                } else {
                    this._JSONEditor.setValue(jsonText + "\n\n", -1);
                    this._JSONEditor.clearSelection();
                }
            } else {
                if (typeof this._value != "string") {
                    this._value = "";
                }

                this._valueText.set("value", this._value, false);
            }
            
            this._updateHelpText();
        },

        _onChangeName: function(value) {
            this._name = value;
        },

        _onChangeOper: function(value) {
            this._oper = value;
        },

        _onChangeValueType: function(value) {
            var self = this;
            switch (value) {
                case "value":
                    self._isSQL = false;
                    self._isRegex = false;
                    break;
                case "sql":
                    self._isSQL = true;
                    self._isRegex = false;
                    break;
                case "regex":
                    self._isSQL = false;
                    self._isRegex = true;
                    break;
                default:
                    self._isSQL = false;
                    self._isRegex = false;
                    break;
            }
            this._updateHelpText();
        },

        _onChangeValue: function(value) {
            this._value = value;
        },

        _updateHelpText: function() {
            if (this._type != "JSON") {
                if (this._isSQL) {
                    this._valueLabel.innerHTML = "SQL:";
                    this._helpSpan.innerHTML = "<b>SQL</b> is a SQL select statement to return a list of string values from spark hive table.";
                } else if (this._isRegex) {
                    this._valueLabel.innerHTML = "Regex:";
                    this._helpSpan.innerHTML = "<b>Regex</b> is a regex string.";
                } else {
                    this._valueLabel.innerHTML = "Value:";
                    this._helpSpan.innerHTML = "<b>Value</b> is a literal numeric value or list of string, one per line.";
                }
            } else {
                this._valueLabel.innerHTML = "Value:";
                this._helpSpan.innerHTML = "<b>Value</b> is QDC JSON.";
            }
        }]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            if (this._type == "JSON") {
                this._fullJSONCheck.set("value", true);
                domStyle.set(this._dimensionTB, "display", "none");
                domStyle.set(this._fullJSONTB, "display", "");
            } else {
                this._fullJSONCheck.set("value", false);
                domStyle.set(this._dimensionTB, "display", "");
                domStyle.set(this._fullJSONTB, "display", "none");
            }
            this._nameSelect.set("value", this._name, false);
            this._operSelect.set("value", this._oper, false);
            
            if (this._type != "JSON") {
                this._valueText.set("value", this._value, false);
            }
            
            if (this._isSQL) {
                this._valueTypeSelect.set("value", "sql", false);
            } else if (this._isRegex) {
                this._valueTypeSelect.set("value", "regex", false);
            } else {
                this._valueTypeSelect.set("value", "value", false);
            }

            this._updateHelpText();
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[            
        	this._type = "Value";
            this.__index__ = String(Date.now());
            this._name = "";
            this._oper = "EQ";
            this._isSQL = false;
            this._value = "";

            if (this.initialConfig.model) {
                var qdc = this.initialConfig.model;
                this.__index__ = qdc.__index__;
                this._type = qdc.type;
                this._name = qdc.name;
                this._oper = qdc.oper;
                this._isSQL = qdc.sql;
                this._isRegex = qdc.regex;
                this._value = qdc.value;
                if (this._type == "Value" && Array.isArray(this._value)) {
                    this._value = this._value.join("\n");
                }
            }

            this.schema = this.editorConfig.schema || [];
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[
            var names = [];
            for (var i = 0; i < this.schema.length; i++) {
                var field = this.schema[i];
                var label = field.name;
                if (field.label != null && field.label != field.name) {
                    label = label + " (" + field.label + ")";
                }
                names.push({
                    value: field.name,
                    label: label,
                });
            }
            names.sort(function(a, b) {
                return a.label.localeCompare(b.label);
            });
            this._nameSelect.addOption(names);
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[
    function loadAceLib(callback) {
        if (window.ace == undefined) {
            require(["af/utils/proxies/Ace", "dojo/domReady!"], function(AceLib) {
                var proxy = new AceLib();
                proxy.load('default').then(function() {
                    callback();
                });
            });
        } else {
            callback();
        }
    }

    function createAceEditor(parentNode, mode, value, readonly, callback) {
        loadAceLib(function() {
            var container = domConstruct.create("div", {
                "style": "display:block;width:100%;height:100%;",
            });
            parentNode.appendChild(container);
            var editor = ace.edit(container);
            editor.setTheme("ace/theme/chrome");
            editor.getSession().setMode(mode);
            editor.getSession().setTabSize(4);
            editor.setKeyboardHandler(null);
            editor.setShowPrintMargin(false);
            editor.getSession().setUseWrapMode(false);
            editor.setBehavioursEnabled(true);
            editor.setReadOnly(readonly);
            ace.config.loadModule('ace/ext/language_tools', function() {
                editor.setOptions({
                    enableBasicAutocompletion: true,
                    enableSnippets: true
                });
            });
            editor.setValue(value + "\n\n", -1);
            editor.clearSelection();
            callback(editor);
        });
    }]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="qdc-editor-widget" style="width:100%;height:100%;border:none;background-color:white;">
    <table cellspacing="5" style="width:100%;border:none;background-color:white;">
        <tr>
            <td style="white-space:nowrap;text-align:right;width:70px;">Full JSON:</td>
            <td style="padding-left:5px;padding-right:5px; width: calc(100% - 70px);">
                <input style="width:calc(100% - 5px);height:25px;margin-top:4px;font-family:monospace;font-size:12px;" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-point="_fullJSONCheck" data-dojo-attach-event="change:_onChangeFullJSON" />
            </td>
        </tr>
    </table>
    <table cellspacing="5" style="width:100%;border:none;background-color:white;" data-dojo-attach-point="_dimensionTB">
        <tr style="width:100%;">
            <td style="white-space:nowrap;text-align:right;width:70px;">Dimension:</td>
            <td style="width: calc(100% - 70px);padding-left:5px;padding-right:5px;">
                <select style="width:calc(100% - 5px);height:25px;font-family:monospace;font-size:12px;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_nameSelect" data-dojo-attach-event="change:_onChangeName" data-dojo-props="maxHeight:200">
                    <option value="">- Select -</option>
                </select>
            </td>
        </tr>
        <tr>
            <td style="white-space:nowrap;text-align:right;width:70px;">Operator:</td>
            <td style="width: calc(100% - 70px); padding-left:5px;padding-right:5px;">
                <select style="width:calc(100% - 5px);height:25px;font-family:monospace;font-size:12px;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_operSelect" data-dojo-attach-event="change:_onChangeOper" data-dojo-props="maxHeight:200">
                    <option value="EQ">equal to or is in</option>
                    <option value="NE">not equal to or is not in</option>
                </select>
            </td>
        </tr>
        <tr>
            <td style="white-space:nowrap;text-align:right;width:70px;">Value Type:</td>
            <td style="width: calc(100% - 70px); padding-left:5px;padding-right:5px;">
                <select style="width:calc(100% - 5px);height:25px;font-family:monospace;font-size:12px;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_valueTypeSelect" data-dojo-attach-event="change:_onChangeValueType" data-dojo-props="maxHeight:200">
                    <option value="value">Value</option>
                    <option value="sql">SQL</option>
                    <option value="regex">Regex</option>
                </select>
            </td>
        </tr>
        <tr>
            <td style="white-space:nowrap;text-align:right;vertical-align:top;padding-top:10px;width:70px;" data-dojo-attach-point="_valueLabel">Value:</td>
            <td style="width: calc(100% - 70px); padding-left:5px;padding-right:5px;">
                <textarea style="width:calc(100% - 5px);height:240px;font-family:monospace;font-size:12px;padding-top:10px;" data-dojo-type="dijit/form/SimpleTextarea" data-dojo-attach-point="_valueText" data-dojo-attach-event="change:_onChangeValue">
                </textarea>
            </td>
        </tr>
    </table>
    <table cellspacing="5" style="width:100%; height: calc(100% - 80px); border:none;background-color:white;" data-dojo-attach-point="_fullJSONTB">
        <tr style="width:100%;">
            <td style="white-space:nowrap;text-align:right;vertical-align:top; width:70px;">Value:</td>
            <td style="width: calc(100% - 70px); height: calc(100% - 10px); padding-left:5px;padding-right:5px;">
                <div data-dojo-attach-point="_divFullJSONEditor" style="border:thin solid lightgray;width:calc(100% - 10px); height:100%;"></div>
            </td>
        </tr>
    </table>
    <div style="width:calc(100% - 10px);height:80px;padding:5px;background-color:rgba(0,0,0,.1);font-style:italic;" data-dojo-attach-point="_helpSpan"></div>
</div>]]>
        </HtmlText>
      </Widget>
      <Widget name="RuntimeWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[
        _disableButtons : function() {
            if (this._startBtn) this._startBtn.set("disabled", true);
            if (this._stopBtn) this._stopBtn.set("disabled", true);
        },

        _enableButtons : function() {
            var canStart = false;
            var canStop  = false;
            for (var i=0; i<this._selection.length; i++) {
                var item = this._selection[i];
                if (item.preprocessStatus == "NOT_ACTIVE") {
                    canStart = true;
                }
                if (item.parserStatus == "NOT_ACTIVE" || (item.anomalyStatus == "NOT_ACTIVE" && item.hasIncidentConfig)) {
                    canStart = true;
                }
                if (item.preprocessStatus == "ACTIVE") {
                    canStop = true;
                }
                if (item.parserStatus == "ACTIVE" || item.anomalyStatus == "ACTIVE") {
                    canStop = true;
                }
                if (canStart && canStop) break;
            }
            if (this._startBtn) this._startBtn.set("disabled", !canStart);
            if (this._stopBtn) this._stopBtn.set("disabled", !canStop);
        },

        _showStatusText : function(type, text) {
            if (this._statusSpan != null) {
                switch (type) {
                    case "Error":
                        domStyle.set(this._statusSpan, {
                            "color"       : "red",
                            "font-weight" : "bold",
                            "font-style"  : "normal",
                        });
                        break;
                    case "Warn":
                        domStyle.set(this._statusSpan, {
                            "color"       : "orange",
                            "font-weight" : "normal",
                            "font-style"  : "normal",
                        });
                        break;
                    case "Info":
                        domStyle.set(this._statusSpan, {
                            "color"       : "black",
                            "font-weight" : "normal",
                            "font-style"  : "italic",
                        });
                        break;
                }
                this._statusSpan.innerHTML = text;
            }
        },
        
        __doStart : function(item, models, callback) {
            var self = this;
            if (models.length == 0) {
                callback();
            }
            else {
                var model = models.shift();
                switch (model) {
                    case "PREPROCESS":
                        if (item.preprocessStatus == "NOT_ACTIVE") {
                            self._commonPlugin.pbShowProgressBar("startPreProcessModel", "Starting " + item.id + " preprocess...");
                            self._plugin.startPreProcessModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("startPreProcessModel");
                                self.__doStart(item, models, callback);
                            });
                        }
                        else {
                            this.__doStart(item, models, callback);
                        }
                        break;
                    case "PARSER":
                        if (item.parserStatus == "NOT_ACTIVE") {
                            self._commonPlugin.pbShowProgressBar("startParserModel", "Starting " + item.id + " parser...");
                            self._plugin.startParserModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("startParserModel");
                                self.__doStart(item, models, callback);
                            });
                        }
                        else {
                            this.__doStart(item, models, callback);
                        }
                        break;
                    case "ANOMALY":
                        if (item.anomalyStatus == "NOT_ACTIVE" && item.hasIncidentConfig) {
                            self._commonPlugin.pbShowProgressBar("startAnomalyModel", "Starting " + item.id + " anomaly...");
                            self._plugin.startAnomalyModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("startAnomalyModel");
                                self.__doStart(item, models, callback);
                            });
                        }
                        else {
                            this.__doStart(item, models, callback);
                        }
                        break;
                }
            }
        },

        _onClickStart : function(evt) {
            var self = this;
            if (this._selection.length == 0) {
                self.doRefresh();
            }
            else {
                var item = this._selection.shift();
                this.__doStart(item, ["PREPROCESS", "PARSER", "ANOMALY"], function() {
                    self._onClickStart(null);
                });
            }
        },

        __doStop : function(item, models, callback) {
            var self = this;
            if (models.length == 0) {
                callback();
            }
            else {
                var model = models.shift();
                switch (model) {
                    case "PREPROCESS":
                        if (item.preprocessStatus == "ACTIVE") {
                            self._commonPlugin.pbShowProgressBar("stopPreProcessModel", "Stopping " + item.id + " preprocess...");
                            self._plugin.stopPreProcessModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("stopPreProcessModel");
                                self.__doStop(item, models, callback);
                            });
                        }
                        else {
                            this.__doStop(item, models, callback);
                        }
                        break;
                    case "PARSER":
                        if (item.parserStatus == "ACTIVE") {
                            self._commonPlugin.pbShowProgressBar("stopParserModel", "Stopping " + item.id + " parser...");
                            self._plugin.stopParserModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("stopParserModel");
                                self.__doStop(item, models, callback);
                            });
                        }
                        else {
                            this.__doStop(item, models, callback);
                        }
                        break;
                    case "ANOMALY":
                        if (item.anomalyStatus == "ACTIVE") {
                            self._commonPlugin.pbShowProgressBar("stopAnomalyModel", "Stopping " + item.id + " anomaly...");
                            self._plugin.stopAnomalyModel(item.project, function(response) {
                                self._commonPlugin.pbHideProgressBar("stopAnomalyModel");
                                self.__doStop(item, models, callback);
                            });
                        }
                        else {
                            this.__doStop(item, models, callback);
                        }
                        break;
                }
            }
        },

        _onClickStop : function(evt) {
            var self = this;
            if (this._selection.length == 0) {
                self.doRefresh();
            }
            else {
                var item = this._selection.shift();
                this.__doStop(item, ["PREPROCESS", "PARSER", "ANOMALY"], function() {
                    self._onClickStop(null);
                });
            }
        },

        _onSelect : function(event) {
            if (this._statusWidget != null && this._statusWidget.grid != null) {
                this._selection = getSelectedItems(this._statusWidget.grid, "__index__");
            }
            else {
                this._selection = [];
            }
            this._enableButtons();
        },

        _updateUIEvent : function(type, event)
        {
            // depend on PopupWidget aspect to catch this call and propagate output
            this.renderer.updateUIEvent([{
                "__TYPE__" : type,
                "__EVENT__" : event
            }]);
        },

        openFormDialog : function(title, description, itemDef, buttonDef, style, callback) {
            var autoHeight = null;
            if (style == null) style = {
                "form-label" : {
                    width : "1%",
                },
                "form-value" : {
                    width : "99%",
                },
            };
            if (style["width"] == null) {
                style["width"] = "500px";
            }
            if (style["height"] == null) {
                autoHeight = itemDef.length * 40;
                style["height"] = autoHeight + "px";
            }
            var self = this;
            require(["af/scripts/controls/FormDialog"], function(FormDialog) {
                var dialog = new FormDialog({
                    title   : title,
                    message : description,
                    items   : itemDef,
                    buttons : buttonDef,
                    style   : style,
                    callback : function(value, data) {
                        if (callback != null) {
                            try {
                                callback(value, data);
                            }
                            catch (x) {
                                console.error(x);
                            }
                        }
                    },
                });
                dialog.show();
                if (autoHeight != null) {
                    domStyle.set(dialog._dialog.dialogContentNode, "height", autoHeight+"px");
                }
            });
        },
        
        showMessage : function(category, title, message, callback) {
            var self = this;
            var growlManager = this.controller && this.controller.appController && this.controller.appController.main && this.controller.appController.main.growlManager;
            require(["af/controls/AppMessageBox"], function(AppMessageBox) {
                var buttonCount = 1;
                switch (category) {
                    case "growl"   : buttonCount = 0; break;
                    case "confirm" : buttonCount = 2; break;
                    case "warn"    : buttonCount = 1; break;
                    case "error"   : buttonCount = 1; break;
                    default        : buttonCount = 1; break;
                }
                if (buttonCount > 0) {
                    var alert = new AppMessageBox({
                        title   : title,
                        message : message,
                        buttons : buttonCount,
                        okHandler: function() {
                            if (callback != null) {
                                try {
                                    callback(true);
                                }
                                catch (x) {
                                    console.error(x);
                                }
                            }
                        },
                        cancelHandler: function() {
                            if (callback != null) {
                                try {
                                    callback(false);
                                }
                                catch (x) {
                                    console.error(x);
                                }
                            }
                        }
                    });
                    alert.show();
                }
                else if (growlManager) {
                    var growlText = "";
                    if (title != null && title != "") {
                        growlText = "<b><big>" + title + "</big></b><br><hr>";
                    }
                    growlText += message;
                    growlManager.addGrowl(growlText);
                    if (callback != null) {
                        try {
                            callback(true);
                        }
                        catch (x) {
                            console.error(x);
                        }
                    }
                }
            });
        },
]]>
        </CodeText>
        <CodeText segment="#doRefresh">
          <![CDATA[
            var data = this.renderer.result;
            if (data != null && data.length == 1) {
                if (data[0]["NuovaStella"] != null) {
                    this._plugin = data[0]["NuovaStella"];
                }
            }

            if (this._statusWidget != null) {
                this._statusWidget.grid.destroy();
                delete this._statusWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            this._onSelect(null);

            var self = this;
            self._commonPlugin.pbShowProgressBar("getRuntimeStatuses", "Checking status of Nuova Stella project runtimes...");
            self._plugin.getRuntimeStatuses(function(response) {
                if (response.status == "OK") {
                    createStatusGrid("Status", self._divContent, lang.hitch(self, "_onSelect"), response.value, function(widget) {
                        self._statusWidget = widget;
                    });
                }
                self._commonPlugin.pbHideProgressBar("getRuntimeStatuses");
            });
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            var node = this.domNode;
            while (node != null) {
                if (domClass.contains(node, "appDialogCenter")) {
                    // found it
                    if (node.nextElementSibling != null) {
                        var footerTd = node.nextElementSibling.firstElementChild;
                        if (footerTd != null) {
                            this._statusSpan = domConstruct.create("span", {
                                style : "padding-left:5px;font-size:12px;font-style:italic;",
                            });
                            footerTd.insertBefore(this._statusSpan, footerTd.firstElementChild);
                            break;
                        }
                    }
                }
                node = node.parentElement;
            }

            this.doRefresh();

            this._disableButtons();
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            this._project = null;

            this._plugin = Plugin();
            this._commonPlugin = Plugin("VIA - Common");
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[
    function getSelectedItems(grid, keyField)
    {
        var items = [];
        for (var i=0; i<grid.collection.data.length; i++) {
            var item = grid.collection.data[i];
            if (grid.selection[item[keyField]] == true) {
                items.push(item);
            }
        }
        return items;
    }

    function createStatusGrid(name, parentNode, onSelect, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            if (parentNode == null) return;

            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            for (var i=0; i<data.length; i++) {
                var item = data[i];
                item.id = item.project.svc + "|" + item.project.comp + "|" + item.project.app;
                item.__index__ = String(i);
            }
            
            var NAMES  = ["id",               "preprocessStatus",      "parserStatus",      "anomalyStatus",       "hasIncidentConfig"];
            var LABELS = ["Project",          "PreProcess",            "Parser",            "Anomaly",             "Incident Config"];
            var STYLE  = ["width:300px;",     "width:100px;",          "width:100px;",      "width:100px;",        "width:100px;"];
            var columns = [];
            for (var i=0; i<NAMES.length; i++) {
                columns.push({
                    field    : NAMES[i],
                    label    : LABELS[i],
                    style    : "font-family:monospace;cursor:pointer;" + STYLE[i],
                    sortable : false,
                });
            }
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store, onSelect, null, "extended", onSelect, null);
            callback({
                store : store,
                grid  : grid,
            });
        });
    }
]]>
        </CodeText>
        <CodeText segment="#updateWidthAndHeight">
          <![CDATA[
            if (this._statusWidget != null) {
                this._statusWidget.grid.resize();
            }
]]>
        </CodeText>
        <CodeText segment="#destroy">
          <![CDATA[
            this._updateUIEvent("on-close", null);
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="runtime-widget" style="width:100%;height:100%;border:none;background-color:white;">
    <style>
    </style>
    <div data-dojo-attach-point="_divContent" style="width:100%;height:calc(100% - 30px);" class="via-scroller">
    </div>
    <table cellspacing="0" data-dojo-attach-point="_footerTable" style="width:100%;height:25px;border:none;background-color:white;padding:5px 0px 0px 0px;">
        <tr style="width:100%;height:100%;">
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_startBtn" data-dojo-attach-event="click:_onClickStart" type="button">Start</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_stopBtn" data-dojo-attach-event="click:_onClickStop" type="button">Stop</button>
            </td>
            <td style="width:100%;"></td>
        </tr>
    </table>
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="TestWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[
        _disableButtons : function() {
            if (this._viewTestsBtn) this._viewTestsBtn.set("disabled", true);
            if (this._uploadTestBtn) this._uploadTestBtn.set("disabled", true);
            if (this._downloadTestBtn) this._downloadTestBtn.set("disabled", true);
            if (this._deleteTestsBtn) this._deleteTestsBtn.set("disabled", true);
            if (this._editModelBtn) this._editModelBtn.set("disabled", true);
            if (this._generateDataBtn) this._generateDataBtn.set("disabled", true);
            if (this._exportDataBtn) this._exportDataBtn.set("disabled", true);
            if (this._epochTimeBtn) this._epochTimeBtn.set("disabled", true);
            if (this._editScriptBtn) this._editScriptBtn.set("disabled", true);
            if (this._testScriptBtn) this._testScriptBtn.set("disable", true);
            if (this._saveEditBtn) this._saveEditBtn.set("disabled", true);
            if (this._cancelEditBtn) this._cancelEditBtn.set("disabled", true);
        },

        _enableSaveCancelButtons : function() {
            if (this._saveEditBtn) this._saveEditBtn.set("disabled", (this._selectedView != "EDIT_MODEL" && this._selectedView != "EDIT_SCRIPT") || (this._modelIsDirty == false && this._scriptIsDirty == false));
            if (this._cancelEditBtn) this._cancelEditBtn.set("disabled", (this._selectedView != "EDIT_MODEL" && this._selectedView != "EDIT_SCRIPT") || (this._modelIsDirty == false && this._scriptIsDirty == false));
        },

        _enableButtons : function() {
            if (this._viewTestsBtn) this._viewTestsBtn.set("disabled", false);
            if (this._uploadTestBtn) this._uploadTestBtn.set("disabled", this._selectedView != "VIEW_TESTS");
            if (this._downloadTestBtn) this._downloadTestBtn.set("disabled", this._selectedView != "VIEW_TESTS" || this._testSelection == null || this._testSelection.length != 1);
            if (this._deleteTestsBtn) this._deleteTestsBtn.set("disabled", this._selectedView != "VIEW_TESTS");
            if (this._editModelBtn) this._editModelBtn.set("disabled", false);
            if (this._generateDataBtn) this._generateDataBtn.set("disabled", this._parserStatus != "ACTIVE");
            if (this._exportDataBtn) this._exportDataBtn.set("disabled", false);
            if (this._epochTimeBtn) this._epochTimeBtn.set("disabled", this._selectedView != "EDIT_MODEL");
            if (this._editScriptBtn) this._editScriptBtn.set("disabled", ["application/json"].indexOf(this._project.sample.type) == -1);
            if (this._testScriptBtn) this._testScriptBtn.set("disabled", this._selectedView != "EDIT_SCRIPT");
            this._enableSaveCancelButtons();
        },

        _showStatusText : function(type, text) {
            if (text == "" && this._lastStatusText.indexOf("EPOCH") == 0) return;
            
            if (this._statusSpan != null) {
                switch (type.toUpperCase()) {
                    case "ERROR":
                        domStyle.set(this._statusSpan, {
                            "color"       : "red",
                            "font-weight" : "bold",
                            "font-style"  : "normal",
                        });
                        break;
                    case "WARN":
                        domStyle.set(this._statusSpan, {
                            "color"       : "orange",
                            "font-weight" : "normal",
                            "font-style"  : "normal",
                        });
                        break;
                    case "INFO":
                        domStyle.set(this._statusSpan, {
                            "color"       : "black",
                            "font-weight" : "normal",
                            "font-style"  : "italic",
                        });
                        break;
                }
                this._statusSpan.innerHTML = text;
                this._lastStatusText = text;
            }
        },

        _doConnect : function() {
            var self = this;
            if (!this._isConnected) {
                this._tdStatus.innerHTML = "Connecting...";
                var parameters = {
                    url : this._project.hdfsServerURL,
                };
                this._disableButtons();
                this._showStatusText("Info", "Connecting to HDFS...");
                this._hdfsPlugin.executeCommand(this._sessionId, "getFileSystem", parameters, function(response) {
                    self._enableButtons();
                    self._showStatusText("Info", "");
                    if (response.status == "OK") {
                        self._isConnected = true;
                        self._tdStatus.innerHTML = "Connected";
                        self._onClickViewTests(null);
                        self._onTestSelect(null);
                    }
                });
            }
        },

        _viewTests : function() {
            if (this._testSelection != null && this._testSelection.length > 0) {
                // if we have selection, do not refresh
                this._viewTestsTimeout = window.setTimeout(lang.hitch(this, "_viewTests"), 5*1000);
            }
            else {
                this._disableButtons();
                this._showStatusText("Info", "Checking test data...");
                delete this._viewTestsTimeout;
                var self = this;
                this._plugin.checkTestData(self._project, "Default", function(response) {
                    if (self._destroyed == true) return;
                    if (self._selectedView == "VIEW_TESTS") {
                        if (response.status == "OK") {
                            self._testData = response.value;
                            self._showTestData();
                        }
                        self._viewTestsTimeout = window.setTimeout(lang.hitch(self, "_viewTests"), 5*1000);
                    }
                    self._enableButtons();
                    self._showStatusText("Info", "");
                });
            }
        },

        _onClickViewTests : function(evt) {
            if (this._selectedView == "VIEW_TESTS") return;
            this._selectedView = "VIEW_TESTS";

            this._downloadTestBtn.set("disabled", false);
            this._deleteTestsBtn.set("disabled", false);
            this._saveEditBtn.set("disabled", true);
            this._cancelEditBtn.set("disabled", true);

            if (this._testModelWidget != null) {
                this._testModelWidget.destroy();
                delete this._testModelWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            if (this._testScriptWidget != null) {
                this._testScriptWidget.destroy();
                delete this._testScriptWidget;
                delete this._testScriptResult;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            this._viewTests();
        },

        _onClickUploadTest : function(evt) {
            // upload test data
            var self = this;
            var uploadComplete = false;
            this._commonPlugin.uploadFile(null, false, function(data) {
                self._showStatusText("INFO", "Upload complete: " + data.size + " bytes");
                self._plugin.addTestData(self._project, "Default", data, function(response) {
                    if (response.status == "OK") {
                    }
                    self._viewTests();
                })
            }, function(event, data) {
                switch (event) {
                    case "onProgress":
                        if (!uploadComplete) {
                            self._showStatusText("INFO", "Uploading selected file: " + data.percent + "...");
                        }
                        break;
                    case "onComplete":
                        uploadComplete = true;
                        break;
                }
            });
        },

        _onClickDownloadTest : function(evt) {
            // download selected test file
            if (this._testSelection != null && this._testSelection.length == 1) {
                var filename = this._testSelection[0].name;
                this._plugin.downloadTestData(this._project, "Default", filename, function(response) {
                    if (response.status == "OK") {
                        var uuid = response.value;
                        if (uuid != null) {
                            window.open("/vitria-oi/rest/app/dojoclient/user/*/*/" + filename + "?op=downloadcsv&uid=" + uuid);
                        }
                    }
                });
            }
        },

        _onClickDeleteTests : function(evt) {
            var self = this;
            if (this._testSelection != null && this._testSelection.length > 0) {
                // delete selected
                var filenames = [];
                this._testSelection.forEach(function(file) {
                    filenames.push(file.name);
                });
                this._plugin.deleteTestData(this._project, "Default", filenames, function(response) {
                    if (response.status == "OK") {
                    }
                    delete self._testSelection;
                    self._viewTests();
                });
            }
            else {
                // delete all
                this._plugin.deleteTestData(this._project, "Default", null, function(response) {
                    if (response.status == "OK") {
                    }
                    self._viewTests();
                });
            }
        },

        _onClickEditModel : function(evt) {
            if (this._selectedView == "EDIT_MODEL") return;

            this._disableButtons();
            this._selectedView = "EDIT_MODEL";
            this._modelIsDirty = false;
            this._enableButtons();

            if (this._viewTestsTimeout != null) {
                window.clearTimeout(this._viewTestsTimeout);
                delete this._viewTestsTimeout;
            }
            if (this._testDataWidget != null) {
                this._testDataWidget.grid.destroy();
                delete this._testDataWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            if (this._testScriptWidget != null) {
                this._testScriptWidget.destroy();
                delete this._testScriptWidget;
                delete this._testScriptResult;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            delete this._testSelection;

            if (this._testModelText == null) {
                var self = this;
                this._plugin.loadProjectTestModel(self._project, function(response) {
                    if (response.status == "OK") {
                        if (response.value != null) {
                            self._testModelText = JSON.stringify(response.value, null, "    ");
                        }
                        else {
                            self._testModelText = "";
                        }
                        self._editTestModel();
                    }
                });
            }
            else {
                this._editTestModel();
            }
        },

        _onClickEditScript : function(evt) {
            if (this._selectedView == "EDIT_SCRIPT") return;

            this._disableButtons();
            this._selectedView = "EDIT_SCRIPT";
            this._modelIsDirty = false;
            this._enableButtons();

            if (this._viewTestsTimeout != null) {
                window.clearTimeout(this._viewTestsTimeout);
                delete this._viewTestsTimeout;
            }
            if (this._testDataWidget != null) {
                this._testDataWidget.grid.destroy();
                delete this._testDataWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            if (this._testModelWidget != null) {
                this._testModelWidget.destroy();
                delete this._testModelWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            delete this._testSelection;

            if (this._testScriptText == null) {
                var self = this;
                this._plugin.loadProjectTestScript(self._project, function(response) {
                    if (response.status == "OK") {
                        if (response.value != null) {
                            self._testScriptText = response.value;
                        }
                        else {
                            self._testScriptText = "";
                        }
                        self._editTestScript();
                    }
                });
            }
            else {
                this._editTestScript();
            }
        },

        _onClickTestScript : function(evt) {
            var self = this;
            if (evt == null) {
                self._testScriptResult.value = "";
                self._commonPlugin.pbShowProgressBar("evalTestScript", "Generate data and evaluate test script...");
                self._plugin.evalTestScript(self._project, self._testScriptWidget.getValue(), function(response) {
                    if (response.status == "OK") {
                        if (typeof response.value == "string") {
                            self._testScriptResult.value = response.value;
                        }
                        else {
                            self._testScriptResult.value = JSON.stringify(response.value, null, "    ");
                        }
                    }
                    else {
                        self._testScriptResult.value = response.error;
                    }
                    self._commonPlugin.pbHideProgressBar("evalTestScript");
                });
            }
            else {
                self._plugin.getTestSize(self._project, function(response) {
                    if (response.status == "OK" && response.value > 0) {
                        if (response.value > 10000) {
                            self.showMessage("confirm", "ALERT: Out-of-Memory Risk",
                                             "Generating " + response.value + " test events may take a long time, consume excessive memory, resulting in OOM exception on the server. Continue?",
                                             function(ok) {
                                                 if (ok) {
                                                     self._onClickTestScript(null);
                                                 }
                                             });
                        }
                        else {
                            self._onClickTestScript(null);
                        }
                    }
                });
            }
        },

        _onClickGenerateData : function(evt) {
            var self = this;
            if (evt == null) {
                self._commonPlugin.pbShowProgressBar("generateTestData", "Generating test data...");
                self._plugin.generateTestData(self._project, "Default", function(response) {
                    self._viewTests();
                    self._commonPlugin.pbHideProgressBar("generateTestData");
                });
            }
            else {
                self._plugin.getTestSize(self._project, function(response) {
                    if (response.status == "OK" && response.value > 0) {
                        if (response.value > 10000) {
                            self.showMessage("confirm", "ALERT: Out-of-Memory Risk",
                                             "Generating " + response.value + " test events may take a long time, consume excessive memory, resulting in OOM exception on the server. Continue?",
                                             function(ok) {
                                                 if (ok) {
                                                     self._onClickGenerateData(null);
                                                 }
                                             });
                        }
                        else {
                            self._onClickGenerateData(null);
                        }
                    }
                });
            }
        },

        _onClickExportData : function(evt) {
            var self = this;
            if (evt == null) {
                self._commonPlugin.pbShowProgressBar("exportTestData", "Exporting test data...");
                self._plugin.exportTestData(self._project, function(response) {
                    if (response.status == "OK" && response.value != null) {
                        if (response.value.uuid != null && response.value.name != null) {
                            window.open("/vitria-oi/rest/app/dojoclient/user/*/*/" + response.value.name + "?op=downloadcsv&uid=" + response.value.uuid);
                        }
                    }
                    self._commonPlugin.pbHideProgressBar("exportTestData");
                });
            }
            else {
                self._plugin.getTestSize(self._project, function(response) {
                    if (response.status == "OK" && response.value > 0) {
                        if (response.value > 10000) {
                            self.showMessage("confirm", "ALERT: Out-of-Memory Risk",
                                             "Generating " + response.value + " test events may take a long time, consume excessive memory, resulting in OOM exception on the server. Continue?",
                                             function(ok) {
                                                 if (ok) {
                                                    self._onClickExportData(null);
                                                 }
                                             });
                        }
                        else {
                            self._onClickExportData(null);
                        }
                    }
                });
            }
        },

        _onClickEpochTime : function(evt) {
            var widgetPath = "/app/dbp/user/via_common/dbpm/VIA - Time Range Picker/TimeRangePicker";
            var widgetConfig = {
                predefined : [],
            };
            var self = this;
            var model = "absolute:" + ( ( Date.now() - 86400000 * 8 ) / 1000 ) + "/" + ( Date.now() / 1000 );
            this._commonPlugin.popupWidget(this.controller, "Compute Epoch", 495, 350, false, model, widgetPath, widgetConfig, function(value) {
                // value = "absolute:1570518000/1571122800"
                if (value != null && value != "" && value.indexOf("absolute:") == 0) {
                    var toks = value.substring("absolute:".length).split("/");
                    if (toks.length == 2) {
                        var startEpoch = Number(toks[0]);
                        var endEpoch = Number(toks[1]);
                        self._showStatusText("Info", "EPOCH From: [" + startEpoch + "] To: [" + endEpoch + "]");

                        // apply to test model
                        self._applyIteratorMinMax(startEpoch, endEpoch, self._testModelWidget.getValue(), function(startDateTime, endStartTime, text) {
                            if (text != null) {
                                self._testModelText = text;
                                self._testModelWidget.setValue(self._testModelText + "\n\n", -1);
                                self._testModelWidget.clearSelection();
                                self._showStatusText("Info", "EPOCH From: [" + startDateTime + "] To: [" + endStartTime + "]");
                            }
                        });
                    }
                }
            });
        },

        _applyIteratorMinMax : function(startEpoch, endEpoch, text, callback) {
            var self = this;
            var models = null;
            if (text != null && text.trim() != "") {
                try {
                    models = JSON.parse(text);
                    var model = models[0];
                    if (model.iterator != null && model.iterator.field != null) {
                        if (model.iterator.unitOfTime == null) {
                            // backward compat
                            model.iterator.unitOfTime = "second";
                        }
                        var field = model.fields[model.iterator.field];
                        if (field != null) {
                            switch (field.type) {
                                case "long":
                                case "double":
                                    switch (model.iterator.unitOfTime) {
                                        case "second":
                                            model.iterator.min = startEpoch;
                                            model.iterator.max = endEpoch;
                                            break;
                                        case "millisecond":
                                            model.iterator.min = startEpoch * 1000;
                                            model.iterator.max = endEpoch * 1000;
                                            break;
                                        case "microsecond":
                                            model.iterator.min = startEpoch * 1000000;
                                            model.iterator.max = endEpoch * 1000000;
                                            break;
                                        case "nanosecond":
                                            model.iterator.min = startEpoch * 1000000000;
                                            model.iterator.max = endEpoch * 1000000000;
                                            break;
                                    }
                                    callback(model.iterator.min, model.iterator.max, JSON.stringify(models, null, "    "));
                                    break;
                                case "datetime":
                                    if (field.format != null && field.format != "") {
                                        self._plugin.formatDateTime(field.format, startEpoch, endEpoch, function(response) {
                                            if (response.status == "OK") {
                                                model.iterator.min = response.value.startDateTime;
                                                model.iterator.max = response.value.endDateTime;
                                                model.fields[model.iterator.field].value.min = response.value.startDateTime;
                                                model.fields[model.iterator.field].value.max = response.value.endDateTime;
                                                callback(model.iterator.min, model.iterator.max, JSON.stringify(models, null, "    "));
                                            }
                                        });
                                    }
                                    break;
                            }
                        }
                    }
                }
                catch (err) {
                    // ignore
                }
            }
        },

        _onClickSaveEdit : function(evt) {
            var self = this;
            switch (this._selectedView) {
                case "EDIT_MODEL":
                    var model = null;
                    var text = this._testModelWidget.getValue();
                    if (text != null && text.trim() != "") {
                        try {
                            model = JSON.parse(text);
                        }
                        catch (err) {
                            this._showStatusText("Error", "Test model is invalid");
                            return;
                        }
                    }
                    this._commonPlugin.pbShowProgressBar("saveProjectTestModel", "Saving test model...");
                    this._plugin.saveProjectTestModel(self._project, model, function(response) {
                        self._commonPlugin.pbHideProgressBar("saveProjectTestModel");
                        self._plugin.loadProjectTestModel(self._project, function(response) {
                            if (response.status == "OK") {
                                self._testModelText = JSON.stringify(response.value, null, "    ");
                                self._testModelWidget.setValue(self._testModelText + "\n\n", -1);
                                self._testModelWidget.clearSelection();
        
                                self._modelIsDirty = false;
                                self._enableSaveCancelButtons();
                            }
                        });
                    });
                    break;
                case "EDIT_SCRIPT":
                    var script = null;
                    var script = this._testScriptWidget.getValue();
                    if (script == null) script = "";
                    if (script != null) script = script.trim();
                    this._commonPlugin.pbShowProgressBar("saveProjectTestScript", "Saving test script...");
                    this._plugin.saveProjectTestScript(self._project, script, function(response) {
                        self._commonPlugin.pbHideProgressBar("saveProjectTestScript");
                        self._plugin.loadProjectTestScript(self._project, function(response) {
                            if (response.status == "OK") {
                                self._testScriptText = response.value;
                                self._testScriptWidget.setValue(self._testScriptText + "\n\n", -1);
                                self._testScriptWidget.clearSelection();
        
                                self._scriptIsDirty = false;
                                self._enableSaveCancelButtons();
                            }
                        });
                    });
                    break;
            }
        },

        _onClickCancelEdit : function(evt) {
            var self = this;
            switch (self._selectedView) {
                case "EDIT_MODEL":
                    if (this._testModelText != null) {
                        this._testModelWidget.setValue(this._testModelText + "\n\n", -1);
                        this._testModelWidget.clearSelection();
                    }
                    this._modelIsDirty = false;
                    this._enableSaveCancelButtons();
                    break;
                case "EDIT_SCRIPT":
                    if (this._testScriptText != null) {
                        this._testScriptWidget.setValue(this._testScriptText + "\n\n", -1);
                        this._testScriptWidget.clearSelection();
                    }
                    this._scriptIsDirty = false;
                    this._enableSaveCancelButtons();
                    break;
            }
        },

        _showTestData : function() {
            if (this._testDataWidget != null) {
                this._testDataWidget.grid.destroy();
                delete this._testDataWidget;
                AppUtil.removeAllChildrenOf(this._divContent);
            }
            this._onTestSelect(null);
            if (this._testData != null) {
                this._testData.sort(function(a,b) {
                    return a.name.localeCompare(b.name);
                });
                var self = this;
                createTestGrid("Tests", this._divContent, lang.hitch(self, "_onTestSelect"), this._testData, function(widget) {
                    self._testDataWidget = widget;
                });
            }
        },
        
        _editTestModel : function() {
            var self = this;
            createAceEditor(self._divContent, "ace/mode/json", self._testModelText, lang.hitch(self, "_onChangeTestModel"), function(editor) {
                self._testModelWidget = editor;
            });
        },

        _onChangeTestModel : function(evt) {
            this._modelIsDirty = true;
            this._enableSaveCancelButtons();
        },
        
        _editTestScript : function() {
            var self = this;
            createScriptEditor(self._divContent, self._testScriptText, lang.hitch(self, "_onChangeTestScript"), function(obj) {
                self._testScriptWidget = obj.editor;
                self._testScriptResult = obj.result;
            });
        },

        _onChangeTestScript : function(evt) {
            this._scriptIsDirty = true;
            this._enableSaveCancelButtons();
        },

        _onTestSelect : function(event) {
            if (this._testDataWidget != null && this._testDataWidget.grid != null) {
                this._testSelection = getSelectedItems(this._testDataWidget.grid, "__index__");
                if (this._deleteTestsBtn != null) {
                    this._deleteTestsBtn.set("label", this._testSelection.length > 0 ? "Delete Selected Test(s)" : "Delete All Tests");
                }
            }
            else {
                this._testSelection = [];
                if (this._deleteTestsBtn != null) {
                    this._deleteTestsBtn.set("label",  "Delete All Tests");
                }
            }
            this._enableButtons();
        },

        openFormDialog : function(title, description, itemDef, buttonDef, style, callback) {
            var autoHeight = null;
            if (style == null) style = {
                "form-label" : {
                    width : "1%",
                },
                "form-value" : {
                    width : "99%",
                },
            };
            if (style["width"] == null) {
                style["width"] = "500px";
            }
            if (style["height"] == null) {
                autoHeight = itemDef.length * 40;
                style["height"] = autoHeight + "px";
            }
            var self = this;
            require(["af/scripts/controls/FormDialog"], function(FormDialog) {
                var dialog = new FormDialog({
                    title   : title,
                    message : description,
                    items   : itemDef,
                    buttons : buttonDef,
                    style   : style,
                    callback : function(value, data) {
                        if (callback != null) {
                            try {
                                callback(value, data);
                            }
                            catch (x) {
                                console.error(x);
                            }
                        }
                    },
                });
                dialog.show();
                if (autoHeight != null) {
                    domStyle.set(dialog._dialog.dialogContentNode, "height", autoHeight+"px");
                }
            });
        },
        
        showMessage : function(category, title, message, callback) {
            var self = this;
            var growlManager = this.controller && this.controller.appController && this.controller.appController.main && this.controller.appController.main.growlManager;
            require(["af/controls/AppMessageBox"], function(AppMessageBox) {
                var buttonCount = 1;
                switch (category) {
                    case "growl"   : buttonCount = 0; break;
                    case "confirm" : buttonCount = 2; break;
                    case "warn"    : buttonCount = 1; break;
                    case "error"   : buttonCount = 1; break;
                    default        : buttonCount = 1; break;
                }
                if (buttonCount > 0) {
                    var alert = new AppMessageBox({
                        title   : title,
                        message : message,
                        buttons : buttonCount,
                        okHandler: function() {
                            if (callback != null) {
                                try {
                                    callback(true);
                                }
                                catch (x) {
                                    console.error(x);
                                }
                            }
                        },
                        cancelHandler: function() {
                            if (callback != null) {
                                try {
                                    callback(false);
                                }
                                catch (x) {
                                    console.error(x);
                                }
                            }
                        }
                    });
                    alert.show();
                }
                else if (growlManager) {
                    var growlText = "";
                    if (title != null && title != "") {
                        growlText = "<b><big>" + title + "</big></b><br><hr>";
                    }
                    growlText += message;
                    growlManager.addGrowl(growlText);
                    if (callback != null) {
                        try {
                            callback(true);
                        }
                        catch (x) {
                            console.error(x);
                        }
                    }
                }
            });
        },
]]>
        </CodeText>
        <CodeText segment="#doRefresh">
          <![CDATA[
            var data = this.renderer.result;
            if (data != null && data.length == 1) {
                if (data[0]["NuovaStella"] != null) {
                    this._plugin = data[0]["NuovaStella"];
                }
                if (data[0]["project"] != null) {
                    this._project = data[0]["project"];
                    this._urlText.set("value", this._project.hdfsServerURL, false);
                    this._doConnect();
                }
            }
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            var node = this.domNode;
            while (node != null) {
                if (domClass.contains(node, "appDialogCenter")) {
                    // found it
                    if (node.nextElementSibling != null) {
                        var footerTd = node.nextElementSibling.firstElementChild;
                        if (footerTd != null) {
                            this._statusSpan = domConstruct.create("span", {
                                style : "padding-left:5px;font-size:12px;font-style:italic;",
                            });
                            footerTd.insertBefore(this._statusSpan, footerTd.firstElementChild);
                            break;
                        }
                    }
                }
                node = node.parentElement;
            }

            this.doRefresh();

            this._parserStatus = "UNKNOWN";
            var self = this;
            this._plugin.getRuntimeStatus(this._project, "Default", function(response) {
                if (response.status == "OK") {
                    self._parserStatus = response.value.rtParserStatus;
                    if (response.value.rtParserStatus == "ACTIVE" || response.value.serviceParserStatus == "ACTIVE") {
                        self._parserStatus = "ACTIVE";
                    }
                    self._generateDataBtn.set("disabled", self._parserStatus != "ACTIVE");
                }
            });
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            this._sessionId = generateRandomUuid();
            this._project = null;
            this._isConnected = false;
            this._modelIsDirty = false;
            this._scriptIsDirty = false;
            
            this._plugin = Plugin();
            this._hdfsPlugin = Plugin("VIA - HDFS Interface");
            this._commonPlugin = Plugin("VIA - Common");
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[
    function getSelectedItems(grid, keyField)
    {
        var items = [];
        for (var i=0; i<grid.collection.data.length; i++) {
            var item = grid.collection.data[i];
            if (grid.selection[item[keyField]] == true) {
                items.push(item);
            }
        }
        return items;
    }

    function createTestGrid(name, parentNode, onSelect, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            if (parentNode == null) return;

            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            for (var i=0; i<data.length; i++) {
                data[i]["__index__"] = String(i);
            }
            
            var NAMES  = ["name",    "size",     "status"];
            var LABELS = ["Name",    "Size",     "Status"];
            var WIDTH  = ["300px",   "100px",    "300px"];
            var columns = [];
            for (var i=0; i<NAMES.length; i++) {
                columns.push({
                    field    : NAMES[i],
                    label    : LABELS[i],
                    style    : "font-family:monospace;cursor:pointer;width:" + WIDTH[i] + ";",
                    sortable : false,
                });
            }
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store, onSelect, null, "extended", onSelect, null);
            callback({
                store : store,
                grid  : grid,
            });
        });
    }

    function loadAceLib(callback)
    {
        if (window.ace == undefined) {
            require(["af/utils/proxies/Ace", "dojo/domReady!"], function(AceLib) {
                var proxy = new AceLib();
                proxy.load('default').then(function() {
                    callback();
                });
            });
        }
        else {
            callback();
        }
    }

    function createAceEditor(parentNode, mode, value, onChangeCallback, callback)
    {
        loadAceLib(function() {
            var container = domConstruct.create("div", {
                "style" : "display:block;width:100%;height:100%;",
            });
            parentNode.appendChild(container);
            var editor = ace.edit(container);
            editor.setTheme("ace/theme/chrome");
            editor.getSession().setMode(mode);
            editor.getSession().setTabSize(4);
            editor.setKeyboardHandler(null);
            editor.setShowPrintMargin(false);
            editor.getSession().setUseWrapMode(false);                
            editor.setBehavioursEnabled(true);
            ace.config.loadModule('ace/ext/language_tools', function() { 
                editor.setOptions({ 
                    enableBasicAutocompletion: true, 
                    enableSnippets: true 
                });
            });
            editor.setValue(value + "\n\n", -1);
            editor.clearSelection();
            if (onChangeCallback == null) {
                editor.setReadOnly(true);
            }
            else {
                editor.getSession().on('change', onChangeCallback);
            }
            callback(editor);
        });
    }

    function createScriptEditor(parentNode, value, onChangeCallback, callback)
    {
        var header = domConstruct.create("div", {
            "style" : "width:100%;height:25px;padding-top:5px;font-size:14px;font-family:Courier New;font-weight:bold;",
        });
        header.innerHTML = "function formatTestData(data) {"
        parentNode.appendChild(header);

        var content = domConstruct.create("div", {
            "class" : "via-scroller",
            "style" : "width:100%;height:calc(100% - 200px);",
        });
        parentNode.appendChild(content);

        var footer = domConstruct.create("div", {
            "style" : "width:100%;height:25px;padding-top:5px;font-size:14px;font-family:Courier New;font-weight:bold;",
        });
        footer.innerHTML = "}"
        parentNode.appendChild(footer);

        var result = domConstruct.create("textarea", {
            "style"    : "width:calc(100% - 10px);height:130px;font-family:Courier New;white-space:pre;",
            "readonly" : true,
            "class"   : "via-scroller",
        });
        parentNode.appendChild(result);

        createAceEditor(content, "ace/mode/javascript", value, onChangeCallback, function(editor) {
            callback({
                editor : editor,
                result : result,
            });
        });
    }
]]>
        </CodeText>
        <CodeText segment="#updateWidthAndHeight">
          <![CDATA[
            if (this._testDataWidget != null) {
                this._testDataWidget.grid.resize();
            }
            
            if (this._testModelWidget != null) {
                this._testModelWidget.resize();
            }

            if (this._testScriptWidget != null) {
                this._testScriptWidget.resize();
            }
]]>
        </CodeText>
        <CodeText segment="#destroy">
          <![CDATA[
            if (this._viewTestsTimeout != null) {
                window.clearTimeout(this._viewTestsTimeout);
                delete this._viewTestsTimeout;
            }

            if (this._isConnected && this._project != null) {
                this._isConnected = false;
                var parameters = {
                    url : this._project.hdfsServerURL,
                };
                var self = this;
                this._hdfsPlugin.executeCommand(this._sessionId, "closeFileSystem", parameters, function(response) {
                    console.debug("closeFileSystem: sessionId=" + self._sessionId);
                });
            }
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="test-widget" style="width:100%;height:100%;border:none;background-color:white;">
    <style>
    </style>
    <table cellspacing="0" data-dojo-attach-point="_headerTable" style="width:100%;height:50px;border:none;background-color:white;padding:0px 0px 10px 0px;">
        <tr style="width:100%;height:100%;">
            <td style="white-space:nowrap;text-align:right;">HDFS URL:</td>
            <td style="width:100%;padding-left:5px;padding-right:5px;">
                <input type="text" style="width:100%;font-family:monospace;" readonly="true" disabled="disabled"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_urlText"/>
            </td>
            <td data-dojo-attach-point="_tdStatus" style="font-style:italic;color:gray;padding-left:5px;padding-right:5px;min-width:100px;">
            </td>
        </tr>
    </table>
    <div data-dojo-attach-point="_divContent" style="width:100%;height:calc(100% - 80px);" class="">
    </div>
    <table cellspacing="0" data-dojo-attach-point="_headerTable" style="width:100%;height:25px;border:none;background-color:white;padding:5px 0px 0px 0px;">
        <tr style="width:100%;height:100%;">
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_viewTestsBtn" data-dojo-attach-event="click:_onClickViewTests" type="button">View Tests</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_uploadTestBtn" data-dojo-attach-event="click:_onClickUploadTest" type="button">Upload</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_downloadTestBtn" data-dojo-attach-event="click:_onClickDownloadTest" type="button">Download</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteTestsBtn" data-dojo-attach-event="click:_onClickDeleteTests" type="button">Delete</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_editModelBtn" data-dojo-attach-event="click:_onClickEditModel" type="button">Edit Model</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_generateDataBtn" data-dojo-attach-event="click:_onClickGenerateData" type="button">Generate</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_exportDataBtn" data-dojo-attach-event="click:_onClickExportData" type="button">Export Data</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_epochTimeBtn" data-dojo-attach-event="click:_onClickEpochTime" type="button">Get Epoch</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_editScriptBtn" data-dojo-attach-event="click:_onClickEditScript" type="button">Edit Script</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_testScriptBtn" data-dojo-attach-event="click:_onClickTestScript" type="button">Test Script</button>
            </td>
            <td style="width:100%;"></td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_saveEditBtn" data-dojo-attach-event="click:_onClickSaveEdit" type="button">Save</button>
            </td>
            <td style="text-align:center;">
                <button data-dojo-type="dijit/form/Button" data-dojo-attach-point="_cancelEditBtn" data-dojo-attach-event="click:_onClickCancelEdit" type="button">Cancel</button>
            </td>
        </tr>
    </table>
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="WorkbenchWidget" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#postCreate">
          <![CDATA[
            var self = this;
 
            this._showDebugTabs = false;
            this._createViewTabs(false, null);

            this._plugin.getADFTimezoneList(function(response) {
                if (response.status == "OK") {
                    var options = [];
                    response.value.forEach(function(item) {
                        options.push({
                            value : item.value,
                            label : item.label,
                        });
                    });
                    self._timezone.addOption(options);
                    self._timezone.set("value", "Etc/GMT", false);
                }
            });

            this._enrichSource.set("disabled", true);
            this._enrichDatabase.set("disabled", true);
            this._enrichTable.set("disabled", true);
            this._enrichJoinType.set("disabled", true);

            this._delimiterType.set("value", "csv");
            this._delimiter.set("value", "");
            this._delimiter.set("disabled", true);

            this.updateWidthAndHeight(this.vtWidth, this.vtHeight);
            this._showViewDiv();

            this._filenameFilter.set("regExp", "^(?!.*(\:|\\?|<|>|\\||\"|\\*|/|\\\\)).*$", false);
            this._filenameFilter.set("invalidMessage", "Suffix can not contain :, ?, <, >, |, \", *, /, \\.", false);
            
            domStyle.set(this.domNode, {
                "pointer-events" : "none",
                "opacity"        : 0.5
            });
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[    function createGrid(name, parentNode, onSelect, data)
    {
        var div = domConstruct.create("div", {});
        parentNode.appendChild(div);
        
        var columns = [{
            field : "name",
            label : "Name",
            style : "font-family:monospace;cursor:pointer;",
            sortable : true,
        }];
        var store = GridUtil.createGridStore("name", data);
        var grid = GridUtil.createGridWidget(name, div, false, null, columns, store,
                                             onSelect, null, "single", onSelect, null);
        grid.set('sort', 'name');
        return {
            store : store,
            grid  : grid,
        };
    }

    function getSelectedItems(grid, keyField)
    {
        var items = [];
        for (var i=0; i<grid.collection.data.length; i++) {
            var item = grid.collection.data[i];
            if (grid.selection[item[keyField]] == true) {
                items.push(item);
            }
        }
        return items;
    }

    function createSchemaGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [{
                field : "ignore",
                label : "(ignore)",
                style : "font-family:monospace;cursor:pointer;width:60px;text-align:center;filter:hue-rotate(150deg)!important;",
                sortable : false,
                autoSave : true,
                editor : CheckBox,
                editorArgs : {
                    value : true
                },
            }, {
                field : "name",
                label : "Name",
                style : "font-family:monospace;cursor:pointer;",
                sortable : true,
            }, {
                field : "label",
                label : "Label *",
                style : "font-family:monospace;cursor:pointer;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;",
                },
            }, {
                field : "data_type",
                label : "Data Type *",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "integer", label: "integer"},
                        {value: "long", label: "long"},
                        {value: "float", label: "float"},
                        {value: "double", label: "double"},
                        {value: "boolean", label: "boolean"},
                        {value: "string", label: "string"},
                        {value: "datetime", label: "datetime"},
                        {value: "date", label: "date"},
                        {value: "time", label: "time"}
                    ]
                },
            }, {
                field : "format",
                label : "Format *",
                style : "font-family:monospace;cursor:pointer;width:250px;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;",
                },
            }, {
                field : "optional",
                label : "Optional",
                style : "font-family:monospace;cursor:pointer;width:60px;text-align:center;",
                sortable : false,
                autoSave : true,
                editor : CheckBox,
                editorArgs : {
                    value : true
                },
            }, {
                field : "attr_type",
                label : "Attribute Type *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "N/A", label: "N/A"},
                        {value: "timestamp", label: "timestamp"},
                        {value: "dimension", label: "dimension"},
                        {value: "measure", label: "measure"},
                        {value: "metric", label: "metric"},
                    ]
                },
            }];

            addIndexAttribute(data);
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "extended", onSelect, null);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
            });
        });
    }

    function createResultGrid(name, parentNode, onSelect, schema, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [];
            schema.forEach(function(field) {
                if (field.ignore != true) {
                    columns.push({
                        field : field.name,
                        label : field.label,
                        style : "font-family:monospace;cursor:pointer;width:150px;",
                        sortable : true,
                    });
                }
            });

            addIndexAttribute(data);
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "single", onSelect, null);
            callback({
                store : store,
                grid  : grid,
            });
        });
    }

    function createPivotGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select", "dijit/form/ValidationTextBox"], function(CheckBox, TimeTextBox, Select, ValidationTextBox) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [];
            if (data.metric != null && data.measures.length == 1) {
                // metric-based
            }
            else if (data.measures.length == 0) {
                // event-based
            }
            else {
                // measure columns
                columns.push({
                    field : "__include__",
                    label : "(Y/N)",
                    style : "font-family:monospace;cursor:pointer;width:40px;text-align:center;",
                    sortable : true,
                    autoSave : true,
                    editor : CheckBox,
                    editorArgs : {
                        value : true
                    },
                });
            }
            columns.push({
                field : "__timestamp_label__",
                label : "(Timestamp)",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
            });
            if (data.metric != null && data.measures.length == 1) {
                // metric-based
                columns.push({
                    field : "__metric_column__",
                    label : "(Metric Name Column)",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                });
                columns.push({
                    field : "__metric_value__",
                    label : "(Metric Value Column)",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                });
                columns.push({
                    field : "__source_metric_name__",
                    label : "(Source Metric Name) *",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
                columns.push({
                    field : "__target_metric_name__",
                    label : "(Target Metric Name) *",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
                columns.push({
                    field : "__metric_label__",
                    label : "(Metric Label)",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
            }
            else if (data.measures.length == 0) {
                // event-based
                columns.push({
                    field : "__metric_name__",
                    label : "(Metric Name) *",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
                
                columns.push({
                    field : "__metric_label__",
                    label : "(Metric Label)",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
            }
            else {
                // measure columns
                columns.push({
                    field : "__metric_value__",
                    label : "(Metric Value Column)*",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
                
                columns.push({
                    field : "__metric_name__",
                    label : "(Metric Name) *",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
                columns.push({
                    field : "__metric_label__",
                    label : "(Metric Label)",
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                    autoSave : true,
                    editor : ValidationTextBox,
                    editOn : 'dblclick',
                    editorArgs: {
                        style: "font-family:Courier New;width:150px;",
                        required : true,
                        pattern : '[a-zA-Z0-9_\\- ]+'
                    },
                });
            }

            columns.push({
                field : "__metric_type__",
                label : "(Metric Type) *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "integer", label: "integer"},
                        {value: "long", label: "long"},
                        {value: "float", label: "float"},
                        {value: "double", label: "double"}
                    ]
                },
            });
            columns.push({
                field : "__metric_uom__",
                label : "(Unit) *",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;width:150px;",
                },
            });
            columns.push({
                field : "__ingestion_metric_aggr__",
                label : "(Ingestion Aggregation) *",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "sum", label: "Sum"},
                        {value: "avg", label: "Average"},
                        {value: "min", label: "Min"},
                        {value: "max", label: "Max"},
                    ]
                },
            });
            columns.push({
                field : "__metric_aggr__",
                label : "(Aggregation) *",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "sum", label: "Sum"},
                        {value: "avg", label: "Average"},
                        {value: "min", label: "Min"},
                        {value: "max", label: "Max"},
                    ]
                },
            });
            for (var i=0; i<data.dimensions.length; i++) {
                var field = data.dimensions[i];
                columns.push({
                    field : field.name,
                    label : field.label,
                    style : "font-family:monospace;cursor:pointer;width:150px;",
                    sortable : true,
                });
            }

            addIndexAttribute(data.pivot);
            var store = GridUtil.createGridStore("__index__", data.pivot);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "extended", onSelect, null);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
                newRow : Object.assign({}, store.fetchSync()[0], overrideProperties())
            });
            
            function overrideProperties(){
                if(data.metric){
                    return { 
                        '__target_metric_name__' : "", 
                        '__source_metric_name__' : "", 
                    };
                }else{
                    return {
                        "__metric_name__" : "",
                        "__metric_label__" : ""
                    };
                }
            }
        });
        
    }

    function createCountGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/Select", "dijit/form/ValidationTextBox"], function(Select, ValidationTextBox) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

            var columns = [{
                field : "metricName",
                label : "Metric Name *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : ValidationTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;",
                    required : true,
                    pattern : '[a-zA-Z0-9_\\- ]+'
                },
            }, {
                field : "metricLabel",
                label : "(Metric Label)",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : ValidationTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;width:100px;",
                    required : true,
                    pattern : '[a-zA-Z0-9_\\- ]+'
                },
            }, {
                field : "fieldName",
                label : "Field Name",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
            }, {
                field : "matchValues",
                label : "Match Values",
                style : "font-family:monospace;cursor:pointer;width:400px;",
                sortable : true,
            }];

            addIndexAttribute(data);
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "extended", onSelect, null);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
            });
        });
    }
    
    function createEnrichGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/Select", "dijit/form/ValidationTextBox"], function(CheckBox, Select, ValidationTextBox) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

        	var ReloadOptionSelect = declare([Select], {
        		// overwrite the method to let reload options every time.
        		isLoaded: function(){
        			return false;
        		}        		
        	});

            var columns = [];
            columns.push({
                field : "include",
                label : " ",
                style : "font-family:monospace;cursor:pointer;width:40px;text-align:center;",
                sortable : true,
                autoSave : true,
                editor : CheckBox,
                editorArgs : {
                    value : true
                },
            });
            columns.push({
                field : "leftField",
                label : "Left Field *",
                style : "font-family:monospace;cursor:pointer;width:200px;",
                sortable : true,
                autoSave : true,
                editor : ReloadOptionSelect,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                },
            });
            columns.push({
                field : "rightColumn",
                label : "Right Column",
                style : "font-family:monospace;cursor:pointer;width:200px;",
                sortable : true,
            });
            columns.push({
                field : "rightField",
                label : "Right Column Alias *",
                style : "font-family:monospace;cursor:pointer;width:200px;",
                sortable : true,
                autoSave : true,
                editor : ValidationTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "font-family:Courier New;",
                    required : true,
                    pattern : '[a-zA-Z0-9_ ]+'
                },
                
            });            
            columns.push({
                field : "type",
                label : "Type",
                style : "font-family:monospace;cursor:pointer;width:200px;",
                sortable : true,
                autoSave : true,
                editor : ReloadOptionSelect,
                editOn: "dblclick",
                editorArgs: {
                    style: "width:100%;",
                },
            });
            
            addIndexAttribute(data.joinClause);
            var store = GridUtil.createGridStore("__index__", data.joinClause);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "extended", onSelect, null);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
            });
        });
    }
    
    function getOutputDeriveColumns() {
        return [{
            field : "name",
            label : "Name",
            style : "font-family:monospace;cursor:pointer;width:150px;",
            type : 'text',
            canEdit : function(obj, val) {
                return obj.__reserved__ != true;
            },
        }, {
            field : "label",
            label : "Label *",
            style : "font-family:monospace;cursor:pointer;width:250px;",
            type : 'text',
            canEdit : function(obj, val) {
                return obj.__reserved__ != true;
            }
        }, {
            field : "type",
            label : "Data Type *",
            style : "font-family:monospace;cursor:pointer;width:150px;",
            type : 'select',
            canEdit : function(obj, val) {
                return obj.__reserved__ != true;
            },
            options: [
                {value: "integer", label: "integer"},
                {value: "long", label: "long"},
                {value: "float", label: "float"},
                {value: "double", label: "double"},
                {value: "boolean", label: "boolean"},
                {value: "string", label: "string"},
                {value: "datetime", label: "datetime"},
                {value: "date", label: "date"},
                {value: "time", label: "time"}
            ]
        }, {
            field : "expr",
            label : "Expression *",
            style : "font-family:monospace;cursor:pointer;width: calc(100% - 650px)",
            type : 'sle',
            canEdit : function(obj, val) {
                return obj.__reserved__ != true;
            },
        }, {
            field : "isDimension",
            label : "Dimension",
            style : "font-family:monospace;cursor:pointer;width:100px;",
            type : 'checkbox',
            canEdit : function(obj, val) {
                return obj.__reserved__ != true;
            }                
        }];
    }

    function createOutputGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox",  "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [{
                field : "name",
                label : "Name",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                canEdit : function(obj, val) {
                    return obj.__reserved__ != true;
                },
                editorArgs: {
                    style: "font-family:Courier New;",
                },
                renderCell: function(object, value, node, options) {
                    node.innerHTML = object.name;
                },
            }, {
                field : "label",
                label : "Label *",
                style : "font-family:monospace;cursor:pointer;width:250px;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                canEdit : function(obj, val) {
                    return obj.__reserved__ != true;
                },
                editorArgs: {
                    style: "font-family:Courier New;",
                },
            }, {
                field : "type",
                label : "Data Type *",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
                autoSave : true,
                editor : Select,
                editOn: "dblclick",
                canEdit : function(obj, val) {
                    return obj.__reserved__ != true;
                },
                editorArgs: {
                    style: "width:100%;",
                    options: [
                        {value: "integer", label: "integer"},
                        {value: "long", label: "long"},
                        {value: "float", label: "float"},
                        {value: "double", label: "double"},
                        {value: "boolean", label: "boolean"},
                        {value: "string", label: "string"},
                        {value: "datetime", label: "datetime"},
                        {value: "date", label: "date"},
                        {value: "time", label: "time"}
                    ]
                },
            }, {
                field : "expr",
                label : "Expression *",
                style : "font-family:monospace;cursor:pointer;",
                sortable : true,
                autoSave : true,
                editor : 'text',
                editOn : 'dblclick',
                canEdit : function(obj, val) {
                    return obj.__reserved__ != true;
                },
                editorArgs: {
                    style: "font-family:Courier New;",
                },
            }, {
                field : "isDimension",
                label : "Dimension",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : CheckBox,
                editorArgs : {
                    value : true
                },
                canEdit : function(obj, val) {
                    return obj.__reserved__ != true;
                }                
            }];

            var config = {
                renderRow : function(object) {
                    var rowElement = this.inherited(arguments);
                    if (object.__reserved__ == true) {
                        domClass.add(rowElement, "reserved-row");
                    }
                    else {
                        domClass.remove(rowElement, "reserved-row");
                    }
                    return rowElement;
                },
            };

            addIndexAttribute(data);
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "extended", onSelect, config);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
            });

        });
    }

    function createSubserviceGrid(name, parentNode, onSelect, onChange, data, callback) {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox", "dijit/form/Select", "dijit/form/ValidationTextBox"], function(CheckBox, TimeTextBox, Select, ValidationTextBox) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

            var columns = [{
                field: "svc",
                label: "Service",
                style: "font-family:monospace;cursor:pointer;width:80px",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    pattern: Plugin().nameConstraints().svc.patternContent,
                    invalidMessage: Plugin().nameConstraints().svc.patternMismatch,
                    required: true,
                    missingMessage: 'Service can not be empty'
                }
            }, {
                field: "svcLabel",
                label: "Service Label",
                style: "font-family:monospace;cursor:pointer;",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    required: true,
                    missingMessage: 'Service Label can not be empty'
                }
            }, {
                field: "subSvc",
                label: "Sub-Service",
                style: "font-family:monospace;cursor:pointer;width:110px",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    pattern: Plugin().nameConstraints().comp.patternContent,
                    invalidMessage: Plugin().nameConstraints().comp.patternMismatch,
                    required: true,
                    missingMessage: 'Sub-Service can not be empty'
                }
            }, {
                field: "subSvcLabel",
                label: "Sub-Service Label",
                style: "font-family:monospace;cursor:pointer;",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    required: true,
                    missingMessage: 'Sub-Service Label can not be empty'
                }
            }, {
                field: "comp",
                label: "Component",
                style: "font-family:monospace;cursor:pointer;width: 110px",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    pattern: Plugin().nameConstraints().app.patternContent,
                    invalidMessage: Plugin().nameConstraints().app.patternMismatch,
                    required: true,
                    missingMessage: 'Component can not be empty'
                }
            }, {
                field: "compLabel",
                label: "Component Label",
                style: "font-family:monospace;cursor:pointer;",
                sortable: true,
                autoSave: true,
                editor: ValidationTextBox,
                editOn: 'dblclick',
                editorArgs: {
                    required: true,
                    missingMessage: 'Component Label can not be empty'
                }
            }];

            addIndexAttribute(data);

            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                onSelect, null, "extended", onSelect);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store: store,
                grid: grid,
            });
        });
    }

    function createQDCGrid(name, parentNode, onSelect, onChange, project, data, callback) {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox", "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

            var columns = [{
                field: "type",
                label: "Type",
                style: "font-family:monospace;cursor:pointer;width:250px;",
                sortable: true,
            }, {
                field: "name",
                label: "Dimension",
                style: "font-family:monospace;cursor:pointer;width:150px;",
                sortable: true,
            }, {
                field: "_oper_",
                label: "Oper",
                style: "font-family:monospace;cursor:pointer;width:100px;",
                sortable: true,
            }, {
                field: "_value_",
                label: "Value/SQL/Regex/JSON",
                style: "font-family:monospace;cursor:pointer;",
                sortable: true,
            }];

            addIndexAttribute(data);
            addQDCDisplayAttributes(project, data);

            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                onSelect, null, "extended", onSelect);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store: store,
                grid: grid,
            });
        });
    }

    function createMetricGrid(name, parentNode, onSelect, onChange, project, data, callback) {
        require(["dijit/form/CheckBox", "dijit/form/TimeTextBox", "dijit/form/Select"], function(CheckBox, TimeTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

            var columns = [{
                field: "_metricName_",
                label: "Metric Name",
                style: "font-family:monospace;cursor:pointer;width:200px;",
                sortable: true,
            }, {
                field: "_metricLabel_",
                label: "Metric Label",
                style: "font-family:monospace;cursor:pointer;width:200px;",
                sortable: true,
            }, {
                field: project.svc + "|" + project.comp + "|" + project.app,
                label: project.svc + "|" + project.comp + "|" + project.app,
                style: "font-family:monospace;cursor:pointer;width:100px;",
                sortable: true,
                autoSave: true,
                editor: CheckBox,
                editorArgs: {
                    value: true
                },
            }];
            for (var i = 0, n = project.subservices.length; i < n; i++) {
                var subservice = project.subservices[i];
                columns.push({
                    field: subservice.svc + "|" + subservice.subSvc + "|" + subservice.comp,
                    label: subservice.svc + "|" + subservice.subSvc + "|" + subservice.comp,
                    style: "font-family:monospace;cursor:pointer;width:100px;",
                    sortable: true,
                    autoSave: true,
                    editor: CheckBox,
                    editorArgs: {
                        value: true
                    },
                });
            }

            addIndexAttribute(data);

            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                onSelect, null, "extended", onSelect);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store: store,
                grid: grid,
            });
        });
    }
    
    function createIncidentConfigGrid(name, parentNode, onSelect, onChange, data, callback)
    {
        require(["dijit/form/CheckBox", "dijit/form/NumberTextBox",  "dijit/form/Select"], function(CheckBox, NumberTextBox, Select) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);
            
            var columns = [{
                field : "metricId",
                label : "Metric ID",
                style : "font-family:monospace;cursor:pointer;width:250px;",
                sortable : true,
            }, {
                field : "settingDescription",
                label : "Description",
                style : "width:250px;",
                sortable : true,
            }, {
                field : "incidentAlgorithm",
                label : "Algorithm",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
            }, {
                field : "incidentThresholdPolicy",
                label : "Threshold Policy",
                style : "font-family:monospace;cursor:pointer;width:150px;",
                sortable : true,
            }, {
                field : "incidentHighThreshold",
                label : "High Threshold *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }, {
                field : "incidentMediumThreshold",
                label : "Medium Threshold *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }, {
                field : "incidentLowThreshold",
                label : "Low Threshold *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }, {
                field : "incidentWarmupThreshold",
                label : "Warmup Threshold *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }, {
                field : "incidentWarmupPeriod",
                label : "Warmup Period *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }, {
                field : "incidentCooldownPeriod",
                label : "Cooldown Period *",
                style : "font-family:monospace;cursor:pointer;width:100px;",
                sortable : true,
                autoSave : true,
                editor : NumberTextBox,
                editOn : 'dblclick',
                editorArgs: {
                    style: "width:100%;font-family:Courier New;",
                },
            }];

            addIndexAttribute(data);
            var store = GridUtil.createGridStore("__index__", data);
            var grid = GridUtil.createGridWidget(name, div, true, null, columns, store,
                                                 onSelect, null, "single", onSelect, null);
            if (onChange != null) {
                grid.on("dgrid-datachange", onChange);
            }
            callback({
                store : store,
                grid  : grid,
            });
        });
    }

    function initPipeFunctions(controller, callback)
    {
        require(["spark/utils/PipeUtil", "spark/utils/FunctionUtil"], function(PipeUtil, FunctionUtil) {
            if (PipeUtil.getFunctionList() == null) {
                PipeUtil.loadFunctions(controller, function() {
                    FunctionUtil.loadFunctionList(function() {
                        callback();
                    });
                });
            }
            else {
                callback();
            }
        });
    }

    function createFlowModelWidget(controller, parentNode, callback)
    {
        require(["spark/panels/widgets/FlowModelEditorWidget", "af/utils/ModelUtil", "spark/utils/DpUtil"], function(FlowModelEditorWidget, ModelUtil, DpUtil) {
            var div = domConstruct.create("div", {});
            parentNode.appendChild(div);

            var model = XmlParser.parse(controller.item.content).documentElement;
            DpUtil.decodeModel(controller, model);

            var widget = new FlowModelEditorWidget({
                controller : controller,
            }, div);
            widget.startup();
            
            var box = domGeom.getContentBox(parentNode);
            widget.updateWidthAndHeight(box.w, box.h);
            
            callback(widget);
        });
    }

    function formatXML(arg, options) {
    	if (arg == null || arg == "") return "";
    	var xml;
        var argtype = typeof arg;
        if (argtype == "string") {
			xml = XmlParser.parse(arg).documentElement;
        }
        else {
        	xml = arg;
        }
        var defaultOptions = {
            INDENT : "  ",
            LENGTH : 0,
        };
        options = lang.mixin(lang.clone(defaultOptions), options || {});
        var buf = [];
   		prettyPrintXML(buf, "", xml, options);
   		return buf.join("\n");
    };

    function escapeDoubleQuotes(str)
    {
        return str.replace(/\"/g, "&quot;");
    }

	function prettyPrintXML(buf, indent, element, options)
	{
		var open = indent + "<" + element.nodeName;
		var openLen = open.length;
		array.forEach(element.attributes, function(attr, index) {
		    var attrStr = " " + attr.nodeName + "=\"" + escapeDoubleQuotes(attr.nodeValue) + "\"";
		    if ((options.LENGTH > 0) && (open.length > openLen) && ((open.length + attrStr.length) > options.LENGTH)) {
		        buf.push(open);
		        open = (new Array(openLen+1)).join(" ");
		    }
			open += attrStr;
		});
		if (hasComplexContent(element)) {
			open += ">";
			buf.push(open);
            dojo.forEach(element.childNodes, function(child) {
            	if (child.nodeType == 1) {
            		prettyPrintXML(buf, indent + options.INDENT, child, options);
            	}
            });
			var close = indent + "</" + element.nodeName + ">";
			buf.push(close);
		}
		else {
			var nodeText = AppUtil.getNodeText(element);
			if (nodeText == "") {
				open += "/>";
			}
			else {
				open += ">" + nodeText + "</" + element.nodeName + ">";
			}
			buf.push(open);
		}
	}

	function hasComplexContent(element)
	{
        var childList = element.childNodes;
        for (var i=0; i<childList.length; i++){
        	var child =  childList[i];
        	if (child.nodeType == 1) {
         		return true;
        	}
        }
        return false;
 	}

    function loadAceLib(callback)
    {
        if (window.ace == undefined) {
            require(["af/utils/proxies/Ace", "dojo/domReady!"], function(AceLib) {
                var proxy = new AceLib();
                proxy.load('default').then(function() {
                    callback();
                });
            });
        }
        else {
            callback();
        }
    }

    function createAceEditor(parentNode, mode, value, readonly, callback)
    {
        loadAceLib(function() {
            var container = domConstruct.create("div", {
                "style" : "display:block;width:100%;height:100%;",
            });
            parentNode.appendChild(container);
            var editor = ace.edit(container);
            editor.setTheme("ace/theme/chrome");
            editor.getSession().setMode(mode);
            editor.getSession().setTabSize(4);
            editor.setKeyboardHandler(null);
            editor.setShowPrintMargin(false);
            editor.getSession().setUseWrapMode(false);                
            editor.setBehavioursEnabled(true);
            editor.setReadOnly(readonly);
            ace.config.loadModule('ace/ext/language_tools', function() { 
                editor.setOptions({ 
                    enableBasicAutocompletion: true, 
                    enableSnippets: true 
                });
            });
            editor.setValue(value + "\n\n", -1);
            editor.clearSelection();
            callback(editor);
        });
    }

    function createTextArea(parentNode, value, callback)
    {
        var textarea = domConstruct.create("textarea", {
            style : "width:calc(100% - 5px);height:100%;font-family:Courier;",
            spellcheck : false,
            "class" : "via-scroller",
        });
        textarea.value = value;
        parentNode.appendChild(textarea);
        callback(textarea);
    }
    
    function createPopupDialogButton(parentNode, buttonLabel, buttonStyle, dialogTitle, dialogWidth, dialogHeight, widgetPath, widgetConfig, getWidgetValue, callback)
    {
        var widget = FormUtil.createButton(parentNode, buttonLabel, buttonStyle, null, function(evt) {
            loadCustomWidgetClass(widgetPath, function(CustomWidgetClazz) {
                if (CustomWidgetClazz != null) {
                    require(["af/controls/PopupEditorDialog", "dojo/domReady!"], function(PopupDialogClazz) {
                        var dialogConfig = {
                            title        : dialogTitle,
                            vtWidth      : dialogWidth,
                            vtHeight     : dialogHeight,
                            model        : getWidgetValue(),
                            editorClass  : CustomWidgetClazz,
                            editorConfig : widgetConfig,
                            onClickOk    : callback
                        };
                        var dialog = new PopupDialogClazz(dialogConfig);
                        domAttr.set(dialog.main, {"title":""});
                        domStyle.set(dialog._widget.modelTd.domNode, "overflow", "hidden");
                        domClass.add(dialog._widget.editorTitleLabel, "popup-title-label");
                        domStyle.set(dialog._widget.editorTitleLabel, {
                            "display"     : "none",
                            "height"      : "0px",
                            "line-height" : "0px"
                        });
                        domStyle.set(dialog._dialog.resizeBtn, "display", "none");
                        domClass.add(dialog.domNode, "popup-dialog");
                        dialog.show();
                    });
                }
            });
        });
        domClass.add(widget.domNode, "popup-button-control");
        return widget;
    }

    function loadCustomWidgetClass(widgetPath, callback)
    {
        if (widgetPath.indexOf("/app/dbp/") == 0 || widgetPath.indexOf("/") == -1) {
            // user defined widget... either full path or just name
            Widget(widgetPath, function(CustomWidget) {
                callback(CustomWidget);
            });
        }
        else {
            // builtin
            require([widgetPath, "dojo/domReady!"], callback);
        }
    }
    
    function getIgnoredFields(schema)
    {
        var ignoredFields = [];
        for (var i=0, n=schema.length; i<n; i++) {
            var field = schema[i];
            if (field.ignore == true) {
                ignoredFields.push(field.name);
            }
        }
        ignoredFields.sort();
        return ignoredFields.join(",");
    }

    function addIndexAttribute(arr)
    {
        if (arr != null) {
            for (var i=0; i<arr.length; i++) {
                arr[i]["__index__"] = String(i);
            }
        }
    }

    function removeIndexAttribute(arr)
    {
        if (arr != null) {
            for (var i=0; i<arr.length; i++) {
                delete arr[i]["__index__"];
            }
        }
    }

    function addQDCDisplayAttributes(project, arr) {
        if (arr != null) {
            for (var i = 0; i < arr.length; i++) {
                var qdc = arr[i];
                switch (qdc.oper) {
                    case "EQ":
                        if (Array.isArray(qdc.value) || qdc.sql == true) {
                            qdc._oper_ = "IS IN";
                        } else {
                            qdc._oper_ = "IS EQUAL TO";
                        }
                        break;
                    case "NE":
                        if (Array.isArray(qdc.value) || qdc.sql == true) {
                            qdc._oper_ = "IS NOT IN";
                        } else {
                            qdc._oper_ = "IS NOT EQUAL TO";
                        }
                        break;
                }
                
                if (qdc.type == "JSON") {
                    qdc._value_ = JSON.stringify(qdc.value);
                } else {
                    if (Array.isArray(qdc.value)) {
                        qdc._value_ = qdc.value.join(", ");
                    } else {
                        qdc._value_ = qdc.value;
                    }
                }
            }
        }
    }

    function removeQDCDisplayAttributes(arr)
    {
        if (arr != null) {
            for (var i=0; i<arr.length; i++) {
                var qdc = arr[i];
                delete qdc._scope_;
                delete qdc._oper_;
                delete qdc._value_;
            }
        }
    }
]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        OPTION_NONE : {
            value : "",
            label : "(none)",
        },

        _initViewTabs : function() {
            var self = this;
            if (self._project.sample != null) {
                self._plugin.showDebugTabs(function(response) {
                    var showDebugTabs = response.status == "OK" && response.value == true;
                    self._loadDetail(lang.hitch(self, "_showDetail"));
                    switch (self._project.sample.type) {
                        case "text/csv":
                        case "application/vnd.ms-excel":
                            if (self._showDebugTabs != showDebugTabs || self._viewTabBar.items[0].value != "view/parse") {
                                self._showDebugTabs = showDebugTabs;
                                self._createViewTabs(false, function() {
                                    self._setSelectedView("view/parse");
                                });
                            }
                            else {
                                self._setSelectedView("view/parse");
                            }
                            self._delimiterType.set("disabled", false);
                            break;
                        case "application/json":
                            if (self._showDebugTabs != showDebugTabs || self._viewTabBar.items[0].value != "view/preprocess") {
                                self._showDebugTabs = showDebugTabs;
                                self._createViewTabs(true, function() {
                                    self._setSelectedView("view/preprocess");
                                });
                            }
                            else {
                                self._setSelectedView("view/preprocess");
                            }
                            self._delimiterType.set("disabled", true);
                            break;
                    }
                });
            }
            else {
                self._createViewTabs(false, function() {
                    self._setSelectedView("view/parse");
                    self._delimiterType.set("disabled", false);
                });
            }
        },

        _createViewTabs : function(preprocess, callback) {
            var self = this;
            var viewItems = [
                { name: "Parse",         value: "view/parse"     },
                { name: "Map",           value: "view/map"       },
                { name: "Enrich",        value: "view/enrich"    },
                { name: "Output",        value: "view/output"    },
                { name: "Partition",     value: "view/qdc"       },
                { name: "Advanced",      value: "view/advanced"  },
            ];
            if (self._showDebugTabs) {
                viewItems = viewItems.concat([
                    { name: "Data Resource", value: "model/resource" },
                    ///{ name: "Parser Model",  value: "model/parser"   },
                    ///{ name: "Anomaly Model", value: "model/anomaly"  },
                    { name: "System Model",  value: "model/system"   },
                ]);
            }
            if (preprocess) {
                viewItems.unshift({ name: "Pre-Process", value: "view/preprocess" });
            }
            if (self._viewTabBar != null) {
                self._viewTabBar.destroy();
                delete self._viewTabBar;
                AppUtil.removeAllChildrenOf(self._viewTabDiv);
            }
            require(["af/controls/tabbar/TabBarEditorWidget"], function(TabBarEditorWidget) {
                var div = domConstruct.create("div");
                self._viewTabDiv.appendChild(div);
                
                self._viewTabBar = new TabBarEditorWidget({
                    items : viewItems,
                    vtWidth : self.vtWidth,
                    vtHeight : 25,
                    editable : false,
                    navigate : false,
                    onSelectItem : lang.hitch(self, "_onSelectView"),
                }, div);
                self._viewTabBar.startup();
                
                if (callback != null) {
                    callback();
                }
                
                window.setTimeout(function() {
                    self._adjustViewTabSpacing();
                }, 100);
            });
            self._selectedView = viewItems[0]["value"];
        },

        _adjustViewTabSpacing : function() {
            var box = domGeom.getMarginBox(this._tableProjectInfo);
            var availableWidth = this.vtWidth - 2;
            var availableHeight = this.vtHeight - 25 - box.h - 8;

            for (var i=0; i<this._viewTabBar.items.length; i++) {
                if (this._viewTabBar.items[i].value == "model/resource") {
                    domStyle.set(this._viewTabBar.tabtr.children[i], {
                        "display" : "",
                        "margin-left" : (availableWidth - (this._viewTabBar.items.length*120)) + "px",
                    });
                }
            }
        },

        _setSelectedView : function(viewName) {
            for (var i=0; i<this._viewTabBar.items.length; i++) {
                if (this._viewTabBar.items[i].value == viewName) {
                    this._selectedView = viewName;
                    this._viewTabBar.setSelectedIndex(i);
                    this._showViewDiv();
                    break;
                }
            }
        },

        _onSelectTemplate : function(evt) {
            if (evt.type == "dgrid-select") {
                this._selectedTemplate = evt.rows[0].data;
            }
            else if (evt.type == "dgrid-deselect") {
                this._selectedTemplate = null;
            }
            if (this._selectedTemplate != null) {
            }
            else {
            }
        },
        
        _onChangeSvcName : function(value) {
            this._project.svc = value;
            this._project.__prjname_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
            this._updateNameDefaults();
        },
        
        _onChangeSvcLabel : function(value) {
            this._project.svcLabel = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },
        
        _onChangeCompName : function(value) {
            this._project.comp = value;
            this._project.__prjname_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
            this._updateNameDefaults();
        },
        
        _onChangeCompLabel : function(value) {
            this._project.compLabel = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },
        
        _onChangeAppName : function(value) {
            this._project.app = value;
            this._project.__prjname_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
            this._updateNameDefaults();
        },
        
        _onChangeAppLabel : function(value) {
            this._project.appLabel = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },
        
        _onChangeFilenameFilter : function(value) {
            this._project.filenameFilter = value;
            this._project.__filter_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeFilenameExtension : function(value) {
            this._project.filenameExtension = value;
            this._project.__filter_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeSourceGroup : function(value) {
            this._project.sourceGroup = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeTargetGroup : function(value) {
            this._project.targetGroup = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeNamePrefix : function(value) {
            this._project.prefix = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },
        
        _onChangeSpaceName : function(value) {
            this._project.space = value;
            this._project.__space_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },
        
        updateUrlPrefix: function (fullPath, prefix) {
            var subPath = fullPath.substring(fullPath.indexOf("/", "hdfs://".length));
            return prefix + subPath;
        },
        
        _onChangeHdfsServerURL : function(value) {
            if (value != null) {
                var index = value.indexOf("/", "hdfs://".length);
                if (index != -1) {
                    this._project.hdfsServerURL = value.substring(0, index);
                    this._hdfsServerURL.set("value", this._project.hdfsServerURL, false);
                } else {
                    this._project.hdfsServerURL = value;
                }
            } else {
                this._project.hdfsServerURL = "";
            }
            
            this._project.__hdfs_changed__ = true;
            if (this._project.anomalyFileUrl) {
                this._project.anomalyFileUrl = this.updateUrlPrefix(this._project.anomalyFileUrl, this._project.hdfsServerURL)
            }
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeTimezone : function(value) {
            this._project.timezone = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeDST : function(value) {
            this._project.dst = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeDelimiterType : function(value) {
            this._project.delimiterType = value;
            this._projectIsDirty = true;
            this._updateSelection();

            if (this._project.delimiterType == "userDef") {
                this._delimiter.set("value", this._project.delimiter, false);
                this._delimiter.set("disabled", false);
            }
            else {
                this._delimiter.set("value", "");
                this._delimiter.set("disabled", true);
            }
        },

        _onChangeDelimiter : function(value) {
            this._project.delimiter = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _updateNameDefaults : function() {
            var self = this;
            if (this._project != null) {
                this._plugin.getNameDefaults(this._project, function(response) {
                    if (response.status == "OK") {
                        if (self._nameDefaults) {
                            if (self._project.sourceGroup == self._nameDefaults.sourceGroup) {
                                self._project.sourceGroup = response.value.sourceGroup;
                            }
                            if (self._project.targetGroup == self._nameDefaults.targetGroup) {
                                self._project.targetGroup = response.value.targetGroup;
                                self._project.orginalTargetGroup = self._project.targetGroup;
                            }
                        }
                        
                        self._namePrefix.set("placeholder", "Defaults to '" + response.value.namePrefix + "'");
                        self._sourceGroup.set("placeholder", "Defaults to '" + response.value.sourceGroup + "'");
                        self._targetGroup.set("placeholder", "Defaults to '" + response.value.targetGroup + "'");
                        self._nameDefaults = response.value;
                    }
                });
            }
            else {
                self._namePrefix.set("placeholder", "");
                self._sourceGroup.set("placeholder", "");
                self._targetGroup.set("placeholder", "");
            }
        },

        compareSchema: function(sch1, sch2) {
            var len1 = 0;
            if (sch1 != null) {
                len1 = sch1.length;
            }
            if (len1 == 0) {
                return false;
            }
            
            var len2 = 0;
            if (sch2 != null) {
                len2 = sch2.length;
            }
            if (len2 ==0 ) {
                return false;
            }
            
            if (len1 != len2) {
                return false;
            }

            var map2 = {};
            array.forEach(sch2, function(item) {
                map2[item.name] = item;
            });
            var matched = true;
            array.some(sch1, function(item) {
                var name = item.name;
                if (map2[name] == null) {
                    matched = false;
                    return true;
                } else {
                    delete map2[name];
                }
            });
            
            return matched;
        },

        generateMap: function(sch) {
            var map = {};
            if (sch != null) {
                array.forEach(sch, function(item) {
                    map[item.name] = item.meta_data;
                });
            }
            return map;
        },

        _loadDetail : function(callback) {
            this._sampleName.set("value", this._project.sample.name, false);
            this._sampleType.set("value", String(this._project.sample.type), false);
            this._sampleSize.set("value", String(this._project.sample.size), false);

            var self = this;
            this._commonPlugin.pbShowProgressBar("loadProject", "Refreshing project details...");
            this._plugin.loadProject(self._project, function(response) {
                if (response.status == "OK" && response.value != null) {
                    
                    var sameSchema = false;
                    if (self._previousConfig) {
                        var sch = self._previousConfig.schema;
                        sameSchema = self.compareSchema(sch, response.value.schema);
                    }
                    
                    if (sameSchema) {
                        var meta_data_map = self.generateMap(response.value.schema);
                        self._selectedSchema = self._previousConfig.schema;
                        array.forEach(self._selectedSchema, function(item) {
                            item.meta_data = meta_data_map[item.name];
                        });
                        self._selectedPivot  = self._previousConfig.pivot;
                        self._selectedCount  = self._previousConfig.count;
                    } else {
                        self._selectedSchema = response.value.schema;
                        self._selectedPivot  = response.value.pivot;
                        self._selectedCount  = response.value.count;
                    }
                    self._selectedResult = response.value.sample;
                    self._selectedEnrich = response.value.enrich;
                    self._selectedOutput = response.value.output;
                    self._selectedQDC    = response.value.qdc;
                    self._selectedMetric = response.value.metric;

                    self._enrichSource.set("disabled", false);
                    self._enrichDatabase.set("disabled", false);
                    self._enrichTable.set("disabled", false);
                    self._enrichJoinType.set("disabled", false);
                    
                    self._enrichSource.set("value", "", false);
                    self._enrichDatabase.set("value", "", false);
                    self._enrichTable.set("value", "", false);
                    self._enrichJoinType.set("value", "LeftOuterJoin", false);
                    self._populateEnrichSourceSelect(function() {
                        self._populateEnrichDatabaseSelect(function() {
                            self._populateEnrichTableSelect(function() {

                            });
                        });
                    });
                    
                    if (self._project) {
                        var value = self._project.enrichJoinType;
                        if (value == null) value = "LeftOuterJoin";
                        self._enrichJoinType.set("value", value, false);
                    } else {
                        self._enrichJoinType.set("value", "LeftOuterJoin", false);
                    }

                    self._updateSelection();
                }
                self._commonPlugin.pbHideProgressBar("loadProject");
                callback();
            });
        },

        _showViewDiv : function() {
            domStyle.set(this._divPreProcess, "display", this._selectedView == "view/preprocess" ? "" : "none");
            domStyle.set(this._divParse,      "display", this._selectedView == "view/parse"      ? "" : "none");
            domStyle.set(this._divMap,        "display", this._selectedView == "view/map"        ? "" : "none");
            domStyle.set(this._divEnrich,     "display", this._selectedView == "view/enrich"     ? "" : "none");
            domStyle.set(this._divOutput,     "display", this._selectedView == "view/output"     ? "" : "none");
            domStyle.set(this._divQDC,        "display", this._selectedView == "view/qdc"        ? "" : "none");
            domStyle.set(this._divAdvanced,   "display", this._selectedView == "view/advanced"   ? "" : "none");
            domStyle.set(this._divResource,   "display", this._selectedView == "model/resource"  ? "" : "none");
            domStyle.set(this._divParser,     "display", this._selectedView == "model/parser"    ? "" : "none");
            domStyle.set(this._divAnomaly,    "display", this._selectedView == "model/anomaly"   ? "" : "none");
            domStyle.set(this._divSystem,     "display", this._selectedView == "model/system"    ? "" : "none");
        },

        _showDetail : function() {
            this._showViewDiv();
            switch (this._selectedView) {
                case "view/preprocess":
                    this._showPreContent();
                    this._showPreScript();
                    this._showPreResult(null, null);
                    break;
                case "view/parse":
                    var self = this;
                    this._plugin.checkInvalidColumns(this._selectedSchema, responseInvalidColumns.bind(this));
                    break;
                case "view/map":
                    this._showPivot();
                    this._showCount();
                    break;
                case "view/enrich":
                    this._showEnrich();
                    break;
                case "view/output":
                    this._showOutput();
                    break;
                case "view/qdc":
                    this._showQDC();
                    break;
                default:
                    this._viewTabBar.setSelectedIndex(0);
                    break;
            }
            
            function responseInvalidColumns(response){
                if(response.status === "Error"){
                    this.controller._scriptManager._args.message("error", "Project", response.error, showSchema.bind(this));
                }else{
                    showSchema.call(this);
                }
            }
            
            function showSchema(){
                this._showSchema(true, null);
                this._showResult();
            }
        },

        _resetDetail : function() {
            this._sampleName.set("value", "(not defined)", false);
            this._sampleType.set("value", "", false);
            this._sampleSize.set("value", "", false);

            this._previousConfig = {};
            this._previousConfig.schema = this._selectedSchema;
            this._previousConfig.pivot = this._selectedPivot;
            this._previousConfig.count = this._selectedCount;
            
            this._selectedSchema = null;
            this._selectedResult = null;
            this._selectedPivot  = null;
            this._selectedCount  = null;
            this._selectedEnrich = null;
            this._selectedOutput = null;
            this._selectedQDC    = null;
            this._outputSelection = null;
            if (this._schemaWidget != null) {
                this._schemaWidget.grid.destroy();
                delete this._schemaWidget;
                AppUtil.removeAllChildrenOf(this._divSchemaGrid);
            }
            if (this._resultWidget != null) {
                this._resultWidget.grid.destroy();
                delete this._resultWidget;
                AppUtil.removeAllChildrenOf(this._divResultGrid);
            }
            if (this._pivotWidget != null) {
                this._pivotWidget.grid.destroy();
                delete this._pivotWidget;
                AppUtil.removeAllChildrenOf(this._divPivotGrid);
            }
            if (this._countWidget != null) {
                this._countWidget.grid.destroy();
                delete this._countWidget;
                AppUtil.removeAllChildrenOf(this._divCountGrid);
            }
            if (this._enrichWidget != null) {
                this._enrichWidget.grid.destroy();
                delete this._enrichWidget;
                AppUtil.removeAllChildrenOf(this._divEnrichGrid);
            }
            if (this._enrichAspectHandler != null) {
                this._enrichAspectHandler.remove();
                this._enrichAspectHandler = null;
            }
            if (this._outputDeriveWidget != null) {
                this._outputDeriveWidget.destroy();
                delete this._outputDeriveWidget;
                AppUtil.removeAllChildrenOf(this._divOutputGrid);
            }
            if (this._subserviceWidget != null) {
                this._subserviceWidget.grid.destroy();
                delete this._subserviceWidget;
                AppUtil.removeAllChildrenOf(this._divSubserviceGrid);
            }
            if (this._qdcWidget != null) {
                this._qdcWidget.grid.destroy();
                delete this._qdcWidget;
                AppUtil.removeAllChildrenOf(this._divQDCGrid);
            }
            if (this._incidentConfigWidget != null) {
                this._incidentConfigWidget.grid.destroy();
                delete this._incidentConfigWidget;
                AppUtil.removeAllChildrenOf(this._divIncidentConfig);
            }
            
            this._divPreMimeType.innerHTML = "";
            this._divPreJsonEncoding.innerHTML = "";
            if (this._preContentEditor != null) {
                this._preContentEditor.setValue("", -1);
                this._preContentEditor.clearSelection();
            }
            if (this._preScriptEditor != null) {
                this._preScriptEditor.setValue("", -1);
                this._preScriptEditor.clearSelection();
            }
            if (this._divPreTextArea != null) {
                this._divPreTextArea.value = "";
            }

            this._enrichSource.set("disabled", true);
            this._enrichDatabase.set("disabled", true);
            this._enrichTable.set("disabled", true);
            this._enrichJoinType.set("disabled", true);
        },

        _showPreContent : function() {
            var self = this;
            this._divPreMimeType.innerHTML = this._project.sample.type;
            self._plugin.getPreContent(self._project, function(response) {
                if (response.status == "OK") {
                    var preContent = response.value;
                    switch (self._project.sample.jsonEncoding) {
                        case "FILE":
                            preContent = JSON.stringify(JSON.parse(preContent), null, "    ");
                            self._divPreJsonEncoding.innerHTML = "(Event per File)";
                            break;
                        case "LINE":
                            var lines = preContent.trim().split("\n");
                            var buf = [];
                            for (var i=0, n=lines.length; i<n; i++) {
                                if ((lines[i]).trim() != "") {
                                    buf.push(JSON.stringify(JSON.parse(lines[i]), null, "    "));
                                }
                            }
                            preContent = buf.join("\n----------------------------------------------------------------------------------------\n");
                            self._divPreJsonEncoding.innerHTML = "(Event per Line)";
                            break;
                    }
                    if (self._preContentEditor == null) {
                        createAceEditor(self._divPreContent, "ace/mode/json", preContent, false, function(editor) {
                            self._preContentEditor = editor;
                        });
                    }
                    else {
                        self._preContentEditor.setValue(preContent + "\n\n", -1);
                        self._preContentEditor.clearSelection();
                    }
                }
            });
        },

        _showPreScript : function() {
            var self = this;
            self._plugin.getPreScript(self._project, function(response) {
                if (response.status == "OK") {
                    var script = response.value;
                    if (self._preScriptEditor == null) {
                        createAceEditor(self._divPreScript, "ace/mode/javascript", script, false, function(editor) {
                            self._preScriptEditor = editor;
                        });
                    }
                    else {
                        self._preScriptEditor.setValue(script + "\n\n", -1);
                        self._preScriptEditor.clearSelection();
                    }
                }
            });
        },

        _showPreResult : function(result, callback) {
            function updatePreTextArea(value)
            {
                if (value != null) {
                    if (typeof value != "string") {
                        if (value.type && value.cols && value.data) {
                            function toCsvLine(arr) {
                                var buf = [];
                                for (var j=0, jN=arr.length; j<jN; j++) {
                                    var val = arr[j];
                                    if (val != null) {
                                        if (typeof val == "string") {
                                            buf.push('"'+val+'"');
                                        }
                                        else {
                                            buf.push(String(val));
                                        }
                                    }
                                    else {
                                        buf.push("");
                                    }
                                }
                                return buf.join(",");
                            }
                            var csv = [];
                            csv.push(toCsvLine(value.cols));
                            for (var j=0, jN=value.data.length; j<jN; j++) {
                                csv.push(toCsvLine(value.data[j]));
                            }
                            value = "[" + value.type + "]\n" + csv.join("\n");
                            if (callback) callback();
                        }
                        else {
                            value = JSON.stringify(value, null, "    ");
                        }
                    }
                    domStyle.set(self._divPreTextArea, "color", "");
                    self._divPreTextArea.value = value;
                }
                else {
                    domStyle.set(self._divPreTextArea, "color", "red");
                    self._divPreTextArea.value = "null";
                }
            }

            var self = this;
            if (result == null) {
                self._plugin.getPreResult(self._project, function(response) {
                    if (response.status == "OK") {
                        updatePreTextArea(response.value);
                    }
                    else {
                        domStyle.set(self._divPreTextArea, "color", "red");
                        self._divPreTextArea.value = response.error;
                    }
                });
            }
            else {
                updatePreTextArea(result);
            }
        },

        _onClickEvalPreScript : function(evt) {
            var self = this;
            var script = this._preScriptEditor.getValue().trim();
            self._plugin.updatePreScript(self._project, script, function(response) {
                if (response.status == "OK") {
                    self.__doEvalPreScript(script, function() {
                        self._loadDetail(function() {
                            self._resultIsDirty = true;
                            self._updateSchema(true, null);
                        });
                    });
                }
            });
        },

        __doEvalPreScript : function(script, callback) {
            var self = this;
            self._divPreTextArea.value = "";
            self._commonPlugin.pbShowProgressBar("evalPreScript", "Evaluating pre-process script...");
            self._plugin.evalPreScript(self._project, script, function(response) {
                if (response.status == "OK") {
                    self._showPreResult(response.value, callback);
                }
                else {
                    domStyle.set(self._divPreTextArea, "color", "red");
                    self._divPreTextArea.value = response.error;
                }
                self._commonPlugin.pbHideProgressBar("evalPreScript");
            });
        },

        _showSchema : function(rebuild, callback) {
            if (this._schemaWidget != null && rebuild) {
                this._schemaWidget.grid.destroy();
                delete this._schemaWidget;
                AppUtil.removeAllChildrenOf(this._divSchemaGrid);
            }
            if (this._selectedSchema == null) return;

            this._ignoredFields = getIgnoredFields(this._selectedSchema);
            var self = this;
            if (this._pauseChangePropagation != true) {
                self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
                self._updatePivot(function() {
                    self._updateCount(function() {
                        self._updateEnrich(function() {
                            self._updateOutput(function() {
                                self._updateQDC(function() {
                                    var schema = self._selectedSchema;
                                    if (self._hideIgnoredFields == true) {
                                        schema = schema.filter(function(field) {
                                            return field.ignore != true;
                                        });
                                    }
                                    if (self._schemaWidget == null) {
                                        createSchemaGrid("Schema", self._divSchemaGrid, null, lang.hitch(self, "_onSchemaChange"), schema, function(widget) {
                                            self._schemaWidget = widget;
                                        });
                                    }
                                    self._commonPlugin.pbHideProgressBar("updatingModel");
                                });
                            });
                        });
                    });
                });
            }
            else {
                var schema = self._selectedSchema;
                if (self._hideIgnoredFields == true) {
                    schema = schema.filter(function(field) {
                        return field.ignore != true;
                    });
                }
                if (self._schemaWidget == null) {
                    createSchemaGrid("Schema", self._divSchemaGrid, null, lang.hitch(self, "_onSchemaChange"), schema, function(widget) {
                        self._schemaWidget = widget;
                    });
                }
            }
        },

        _showResult : function() {
            if (this._resultWidget != null) {
                this._resultWidget.grid.destroy();
                delete this._resultWidget;
                AppUtil.removeAllChildrenOf(this._divResultGrid);
            }
            if (this._selectedSchema == null || this._selectedResult == null) return;

            var self = this;
            createResultGrid("Result", self._divResultGrid, null, self._selectedSchema, self._selectedResult, function(widget) {
                self._resultWidget = widget;
                self._resultIsDirty = false;
            });
        },

        _showPivot : function() {
            if (this._pivotWidget != null) {
                this._pivotWidget.grid.destroy();
                delete this._pivotWidget;
                AppUtil.removeAllChildrenOf(this._divPivotGrid);
            }
            var self = this;
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updatePivot(function() {
                self._updateEnrich(function() {
                    self._updateOutput(function() {
                        self._updateQDC(function() {
                            if(self._selectedPivot.measures && self._selectedPivot.measures.length > 0){
                                self._deleteMetricBtn.domNode.style.removeProperty('display');
                                self._addMetricBtn.domNode.style.removeProperty('display');
                            }else{
                                self._deleteMetricBtn.domNode.style.display = 'none';
                                self._addMetricBtn.domNode.style.display = 'none';
                            }
                            self._deleteMetricBtn && self._deleteMetricBtn.set("disabled", true);
                            createPivotGrid("Pivot", self._divPivotGrid, lang.hitch(self, "_onPivotSelect"), lang.hitch(self, "_onPivotChange"), self._selectedPivot, function(widget) {
                                self._pivotWidget = widget;
                            });
                            self._commonPlugin.pbHideProgressBar("updatingModel");
                        });
                    });
                });
            });
        },

        _showCount : function() {
            if (this._countWidget != null) {
                this._countWidget.grid.destroy();
                delete this._countWidget;
                AppUtil.removeAllChildrenOf(this._divCountGrid);
            }
            var self = this;
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updateCount(function() {
                self._updateEnrich(function() {
                    self._updateOutput(function() {
                        self._updateQDC(function() {
                            self._editCountBtn.set("disabled", self._countSelection == null || self._countSelection.length != 1);
                            self._deleteCountBtn.set("disabled", self._countSelection == null || self._countSelection.length == 0);
                            createCountGrid("Count", self._divCountGrid, lang.hitch(self, "_onCountSelect"), lang.hitch(self, "_onCountChange"), self._selectedCount, function(widget) {
                                self._countWidget = widget;
                            });
                            self._commonPlugin.pbHideProgressBar("updatingModel");
                        });
                    });
                });
            });
        },

        _showEnrich : function() {
            if (this._enrichWidget != null) {
                if (this._enrichAspectHandler) {
                    this._enrichAspectHandler.remove();
                    this._enrichAspectHandler = null;
                }
                this._enrichWidget.grid.destroy();
                delete this._enrichWidget;
                AppUtil.removeAllChildrenOf(this._divEnrichGrid);
            }
            var self = this;
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updateEnrich(function() {
                self._updateOutput(function() {
                    self._updateQDC(function() {
                        createEnrichGrid("Enrich", self._divEnrichGrid, lang.hitch(self, "_onEnrichSelect"), lang.hitch(self, "_onEnrichChange"), self._selectedEnrich, function(widget) {
                            self._enrichWidget = widget;
                            self._enrichAspectHandler = aspect.before(self._enrichWidget.grid, "_showEditor", lang.hitch(self, "_onShowEnrichEditor", self._selectedEnrich));
                            self._enrichWidget.grid.on("dgrid-editor-hide", lang.hitch(self, "_onHideEnrichEditor"));
                        });
                        self._commonPlugin.pbHideProgressBar("updatingModel");
                    });
                });
            });
        },

        _onHideEnrichEditor: function(event) {
            var cell = event.cell;
			var column = cell.column.field;
			var idx = cell.row.data.__index__;
			var editor = event.editor;

            if (column == "type") {
			    var type = editor.get("value");
			    var leftField = "";
			    var rightField = "";
                if (this._selectedEnrich.joinClause != null && this._selectedEnrich.joinClause.length > idx) {
                    leftField = this._selectedEnrich.joinClause[idx].leftField;
                    rightField = this._selectedEnrich.joinClause[idx].rightField;
                }
                    
                if (leftField != null && leftField != "") {
                    var match = false;
                    var leftType = "";
                    array.some(this._selectedEnrich.leftFields, function(item) {
                        if (item.name == leftField && item.type == type) {
                            match = true;
                            return true;
                        } else if (item.name == leftField ) {
                            leftType = item.type;
                        }
                    });
                    if (!match) {
                        var message = "There is type mismatch between left field: " + leftField + "(" + leftType + ") and right field: " + rightField + "(" + type + "). Please correct it";
                        this._plugin.createEnrichTypeMismatchDialog(message);
                    }
                }
            }
        },

		// reset different options base on data type
		// the control is ReloadOptionSelect. defined in createEnrichGrid method
		_onShowEnrichEditor: function(data, cmp, column, cellElement, value) {
		    var idx = 0;
		    if (this._enrichSelection != null && this._enrichSelection.length > 0) {
			    idx = this._enrichSelection[0].__index__;
			}
			
			if (idx >= 0) {
		        if (column.field == "leftField") {
		            cmp.options = this._generateLeftFieldOptions(data, idx);							
					return;
		        } else if (column.field == "type") {
		            cmp.options = this._generateRightFieldOptions(data, idx);
		        }
			}
		},

        _getMappingRule: function(type) {
            if (this.rule == null) {
                this.rule = {};
                this.rule.integer = [{value: "integer", label: "integer"},
                                {value: "long", label: "long"},
                                {value: "float", label: "float"},
                                {value: "double", label: "double"},
                                {value: "string", label: "string"}
                                ];
                this.rule.long = [
                                {value: "long", label: "long"},
                                {value: "float", label: "float"},
                                {value: "double", label: "double"},
                                {value: "string", label: "string"}
                                ];
                this.rule.float = [
                                {value: "float", label: "float"},
                                {value: "double", label: "double"},
                                {value: "string", label: "string"}
                                ];
                this.rule.double = [
                                {value: "double", label: "double"},
                                {value: "string", label: "string"}
                                ];
                this.rule.string = [{value: "integer", label: "integer"},
                                {value: "long", label: "long"},
                                {value: "float", label: "float"},
                                {value: "double", label: "double"},
                                {value: "string", label: "string"},
                                {value: "datetime", label: "datetime"},
                                {value: "date", label: "date"},
                                {value: "time", label: "time"},
                                {value: "boolean", label: "boolean"},
                                ];
                this.rule.datetime = [
                                {value: "string", label: "string"},
                                {value: "datetime", label: "datetime"},
                                ];
                this.rule.date = [
                                {value: "string", label: "string"},
                                {value: "date", label: "date"},
                                ];
                this.rule.time = [
                                {value: "string", label: "string"},
                                {value: "time", label: "time"},
                                ];
                this.rule.boolean = [
                                {value: "string", label: "string"},
                                {value: "boolean", label: "boolean"},
                                ];
            }

            var options = this.rule[type];
            if (options == null) {
                options = [{value: type, label: type}];
            }
            return options;             
        },

        _generateRightFieldOptions: function(data, idx) {
            var options = [];
            var dbtype = "";
            if (data.rightFields != null && data.rightFields.length > idx) {
                dbtype = data.rightFields[idx].type;
                options = this._getMappingRule(dbtype);
            }
            return options;
        },

        _generateLeftFieldOptions: function(data, idx) {
            var leftFieldOptions = [{
                value : "",
                label : "(none)",
            }];
            var type = "";
            if (data.joinClause != null && data.joinClause.length > idx) {
                type = data.joinClause[idx].type;
            }
            array.forEach(data.leftFields, function(item){
                if (type == "" || item.type == type) {
                    leftFieldOptions.push({
                        value : item.name,
                        label : item.label
                    });
                }
            });
            return leftFieldOptions;
        },

        _showOutput : function() {
            if (this._outputDeriveWidget != null) {
                this._outputDeriveWidget.destroy();
                delete this._outputDeriveWidget;
                AppUtil.removeAllChildrenOf(this._divOutputGrid);
            }
            var self = this;
            var columns = getOutputDeriveColumns();
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updateOutput(function() {
                self._deleteOutputBtn.set("disabled", true);
                addIndexAttribute(self._selectedOutput);
                self._plugin.getOutputSleSchema(self._selectedPivot, self._selectedEnrich, function (response) {
                    var schema = {
                        schema: [],
                        properties: []
                    };
                    if (response.status == "OK") {
                        schema = response.value;
                    }
                    Widget("DeriveWidget", function(DeriveWidget) {
                        var div = domConstruct.create("div");
                        self._divOutputGrid.appendChild(div);
                        self._outputDeriveWidget = new DeriveWidget({
                            columns: columns,
                            sleProperties: schema.properties,
                            sleSchema: schema.schema,
                            data: self._selectedOutput,
                            onSelectionChange: lang.hitch(self, "_onOutputSelect"),
                            onChange: lang.hitch(self, '_onOutputChange'),
                            sleTypeFieldMap: {
                                expr: 'type'
                            },
                            isRowSelectable: function (data) {
                                return data.__reserved__ != true;
                            },
                            isRowDisable: function (data) {
                                return data.__reserved__ == true;
                            }
                        }, div);
                        self._commonPlugin.pbHideProgressBar("updatingModel");
                    });
                });
            });
        },

        _showMetric : function() {
            if (this._metricWidget != null) {
                this._metricWidget.grid.destroy();
                delete this._metricWidget;
                AppUtil.removeAllChildrenOf(this._divMetricGrid);
            }
            domStyle.set(this._divQDCBottomRow, "display", "none");
            var self = this;
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updateMetric(function() {
                if (self._project.subservices.length > 0) {
                    domStyle.set(self._divQDCBottomRow, "display", "");
                    createMetricGrid("QDC", self._divMetricGrid, null, lang.hitch(self, "_onMetricChange"), self._project, self._selectedMetric, function(widget) {
                        self._metricWidget = widget;
                    });
                }
                else {
                    domStyle.set(self._divQDCBottomRow, "display", "none");
                }
                self._commonPlugin.pbHideProgressBar("updatingModel");
            });
        },
        
        _selectedScope: null,
        _initQDCComponent: function() {
            var scopeOptions = [];
            var scopeOptionsMap = {};

            function generateScope(svc, subSvc, comp, options, optionMap) {
                var item = {
                    value: "svc:" + svc,
                    label: svc,
                };
                if (!optionMap[item.value]) {
                    optionMap[item.value] = item;
                    options.push(item);
                }

                item = {
                    value: "subSvc:" + svc,
                    label: svc + "|*"
                }
                if (!optionMap[item.value]) {
                    optionMap[item.value] = item;
                    options.push(item);
                }

                item = {
                    value: "subSvc:" + svc + "|" + subSvc,
                    label: svc + "|" + subSvc
                }
                if (!optionMap[item.value]) {
                    optionMap[item.value] = item;
                    options.push(item);
                }
                
                item = {
                    value: "comp:" + svc + "|" + subSvc,
                    label: svc + "|" + subSvc + "|*"
                }
                if (!optionMap[item.value]) {
                    optionMap[item.value] = item;
                    options.push(item);
                }

                item = {
                    value: "comp:" + svc + "|" + subSvc + "|" + comp,
                    label: svc + "|" + subSvc + "|" + comp
                }
                if (!optionMap[item.value]) {
                    optionMap[item.value] = item;
                    options.push(item);
                }
            }

            generateScope(this._project.svc, this._project.comp, this._project.app, scopeOptions, scopeOptionsMap);
            var self = this;
            if (this._project && this._project.subservices) {
                this._project.subservices.forEach(function(item) {
                    generateScope(item.svc, item.subSvc, item.comp, scopeOptions, scopeOptionsMap);
                })
            }
            
            scopeOptions.forEach(function(scope) {
                scope.label = "<span style='font-family:monospace;font-size:12px;'>" + scope.label + "</span>";
            });
            scopeOptions.sort(function(a, b) {
                return a.label.localeCompare(b.label);
            });

            if (this._selectedScope == null) {
                this._selectedScope = "svc:" + this._project.svc;
            }

            if (!this._selectedQDC[this._selectedScope]) {
                this._selectedQDC[this._selectedScope] = {
                    operator: "and",
                    items: []
                }
            }
            this._selectedScopeQDC = this._selectedQDC[this._selectedScope];
            this._qdcOperator.set("value", this._selectedScopeQDC.operator);
            this._qdcScopeSelect.removeOption(this._qdcScopeSelect.getOptions());
            this._qdcScopeSelect.addOption(scopeOptions);
            this._qdcScopeSelect.set("value", this._selectedScope, false);
        },
        
        _buildQDCSleEditor: function (schema, sleText) {
            var self = this;
            require(["af/components/sle/SingleLineEditor", "spark/utils/FunctionUtil"], function(SingleLineEditor, FunctionUtil) {
                FunctionUtil.loadFunctionList(function(funcList){
                    self._qdcSleEditor = new SingleLineEditor({
            			schema: schema.schema,
            			properties: schema.properties,
            			functionList:funcList,
            			validateProperty:true,
            			text: sleText || "source1.metric_name = source2.parse_target_metric",
            			targetType: "boolean",
            			allowEmpty: false,
            			sourceSparkType: "DStream",
                        wordWarp : true,
            			onChange : function (text){
            			    self._project._systemModelJoinConditionsSle = text;
            			    self._projectIsDirty = true;
            			    self._updateSelection();
            			}
            		}, self.sleContainer);
                });
            });
        },

        _showQDC: function() {
            var self = this;
            this._commonPlugin.pbShowProgressBar("getSystemModelJoinConditionsSchema", "Loading system model join conditions schema...");
            this._plugin.getSystemModelJoinConditionsSchema(this._project, this._selectedPivot, function (response) {
                if (response.status == "OK") {
                    if (!self._qdcSleEditor) {
                        self._buildQDCSleEditor(response.value, self._project._systemModelJoinConditionsSle);
                    } else {
                        self._qdcSleEditor.setSchema(response.value.schema);
                    }
                }
                self._commonPlugin.pbHideProgressBar("getSystemModelJoinConditionsSchema");
            });
            
            if (this._qdcWidget != null) {
                this._qdcWidget.grid.destroy();
                delete this._qdcWidget;
                AppUtil.removeAllChildrenOf(this._divQDCGrid);
            }
            if (this._metricWidget != null) {
                this._metricWidget.grid.destroy();
                delete this._metricWidget;
                AppUtil.removeAllChildrenOf(this._divMetricGrid);
            }

            this._initQDCComponent();
            domStyle.set(this._divQDCBottomRow, "display", "none");
            var self = this;
            self._commonPlugin.pbShowProgressBar("updatingModel", "Updating model...");
            self._updateQDC(function() {
                self._deleteSubserviceBtn.set("disabled", true);
                if (self._subserviceWidget == null) {
                    createSubserviceGrid("Subservice", self._divSubserviceGrid, lang.hitch(self, "_onSubserviceSelect"), lang.hitch(self, "_onSubserviceChange"), self._project.subservices, function(widget) {
                        self._subserviceWidget = widget;
                    });
                }
                self._editQDCBtn.set("disabled", true);
                self._deleteQDCBtn.set("disabled", true);
                createQDCGrid("QDC", self._divQDCGrid, lang.hitch(self, "_onQDCSelect"), null, self._project, self._selectedScopeQDC.items, function(widget) {
                    self._qdcWidget = widget;
                });

                if (self._project.subservices.length > 0) {
                    domStyle.set(self._divQDCBottomRow, "display", "");
                    createMetricGrid("QDC", self._divMetricGrid, null, lang.hitch(self, "_onMetricChange"), self._project, self._selectedMetric, function(widget) {
                        self._metricWidget = widget;
                    });
                } else {
                    domStyle.set(self._divQDCBottomRow, "display", "none");
                }
                self._commonPlugin.pbHideProgressBar("updatingModel");
            });
        },

        _onSelectView : function(selected) {
            this._selectedView = selected.value;
            this._showViewDiv();
            switch (this._selectedView) {
                case "view/advanced":
                    this._resizeIncidentConfig();
                    this._initAggregateDisplay();
                    if (this._project != null && this._incidentConfigWidget == null) {
                        this._showIncidentConfig();
                    }
                    break;
                case "view/parse":
                    if (this._project != null && this._schemaWidget == null) {
                        this._showSchema(true, null);
                        this._showResult();
                    }
                    else {
                        if (this._schemaWidget != null) {
                            this._schemaWidget.grid.resize();
                        }
                        if (this._resultWidget != null) {
                            this._resultWidget.grid.resize();
                        }
                    }
                    break;
                case "view/map":
                    if (this._project != null && (this._pivotWidget == null || this._pivotNeedsUpdate == true) && (this._countWidget == null || this._countNeedsUpdate == true)) {
                        this._showPivot();
                        this._showCount();
                    }
                    else {
                        if (this._pivotWidget != null) {
                            this._pivotWidget.grid.resize();
                        }
                        if (this._countWidget != null) {
                            this._countWidget.grid.resize();
                        }
                    }
                    break;
                case "view/enrich":
                    if (this._project != null && (this._enrichWidget == null || this._enrichNeedsUpdate == true)) {
                        this._showEnrich();
                    }
                    else {
                        if (this._enrichWidget != null) {
                            this._enrichWidget.grid.resize();
                        }
                    }
                    break;
                case "view/output":
                    if (this._project != null && (this._outputDeriveWidget == null || this._outputNeedsUpdate == true)) {
                        this._showOutput();
                    }
                    else {
                        //TBD
                    }
                    break;
                case "view/qdc":
                    if (this._project != null && (this._qdcWidget == null || this._qdcNeedsUpdate == true)) {
                        this._showQDC();
                    }
                    else {
                        if (this._subserviceWidget != null) {
                            this._subserviceWidget.grid.resize();
                        }
                        if (this._qdcWidget != null) {
                            this._qdcWidget.grid.resize();
                        }
                    }
                    break;
                case "model/resource":
                    this._showResourceModel();
                    break;
                case "model/parser":
                    this._showParserModel();
                    break;
                case "model/anomaly":
                    this._showAnomalyModel();
                    break;
                case "model/system":
                    this._showSystemModel();
                    break;
            }
            this._updateSelection();
        },

        _onSchemaChange : function(event) {
            // some types of changes to schema has no immediate implications to downstream models
            // changes effect occur at code/model generation time
            // for these types of changes, we can avoid updating schema/models
            var self = this;
            if (event.type == "dgrid-datachange") {
                if (event.cell.column.field == "label") {
                    window.setTimeout(function() {
                        self._showResult();
                    }, 100);
                    return;
                }
                var FIELDS = ["optional", "format"];
                if (FIELDS.indexOf(event.cell.column.field) != -1) {
                    this._schemaIsDirty = true;
                    this._updateSelection();
                    return;
                }
            }
            window.setTimeout(function() {
                if (getIgnoredFields(self._selectedSchema) != self._ignoredFields && self._hideIgnoredFields) {
                    if (self._selectedSchema) {
                        var schema = self._selectedSchema.filter(function(field) {
                            return field.ignore != true;
                        });
                        if (self._schemaWidget != null) {
                            addIndexAttribute(schema);
                            var store = GridUtil.createGridStore("__index__", schema);
                            self._schemaWidget.grid.set("collection", store);
                        }
                    }
                }
                self._updateSchema(false, null);
            }, 100);
        },

        _onPivotChange : function(event) {
            var self = this;
            
            if(isLabelChange() && labelUsed()){
                self.controller._scriptManager._args.message("error", "Metric Label", event.value + ' is used.', null);
                event.preventDefault();
                return;
            }
                
            self._qdcNeedsUpdate = true;
            
            if (this._pivotWidget && this._pivotWidget.store && this._selectedPivot) {
                this._selectedPivot.pivot = this._pivotWidget.store.data;
            }
            
            window.setTimeout(function() {
                self._pivotIsDirty = true;
                self._enrichNeedsUpdate = true;
                self._outputNeedsUpdate = true;
                self._updateEnrich(function() {
                    self._updateOutput(function() {
                        self._updateQDC(function() {
                            self._updateSelection();
                        });
                    });
                });
            }, 100);
            
            function isLabelChange(){
                return event.cell.column.field === "__metric_label__";
            }
            
            function labelUsed(){
                return event.grid.collection.filter({"__metric_label__" : event.value}).fetchSync().length > 0;
            }
        },

        _onCountSelect : function(event) {
            this._countSelection = getSelectedItems(this._countWidget.grid, "__index__");
            this._editCountBtn.set("disabled", this._countSelection.length != 1);
            this._deleteCountBtn.set("disabled", this._countSelection.length == 0);
        },
        
        _onPivotSelect : function(event) {
            this._pivotSelection = getSelectedItems(this._pivotWidget.grid, "__index__");
            this._deleteMetricBtn.set("disabled", this._pivotSelection.length == 0);
        },

        _onCountChange : function(event) {
            var self = this;
            self._qdcNeedsUpdate    = true;
            
            if (this._countWidget && this._countWidget.store) {
                this._selectedCount = this._countWidget.store.data;
            }
            
            window.setTimeout(function() {
                self._countIsDirty = true;
                self._enrichNeedsUpdate = true;
                self._outputNeedsUpdate = true;
                self._updateEnrich(function() {
                    self._updateOutput(function() {
                        self._updateQDC(function() {
                            self._updateSelection();
                        });
                    });
                });
            }, 100);
        },

        _onEnrichSelect : function(event) {
            this._enrichWidget.grid = event.grid;
            this._enrichSelection = getSelectedItems(event.grid, "__index__");
        },

        _onEnrichChange : function(event) {
            if (event && this._enrichWidget && this._enrichWidget.store && this._selectedEnrich) {
                this._selectedEnrich.joinClause = this._enrichWidget.store.data;
            }
            this._project.__enrich_changed__ = true;
            var self = this;
            self._qdcNeedsUpdate = true;
            window.setTimeout(function() {
                /**
                if (self._selectedEnrich.joinClause != null) {
                    self._selectedEnrich.joinClause.forEach(function(field) {
                        if (field.include == "on") field.include = true;
                        if (field.leftField == "") field.leftField = null;
                    });
                }
                **/
                self._enrichIsDirty = true;
                self._outputNeedsUpdate = true;
                self._updateOutput(function() {
                    self._updateQDC(function() {
                        self._updateSelection();
                    });
                });
            }, 100);
        },

        _onOutputSelect : function(selection) {
            this._outputSelection = selection;
            if (this._outputSelection.length == 0) {
                this._deleteOutputBtn.set("disabled", true);
            }
            else {
                var disabled = false;
                for (var i=0; i<this._outputSelection.length; i++) {
                    if (this._outputSelection[i]["__user_defined__"] != true) {
                        disabled = true;
                        break;
                    }
                }
                this._deleteOutputBtn.set("disabled", disabled);
            }
        },

        _onOutputChange : function(event) {
            var self = this;
            window.setTimeout(function() {
                self._outputIsDirty = true;
                self._updateSelection();
            }, 100);
            
            if(this._referenceProjectsWarned) return;
            this._plugin.warnReferenceProjects(this._refPrjs());
            this._referenceProjectsWarned = true;
        },
        
        _refPrjs : function(){
            if(this._project.referenceProjects) return this._project.referenceProjects;
            else return [];
        },

        _onSubserviceSelect : function(event) {
            this._subserviceSelection = getSelectedItems(this._subserviceWidget.grid, "__index__");
            this._deleteSubserviceBtn.set("disabled", this._subserviceSelection.length == 0);
        },

        _onSubserviceChange: function(event) {
            var self = this;
            if (event) {
                if (event.cell.column.field.indexOf('Label') == -1 && nameUsed(this._subserviceWidget.store, targetRow())) {
                    self.controller._scriptManager._args.message("error", "Associated Subservices", targetName() + ' is used.', null);
                    event.preventDefault();
                    return;
                }
                if (event.cell.column.field.indexOf('Label') >=0  && labelUsed(this._subserviceWidget.store, targetRow())) {
                    self.controller._scriptManager._args.message("error", "Associated Subservices", targetLabel() + ' is used.', null);
                    event.preventDefault();
                    return;
                }
            }
            var subSvcFields = ["svc", "svcLabel", "subSvc", "subSvcLabel", "comp", "compLabel"];
            window.setTimeout(function() {
                self._initQDCComponent();
                self._projectIsDirty = true;
                self._updateSelection();
                if (event && event.type == "dgrid-datachange" && subSvcFields.indexOf(event.cell.column.field) >= 0) {
                    // if subservice name change, we need to update metric table
                    self._showMetric();
                }
            }, 100);

            function sameName(target, row) {
                return target.svc === row.svc && target.subSvc === row.subSvc && target.comp === row.comp;
            }

            function sameLabel(target, row) {
                return target.svcLabel === row.svcLabel && target.subSvcLabel === row.subSvcLabel && target.compLabel === row.compLabel;
            }

            function nameUsed(store, target) {
                return store.data.filter(sameName.bind(null, target)).length > 0;
            }

            function labelUsed(store, target) {
                return store.data.filter(sameLabel.bind(null, target)).length > 0;
            }
            
            function targetRow(){
                var ret = Object.assign({}, event.cell.row.data);
                ret[event.cell.column.field] = event.value;
                return ret;
            }
            
            function targetName(){
                return targetRow().svc + '|' + targetRow().subSvc + '|' + targetRow().comp;
            }
            
            function targetLabel(){
                return targetRow().svcLabel + '|' + targetRow().subSvcLabel + '|' + targetRow().compLabel;
            }
        },

        _onQDCSelect : function(event) {
            this._qdcSelection = getSelectedItems(this._qdcWidget.grid, "__index__");
            this._editQDCBtn.set("disabled", this._qdcSelection.length != 1);
            this._deleteQDCBtn.set("disabled", this._qdcSelection.length == 0);
        },

        _onQDCChange: function(event) {
            var self = this;
            if (this._qdcWidget) {
                this._selectedScopeQDC.items = this._qdcWidget.store.data;
                this._selectedQDC[this._selectedScope] = this._selectedScopeQDC;
            }
            window.setTimeout(function() {
                self._qdcIsDirty = true;
                self._updateSelection();
            }, 100);
        },

        _onMetricChange : function(event) {
            var self = this;
            window.setTimeout(function() {
                self._metricIsDirty = true;
                self._updateSelection();
            }, 100);
        },

        _getPivot : function(callback) {
            var project = lang.clone(this._project);
            var schema  = this._selectedSchema != null ? lang.clone(this._selectedSchema) : null;
            var pivot   = this._selectedPivot != null ? lang.clone(this._selectedPivot) : null;
            this._plugin.getPivotModel(project, schema, pivot, callback);
        },

        _comparePivot : function(oldModel, newModel) {
            if (oldModel == null) oldModel = {};
            oldModel = lang.clone(oldModel);
            removeIndexAttribute(oldModel.pivot);
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _updateSchema : function(rebuild, callback) {
            var oldIgnoredFields = this._ignoredFields;
            this._ignoredFields = getIgnoredFields(this._selectedSchema);
            this._schemaIsDirty = true;
            this._pivotNeedsUpdate = true;
            this._countNeedsUpdate = true;
            this._enrichNeedsUpdate = true;
            this._outputNeedsUpdate = true;
            this._qdcNeedsUpdate = true;
            if (this._resultIsDirty == true || this._ignoredFields != oldIgnoredFields) {
                // ignored fields changed, rebuild result grid
                this._showResult();
            }
            var self = this;
            this._showSchema(rebuild, function() {
                self._updateSelection();
                if (callback) callback();
            });
        },

        _updatePivot : function(callback) {
            if (this._pivotWidget != null && this._pivotNeedsUpdate == true) {
                this._pivotWidget.grid.destroy();
                delete this._pivotWidget;
                AppUtil.removeAllChildrenOf(this._divPivotGrid);
            }
            var self = this;
            this._getPivot(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._pivotIsDirty = !self._comparePivot(self._selectedPivot, response.value);
                    if (self._pivotIsDirty) {
                        console.debug("PIVOT BEFORE");
                        console.debug(self._selectedPivot);
                        console.debug("PIVOT AFTER");
                        console.debug(response.value);
                    }
                    self._selectedPivot = response.value;
                    self._pivotNeedsUpdate = false;
                    self._updateSelection();
                    callback();
                }
            });
        },

        _getCount : function(callback) {
            var project = lang.clone(this._project);
            var schema  = this._selectedSchema != null ? lang.clone(this._selectedSchema) : null;
            var count   = this._selectedCount != null ? lang.clone(this._selectedCount) : null;
            this._plugin.getCountModel(project, schema, count, callback);
        },

        _compareCount : function(oldModel, newModel) {
            oldModel = lang.clone(oldModel);
            removeIndexAttribute(oldModel);
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _updateCount : function(callback) {
            if (this._countWidget != null && this._countNeedsUpdate == true) {
                this._countWidget.grid.destroy();
                delete this._countWidget;
                AppUtil.removeAllChildrenOf(this._divCountGrid);
            }
            var self = this;
            this._getCount(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._countIsDirty = !self._compareCount(self._selectedCount, response.value);
                    if (self._countIsDirty) {
                        console.debug("COUNT BEFORE");
                        console.debug(self._selectedCount);
                        console.debug("COUNT AFTER");
                        console.debug(response.value);
                    }
                    self._selectedCount = response.value;
                    self._countNeedsUpdate = false;
                    self._updateSelection();
                    callback();
                }
            });
        },

        _getEnrich : function(callback) {
            var project = lang.clone(this._project);
            var pivot   = this._selectedPivot != null ? lang.clone(this._selectedPivot) : null;
            var enrich  = this._selectedEnrich != null ? lang.clone(this._selectedEnrich) : null;
            this._plugin.getEnrichModel(project, pivot, enrich, callback);
        },

        _compareEnrich : function(oldModel, newModel) {
            oldModel = lang.clone(oldModel);
            if (oldModel) {
                removeIndexAttribute(oldModel.leftFields);
                removeIndexAttribute(oldModel.rightFields);
                removeIndexAttribute(oldModel.joinClause);
            }
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _updateEnrich : function(callback) {
            if (this._enrichWidget != null && this._enrichNeedsUpdate == true) {
                this._enrichWidget.grid.destroy();
                delete this._enrichWidget;
                AppUtil.removeAllChildrenOf(this._divEnrichGrid);
            }
            var self = this;
            this._getEnrich(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._enrichIsDirty = !self._compareEnrich(self._selectedEnrich, response.value);
                    if (self._enrichIsDirty) {
                        console.debug("ENRICH BEFORE");
                        console.debug(self._selectedEnrich);
                        console.debug("ENRICH AFTER");
                        console.debug(response.value);
                    }
                    self._selectedEnrich = response.value;
                    self._enrichNeedsUpdate = false;
                    self._updateSelection();
                    callback();
                }
            });
        },

        _getOutput : function(callback) {
            var project = lang.clone(this._project);
            var pivot   = this._selectedPivot != null ? lang.clone(this._selectedPivot) : null;
            var enrich  = this._selectedEnrich != null ? lang.clone(this._selectedEnrich) : null;
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            this._plugin.getOutputModel(project, pivot, enrich, output, callback);
        },

        _compareOutput : function(oldModel, newModel) {
            oldModel = lang.clone(oldModel);
            removeIndexAttribute(oldModel);
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _updateOutput : function(callback) {
            if (this._outputDeriveWidget != null && this._outputNeedsUpdate == true) {
                this._outputDeriveWidget.destroy();
                delete this._outputDeriveWidget;
                AppUtil.removeAllChildrenOf(this._divOutputGrid);
            }
            var self = this;
            this._getOutput(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._outputIsDirty = !self._compareOutput(self._selectedOutput, response.value);
                    if (self._outputIsDirty) {
                        console.debug("OUTPUT BEFORE");
                        console.debug(self._selectedOutput);
                        console.debug("OUTPUT AFTER");
                        console.debug(response.value);
                    }
                    self._selectedOutput = response.value;
                    self._outputNeedsUpdate = false;
                    self._updateSelection();
                    callback();
                }
            });
        },

        _getQDC : function(callback) {
            var project = lang.clone(this._project);
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            var qdc     = this._selectedQDC != null ? lang.clone(this._selectedQDC) : null;
            this._plugin.getQDCModel(project, output, qdc, callback);
        },

        _compareQDC: function(oldModel, newModel) {
            oldModel = lang.clone(oldModel);
            for (var pro in oldModel) {
                var scopeQDC = oldModel[pro];
                if (scopeQDC.items) {
                    removeIndexAttribute(scopeQDC.items);
                    removeQDCDisplayAttributes(scopeQDC.items);
                }
            }
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _getMetrics : function(callback) {
            var project = lang.clone(this._project);
            var pivot  = this._selectedPivot != null ? lang.clone(this._selectedPivot) : [];
            var count  = this._selectedCount != null ? lang.clone(this._selectedCount) : [];
            var metric = this._selectedMetric != null ? lang.clone(this._selectedMetric) : null;
            this._plugin.getMetricModel(project, pivot, count, metric, callback);
        },

        _compareMetrics : function(oldModel, newModel) {
            oldModel = lang.clone(oldModel);
            removeIndexAttribute(oldModel);
            return JSON.stringify(oldModel) == JSON.stringify(newModel);
        },

        _updateMetric : function(callback) {
            if (this._metricWidget != null && this._metricNeedsUpdate == true) {
                this._metricWidget.grid.destroy();
                delete this._metricWidget;
                AppUtil.removeAllChildrenOf(this._divMetricGrid);
            }
            var self = this;
            self._getMetrics(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._metricIsDirty = !self._compareMetrics(self._selectedMetric, response.value);
                    if (self._qdcIsDirty) {
                        console.debug("METRIC BEFORE");
                        console.debug(self._selectedMetric);
                        console.debug("METRIC AFTER");
                        console.debug(response.value);
                    }
                    self._selectedMetric = response.value;
                    self._metricNeedsUpdate = false;
                    callback();
                }
            });
        },

        _updateQDC : function(callback) {
            if (this._qdcWidget != null && this._qdcNeedsUpdate == true) {
                this._qdcWidget.grid.destroy();
                delete this._qdcWidget;
                AppUtil.removeAllChildrenOf(this._divQDCGrid);
            }
            var self = this;
            self._getQDC(function(response) {
                if (response.status == "OK" && response.value != null) {
                    self._qdcIsDirty = !self._compareQDC(self._selectedQDC, response.value);
                    if (self._qdcIsDirty) {
                        console.debug("QDC BEFORE");
                        console.debug(self._selectedQDC);
                        console.debug("QDC AFTER");
                        console.debug(response.value);
                    }
                    self._selectedQDC = response.value;
                    self._qdcNeedsUpdate = false;
                    self._syncQDCGrid();
                    self._updateMetric(function() {
                        self._updateSelection();
                        callback();
                    });
                }
            });
        },

        _updateSelection : function() {
            if (this._pivotWidget && this._pivotWidget.store && this._selectedPivot) {
                this._selectedPivot.pivot = this._pivotWidget.store.data;
            }

            if (this._countWidget && this._countWidget.store) {
                this._selectedCount = this._countWidget.store.data;
            }

            if (this._subserviceWidget && this._subserviceWidget.store) {
                this._project.subservices = this._subserviceWidget.store.data;
            }

            if (this._metricWidget && this._metricWidget.store) {
                this._selectedMetric = this._metricWidget.store.data;
            }

            if (this._enrichWidget && this._enrichWidget.store && this._selectedEnrich) {
                this._selectedEnrich.joinClause = this._enrichWidget.store.data;
            }

            if (this._outputDeriveWidget) {
                this._selectedOutput = this._outputDeriveWidget.data;
            }
            
            if (this.renderer.tile != null) {
                var content = {
                    "view"            : this._selectedView,
                    "schema"          : this._selectedSchema,
                    "result"          : this._selectedResult,
                    "pivot"           : this._selectedPivot,
                    "count"           : this._selectedCount,
                    "enrich"          : this._selectedEnrich,
                    "output"          : this._selectedOutput,
                    "qdc"             : this._selectedQDC,
                    "projectChanged"  : this._projectIsDirty == true,
                    "schemaChanged"   : this._schemaIsDirty == true,
                    "pivotChanged"    : this._pivotIsDirty == true  || this._pivotNeedsUpdate == true,
                    "countChanged"    : this._countIsDirty == true  || this._countNeedsUpdate == true,
                    "enrichChanged"   : this._enrichIsDirty == true || this._enrichNeedsUpdate == true,
                    "outputChanged"   : this._outputIsDirty == true || this._outputNeedsUpdate == true,
                    "qdcChanged"      : this._qdcIsDirty == true    || this._qdcNeedsUpdate == true,
                    "metricChanged"   : this._metricIsDirty == true || this._metricNeedsUpdate == true,
                    "delimiterType"   : this._project != null ? this._project.delimiterType : "csv",
                    "delimiter"       : this._project != null ? this._project.delimiter : "",
                };
                content.changed = content.projectChanged == true
                               || content.schemaChanged == true
                               || content.pivotChanged == true
                               || content.countChanged == true
                               || content.enrichChanged == true
                               || content.outputChanged == true
                               || content.qdcChanged == true
                               || content.metricChanged == true;
                var dirtyKey = "NuovaStellaProject";
                if (content.changed) {
                    this.controller.appController.markDirty(dirtyKey);
                } else {
                    this.controller.appController.clearDirty(dirtyKey);
                }
                
                var selection = [content];

                // use this.renderer.tile._onSelectionChange() to direct selection via Selection port
                this.renderer.tile._onSelectionChange(selection);
                
                // use this.renderer.tile._doubleClickOnSelection() to direct selection via Drilldown port
                this.renderer.tile._doubleClickOnSelection(selection);
            }
        },

        _updateUIEvent : function(type, event)
        {
            if (this.tile != null) {
                this.tile.updateUIEvent([{
                    "__TYPE__" : type,
                    "__EVENT__" : event
                }]);
            }
        },

        _generateResourceModel : function(callback) {
            var project = lang.clone(this._project);
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            this._plugin.generateResourceModel(project, "Default", output, callback);
        },

        _showResourceModel : function() {
            var self = this;
            this._generateResourceModel(function(response) {
                if (response.status == "OK" && response.value != null) {
                    //if (self._dataResourceWidget != null) {
                    //    self._dataResourceWidget.destroy();
                    //    delete self._dataResourceWidget;
                    //}
                    //AppUtil.removeAllChildrenOf(self._divResourceModel);
                    var edits = response.value.edits;
                    var model = response.value.model;
                    if (self._dataResourceWidget != null) {
                        self._dataResourceWidget.setSelected(model, false);
                        self._dataResourceWidget._showDef();
                    }
                    else {
                        require(["drd/widgets/DataResourceDetailWidget", ], function(DataResourceDetailWidget) {
                            var div = domConstruct.create("div", {});
                            self._divResourceModel.appendChild(div);
    
                            self._dataResourceWidget = new DataResourceDetailWidget({
                                controller : {
                                    appController : {
                                        hasEditRole : function(item) {
                                            return true;
                                        },
                                        isRunnable : function(item, callback) {
                                            callback(false);
                                        },
                                    }
                                }
                            }, div);
                            self._dataResourceWidget.startup();
                            domStyle.set(self._dataResourceWidget.domNode, "height", "100%");
                            domStyle.set(self._dataResourceWidget.bottomBarDiv, "display", "none");
                            
                            self._dataResourceWidget.setSelected(model, false);
                        });
                    }
                }
                else {
                    if (self._dataResourceWidget != null) {
                        self._dataResourceWidget.destroy();
                        delete self._dataResourceWidget;
                    }
                    AppUtil.removeAllChildrenOf(self._divResourceModel);
                }
            });
        },

        _generateParserModel : function(callback) {
            var project = lang.clone(this._project);
            var schema  = this._selectedSchema != null ? lang.clone(this._selectedSchema) : null;
            var pivot   = this._selectedPivot != null ? lang.clone(this._selectedPivot) : null;
            var count   = this._selectedCount != null ? lang.clone(this._selectedCount) : null;
            var enrich  = this._selectedEnrich != null ? lang.clone(this._selectedEnrich) : null;
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            this._plugin.generateParserModel(project, "Default", schema, pivot, count, enrich, output, callback);
        },

        _showParserModel : function() {
            var self = this;
            this._commonPlugin.pbShowProgressBar("generateParserModel", "Generating parser model xml...");
            this._generateParserModel(function(response) {
                if (response.status == "OK" && response.value != null) {
                    var edits = response.value.edits;
                    var model = response.value.model;
                    var SHOW_FLOW_MODEL = false;
                    if (SHOW_FLOW_MODEL) {
                        if (self._flowModelWidget != null) {
                            delete self._flowModelWidget;
                            self._flowModelWidget = null;
                            AppUtil.removeAllChildrenOf(self._divParserModel);
                        }
                        createDataFlowController(model, function(controller) {
                            initPipeFunctions(controller, function() {
                                createFlowModelWidget(controller, self._divParserModel, function(widget) {
                                    self._flowModelWidget = widget;
                                });
                            });
                        });
                    }
                    else {
                        AppUtil.removeAllChildrenOf(self._divParserModel);
                        var modelText = formatXML(model, {
                            INDENT : "    "
                        });
                        createAceEditor(self._divParserModel, "ace/mode/xml", modelText, true, function(editor) {
                        });
                    }
                }
                else {
                    AppUtil.removeAllChildrenOf(self._divParserModel);
                }
                self._commonPlugin.pbHideProgressBar("generateParserModel");
            });
        },

        _generateAnomalyModel : function(callback) {
            var project = lang.clone(this._project);
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            this._plugin.generateAnomalyModel(project, "Default", output, callback);
        },

        _showAnomalyModel : function() {
            var self = this;
            this._commonPlugin.pbShowProgressBar("generateAnomalyModel", "Generating anomaly model xml...");
            this._generateAnomalyModel(function(response) {
                if (response.status == "OK" && response.value != null) {
                    var edits = response.value.edits;
                    var model = response.value.model;
                    var SHOW_FLOW_MODEL = false;
                    if (SHOW_FLOW_MODEL) {
                        if (self._flowModelWidget != null) {
                            delete self._flowModelWidget;
                            self._flowModelWidget = null;
                            AppUtil.removeAllChildrenOf(self._divAnomalyModel);
                        }
                        createDataFlowController(model, function(controller) {
                            initPipeFunctions(controller, function() {
                                createFlowModelWidget(controller, self._divAnomalyModel, function(widget) {
                                    self._flowModelWidget = widget;
                                });
                            });
                        });
                    }
                    else {
                        AppUtil.removeAllChildrenOf(self._divAnomalyModel);
                        var modelText = formatXML(model, {
                            INDENT : "    "
                        });
                        createAceEditor(self._divAnomalyModel, "ace/mode/xml", modelText, true, function(editor) {
                        });
                    }
                }
                else {
                    AppUtil.removeAllChildrenOf(self._divAnomalyModel);
                }
                self._commonPlugin.pbHideProgressBar("generateAnomalyModel");
            });
        },

        _generateSystemModel : function(callback) {
            var project = lang.clone(this._project);
            var schema  = this._selectedSchema != null ? lang.clone(this._selectedSchema) : null;
            var pivot   = this._selectedPivot != null ? lang.clone(this._selectedPivot) : null;
            var count   = this._selectedCount != null ? lang.clone(this._selectedCount) : null;
            var enrich  = this._selectedEnrich != null ? lang.clone(this._selectedEnrich) : null;
            var output  = this._selectedOutput != null ? lang.clone(this._selectedOutput) : null;
            var qdc     = this._selectedQDC != null ? lang.clone(this._selectedQDC) : null;
            var metric  = this._selectedMetric != null ? lang.clone(this._selectedMetric) : null;
            this._plugin.generateSystemModel(project, "Default", "demo", schema, pivot, count, enrich, output, qdc, metric, callback);
        },

        _showSystemModel : function() {
            var self = this;
            this._commonPlugin.pbShowProgressBar("generateSystemModel", "Generating system model...");
            this._generateSystemModel(function(response) {
                if (response.status == "OK" && response.value != null) {
                    AppUtil.removeAllChildrenOf(self._divSystemModel);
                    var modelText = JSON.stringify(response.value, null, "    ");
                    createAceEditor(self._divSystemModel, "ace/mode/json", modelText, true, function(editor) {
                    });
                }
                else {
                    AppUtil.removeAllChildrenOf(self._divSystemModel);
                }
                self._commonPlugin.pbHideProgressBar("generateSystemModel");
            });
        },

        _onClickIgnoreAll : function(evt) {
            for (var i=0, n=this._selectedSchema.length; i<n; i++) {
                this._selectedSchema[i]["ignore"] = true;
            }
            this._updateSchema(true, null);
        },

        _onClickIgnoreSelected : function(evt) {
            var selectedFields = getSelectedItems(this._schemaWidget.grid, "__index__");
            if (selectedFields != null && selectedFields.length > 0) {
                for (var i=0, n=selectedFields.length; i<n; i++) {
                    selectedFields[i]["ignore"] = true;
                }
                this._updateSchema(true, null);
            }
        },

        _onChangeHideIgnored : function(value) {
            this._hideIgnoredFields = value;
            if (this._selectedSchema == null) return;
            
            var schema = this._selectedSchema;
            if (this._hideIgnoredFields == true) {
                schema = schema.filter(function(field) {
                    return field.ignore != true;
                });
            }
            
            if (this._schemaWidget != null) {
                addIndexAttribute(schema);
                var store = GridUtil.createGridStore("__index__", schema);
                this._schemaWidget.grid.set("collection", store);
            }
        },

        _onChangePauseChangePropagation : function(value) {
            this._pauseChangePropagation = value;
            if (this._pauseChangePropagation == false) {
                this._updateSchema(true, null);
            }
        },

        _onClickSetAttributeTypeDefaults : function(evt) {
            var self = this;
            if (self._selectedSchema != null) {
                self._selectedSchema.forEach(function(field) {
                    if (field.ignore != true) {
                        switch (field.data_type) {
                            case "string":
                            case "boolean":
                                field.attr_type = "dimension";
                                break;
                            case "datetime":
                            case "date":
                                field.attr_type = "timestamp";
                                break;
                            default:
                                field.attr_type = "measure";
                                break;
                        }
                    }
                    else {
                        field.attr_type = "N/A";
                    }
                });
                self._pivotNeedsUpdate  = true;
                self._qdcNeedsUpdate    = true;
                window.setTimeout(function() {
                    self._showSchema(true, null);
                    self._schemaIsDirty = true;
                    self._countNeedsUpdate  = true;
                    self._enrichNeedsUpdate = true;
                    self._outputNeedsUpdate = true;
                }, 100);
            }
        },

        _onClickClearAttributeTypes : function(evt) {
            var self = this;
            if (self._selectedSchema != null) {
                self._selectedSchema.forEach(function(field) {
                    field.attr_type = "N/A";
                });
                self._pivotNeedsUpdate  = true;
                self._qdcNeedsUpdate    = true;
                window.setTimeout(function() {
                    self._showSchema(true, null);
                    self._schemaIsDirty = true;
                    self._countNeedsUpdate  = true;
                    self._enrichNeedsUpdate = true;
                    self._outputNeedsUpdate = true;
                }, 100);
            }
        },

        _onChangeDetectionAlgorithm : function(value) {
            this._project.detectionAlgorithm = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeThresholdPolicy : function(value) {
            this._project.thresholdPolicy = value;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _getAnalysisTimeRange : function() {
            return this._incidentTimeRange || "";
        },

        _getDefaultIncidentConfig : function(fromUnixTime, toUnixTime, swagOnly) {
            var self = this;
            self._commonPlugin.pbShowProgressBar("getDefaultIncidentConfig", "Computing default configuration for incident detection...");
            self._project.configs = [];
            self._plugin.getDefaultIncidentConfig(self._project, fromUnixTime, toUnixTime, swagOnly, function(response) {
                if (response.status == "OK") {
                    self._project.configs = response.value;
                    self._showIncidentConfig();
                    if (!self._projectIsDirty) {
                        self._projectIsDirty = true;
                        self._updateSelection();
                    }
                }
                self._commonPlugin.pbHideProgressBar("getDefaultIncidentConfig");
            });
        },

        _onSetAnalysisTimeRange : function(value) {
            this._incidentTimeRange = value;
            var toks = value.split(":");
            if (toks.length == 2) {
                toks = (toks[1]).split("/");
                if (toks.length == 2) {
                    var swagOnly = this._cbSwagOnly.get("checked") == true;
                    var fromUnixTime = Number(toks[0]);
                    var toUnixTime = Number(toks[1]);
                    if (swagOnly) {
                        this._getDefaultIncidentConfig(fromUnixTime, toUnixTime, swagOnly);
                    }
                    else {
                        var self = this;
                        var msg = "Performing a comprehensive analysis of the data to determine default settings can take significant amount of time. Continue? ";
                        self._commonPlugin.showMessage(self.controller, "confirm", "Compute Defaults", msg, function(ok) {
                            if (ok) {
                                self._getDefaultIncidentConfig(fromUnixTime, toUnixTime, swagOnly);
                            }
                        });
                    }
                }
            }
        },

        _showIncidentConfig : function() {
            if (this._incidentConfigWidget != null) {
                this._incidentConfigWidget.grid.destroy();
                delete this._incidentConfigWidget;
            }
            AppUtil.removeAllChildrenOf(this._divIncidentConfig);
            var self = this;
            createIncidentConfigGrid("Incident", self._divIncidentConfig, lang.hitch(self, "_onIncidentConfigSelect"), lang.hitch(self, "_onIncidentConfigChange"), self._project.configs || [], function(widget) {
                self._incidentConfigWidget = widget;
            });
            delete this._incidentConfigSelection;
            this._changeSettingBtn.set("disabled", this._incidentConfigSelection == null || this._incidentConfigSelection.length != 1);
        },

        _resizeIncidentConfig : function() {
            var box1 = domGeom.getContentBox(this._divAdvanced);
            var box2 = domGeom.getMarginBox(this._tableAdvancedInfo);
            var configWidth = box1.w - 4;
            var configHeight = box1.h - box2.h;
            domStyle.set(this._divIncidentConfig, {
                width  : configWidth + "px",
                height : configHeight + "px",
            });
            if (this._incidentConfigWidget != null) {
                this._incidentConfigWidget.grid.resize();
            }
        },

        _onClickChangeSetting : function(evt) {
            if (this._incidentConfigSelection != null && this._incidentConfigSelection.length == 1) {
                var self = this;
                var config = this._incidentConfigSelection[0];
            	var widgetPath = "/app/dbp/user/viaops_admin/dbpm/VIAOps - Signal Onboarding Service/ConfigSettingsWidget";
            	var widgetConfig = {
            	    settings : config.settings,
            	};
            	this._commonPlugin.popupWidget(this.controller, "Config Settings", 700, 400, true, null, widgetPath, widgetConfig, function(uuid) {
                    if (uuid != null) {
                        var setting = config.settings[uuid];
                        config.settingDescription      = setting.description;
                        config.incidentAlgorithm       = setting.algorithm;
                        config.incidentThresholdPolicy = setting.thresholdPolicy;
                        config.incidentHighThreshold   = setting.highThreshold;
                        config.incidentMediumThreshold = setting.mediumThreshold;
                        config.incidentLowThreshold    = setting.lowThreshold;
                        config.incidentWarmupThreshold = setting.warmupThreshold;
                        config.incidentWarmupPeriod    = setting.warmupPeriod;
                        config.incidentCooldownPeriod  = setting.cooldownPeriod;
                        self._incidentConfigWidget.store.put(config);
                        self._onIncidentConfigChange(null);
                    }
            	});
            }
        },

        _onIncidentConfigSelect : function(event) {
            this._incidentConfigSelection = getSelectedItems(this._incidentConfigWidget.grid, "__index__");
            this._changeSettingBtn.set("disabled", this._incidentConfigSelection == null || this._incidentConfigSelection.length != 1);
        },

        _onIncidentConfigChange : function(evt) {
            if (this._incidentConfigWidget && this._incidentConfigWidget.store) {
                this._project.configs = this._incidentConfigWidget.store.data;
            }
            
            var self = this;
            window.setTimeout(function() {
                self._projectIsDirty = true;
                self._updateSelection();
            }, 100);
        },
        
        _onClickAddMetric : function(evt) {
            if(this._pivotWidget && this._pivotWidget.store == null) return;
            this._pivotWidget.store.put(newValue(this._pivotWidget));
            this._onPivotChange();
            
            function newValue(widget){
                return Object.assign({}, widget.newRow, { '__index__' : String(Date.now()) });
            }
        },
        
        _onClickDeleteMetric : function(evt) {
            var self = this;
            if(this._pivotWidget && this._pivotWidget.store == null) return;
            getSelectedItems(this._pivotWidget.grid, "__index__")
                .forEach(item => this._pivotWidget.store.remove(item["__index__"]), this);
            this._onPivotChange();
        },

        _onClickAddCount : function(evt) {
            var self = this;
            this._plugin.openCountMetricDialog(null, this._selectedSchema, function(values) {
                if (self._countWidget.store != null) {
                    values.__index__ = String(Date.now());
                    values.encodeMetricName = values.metricName.replace(/[^a-z0-9+]+/gi, '_');
                    self._countWidget.store.put(values);
                    self._onCountChange(null);
                }
            });
        },

        _onClickEditCount : function(evt) {
            var self = this;
            if (this._countWidget.store != null && this._countSelection != null && this._countSelection.length == 1) {
                var item = this._countSelection[0];
                this._plugin.openCountMetricDialog(item, this._selectedSchema, function(values) {
                    if (self._countWidget.store != null) {
                        item.metricName  = values.metricName;
                        item.metricLabel = values.metricLabel;
                        item.fieldName   = values.fieldName;
                        item.matchValues = values.matchValues;
                        self._countWidget.store.put(item);
                        self._onCountChange(null);
                    }
                });
            }
        },

        _onClickDeleteCount : function(evt) {
            var self = this;
            if (this._countWidget.store != null && this._countSelection != null && this._countSelection.length > 0) {
                this._countSelection.forEach(function(item) {
                    self._countWidget.store.remove(item["__index__"]);
                });
                this._onCountChange(null);
            }
        },

        _onClickAddOutput : function(evt) {
            if (this._outputDeriveWidget != null) {
                this._outputDeriveWidget.addItem({
                    "__index__"        : String(Date.now()),
                    "__user_defined__" : true,
                    "name"             : "new_output",
                    "label"            : "New Output",
                    "type"             : "string",
                    "expr"             : '""',
                });
                this._onOutputChange(null);
            }
        },

        _onClickDeleteOutput : function(evt) {
            var self = this;
            if (this._outputDeriveWidget != null && this._outputSelection != null && this._outputSelection.length > 0) {
                this._outputSelection.forEach(function(item) {
                    self._outputDeriveWidget.deleteItem(item);
                });
                this._onOutputChange(null);
            }
        },
        
        _onClickAddSubservice: function(evt) {
            var self = this;
            if (this._subserviceWidget.store != null) {
                this._subserviceWidget.store.put({
                    "__index__": String(Date.now()),
                    "svc": this._project.svc,
                    "svcLabel": this._project.svcLabel || this._project.svc,
                    "subSvc": this._project.comp + (this._project.subservices.length + 1),
                    "subSvcLabel": (this._project.compLabel || this._project.comp) + " " + (this._project.subservices.length + 1),
                    "comp": this._project.app,
                    "compLabel": this._project.appLabel || this._project.app
                });
                this._onSubserviceChange(null);

                window.setTimeout(function() {
                    self._showMetric();
                }, 100);
            }
        },
        
        _onClickDeleteSubservice : function(evt) {
            var self = this;
            var qdcChange = false;
            if (this._subserviceWidget.store != null && this._subserviceSelection != null && this._subserviceSelection.length > 0) {
                this._subserviceSelection.forEach(function(item) {
                    var candiates = [];
                    if (self._qdcWidget.store != null && self._qdcWidget.store.data != null) {
                        self._qdcWidget.store.data.forEach(function(qdcItem) {
                            var scope = qdcItem._scope_;
                            if (scope != null && scope.indexOf("|" + item.name) != -1) {
                                candiates.push(qdcItem);
                            }
                        });
                        if (candiates.length > 0) {
                            qdcChange = true;
                            candiates.forEach(function(qdcItem) {
                                self._qdcWidget.store.remove(qdcItem["__index__"]);
                            });
                        }
                    }                
                    self._subserviceWidget.store.remove(item["__index__"]);
                });
                this._onSubserviceChange(null);
                if (qdcChange) {
                    this._onQDCChange(null);
                }

                window.setTimeout(function() {
                    self._showMetric();
                }, 100);
            }
        },

        _syncQDCGrid: function() {
            if (this._qdcWidget) {
                if (!this._selectedQDC[this._selectedScope]) {
                    this._selectedQDC[this._selectedScope] = {
                        operator: "and",
                        items: []
                    }
                }
                
                this._selectedScopeQDC = this._selectedQDC[this._selectedScope];
                addIndexAttribute(this._selectedScopeQDC.items);
                addQDCDisplayAttributes(this._project, this._selectedScopeQDC.items);
                
                this._qdcWidget.store.setData(this._selectedScopeQDC.items);
                this._qdcWidget.grid.refresh();
                this._qdcOperator.set("value", this._selectedScopeQDC.operator, false);
            }
        },

        _onChangeQdcScope: function() {
            this._selectedScope = this._qdcScopeSelect.value;
            if (!this._selectedQDC[this._selectedScope]) {
                this._selectedQDC[this._selectedScope] = {
                    operator: "and",
                    items: []
                }
            }
            this._selectedScopeQDC = this._selectedQDC[this._selectedScope];
            addIndexAttribute(this._selectedScopeQDC.items);
            addQDCDisplayAttributes(this._project, this._selectedScopeQDC.items);
            this._qdcWidget.store.setData(this._selectedScopeQDC.items);
            this._qdcWidget.grid.refresh();
            this._qdcOperator.set("value", this._selectedScopeQDC.operator, false);
        },

        _onChangeQdcOperator: function() {
            this._qdcIsDirty = true;
            var operator = this._qdcOperator.value;
            this._selectedScopeQDC.operator = operator;
            this._updateSelection();
        },
        
        _qdcWidgetShowing: false,
        _onClickAddQDC : function(evt) {
            if (this._qdcWidgetShowing == true) return;
            
            this._qdcWidgetShowing = true;
            var self = this;
        	var widgetPath = "/app/dbp/user/viaops_admin/dbpm/VIAOps - Signal Onboarding Service/QDCEditorWidget";
        	var widgetConfig = {
        	    schema : this._selectedOutput
        	};
        	this._commonPlugin.popupWidget(this.controller, "Qualifying Dimension Constraints", 600, 550, true, null, widgetPath, widgetConfig, function(qdc) {
                addQDCDisplayAttributes(self._project, [qdc]);
        	    self._qdcWidget.store.put(qdc);
                self._onQDCChange(null);
                self._qdcWidgetShowing = false;
        	}, function () {
        	    self._qdcWidgetShowing = false;
        	});
        },
        
        _onClickEditQDC : function(evt) {
            var self = this;
            if (this._qdcSelection != null && this._qdcSelection.length == 1 && this._qdcWidgetShowing != true) {
            	var widgetPath = "/app/dbp/user/viaops_admin/dbpm/VIAOps - Signal Onboarding Service/QDCEditorWidget";
            	var widgetConfig = {
            	    schema : this._selectedOutput
            	};
            	
            	this._qdcWidgetShowing = true;
            	this._commonPlugin.popupWidget(this.controller, "Qualifying Dimension Constraints", 600, 550, true, this._qdcSelection[0], widgetPath, widgetConfig, function(qdc) {
                    addQDCDisplayAttributes(self._project, [qdc]);
            	    self._qdcWidget.store.put(qdc);
            	    self._onQDCSelect();
                    self._onQDCChange(null);
                    self._qdcWidgetShowing = false;
            	}, function () {
            	    self._qdcWidgetShowing = false;
            	});
            }
        },

        _onClickDeleteQDC : function(evt) {
            var self = this;
            if (this._qdcWidget.store != null && this._qdcSelection != null && this._qdcSelection.length > 0) {
                this._qdcSelection.forEach(function(item) {
                    self._qdcWidget.store.remove(item["__index__"]);
                });
                this._onQDCChange(null);
            }
        },

        _onChangeEnrichSource : function(value) {
            if (this._project == null) return;

            this._project.__enrich_changed__ = true;
            this._selectedEnrich = {};
            this._project.enrichSource = value;
            this._projectIsDirty = true;
            this._onEnrichChange(null);
            this._showEnrich();

            this._project.enrichDatabase = "";
            this._enrichDatabase.removeOption(this._enrichDatabase.getOptions());
            this._enrichDatabase.addOption([this.OPTION_NONE]);
            this._enrichDatabase.set("value", this._project.enrichDatabase, false);

            this._project.enrichTable = "";
            this._enrichTable.removeOption(this._enrichTable.getOptions());
            this._enrichTable.addOption([this.OPTION_NONE]);
            this._enrichTable.set("value", this._project.enrichTable, false);

            this._populateEnrichDatabaseSelect(null);
        },

        _onChangeEnrichDatabase : function(value) {
            if (this._project == null) return;

            this._project.__enrich_changed__ = true;
            this._selectedEnrich = {};
            this._project.enrichDatabase = value;
            this._projectIsDirty = true;
            this._onEnrichChange(null);
            this._showEnrich();

            this._project.enrichTable = "";
            this._enrichTable.removeOption(this._enrichTable.getOptions());
            this._enrichTable.addOption([this.OPTION_NONE]);
            this._enrichTable.set("value", this._project.enrichTable, false);

            this._populateEnrichTableSelect(null);
        },

        _onChangeEnrichTable : function(value) {
            if (this._project == null) return;

            this._project.__enrich_changed__ = true;
            this._selectedEnrich = {};
            this._project.enrichTable = value;
            this._projectIsDirty = true;
            this._onEnrichChange(null);
            this._showEnrich();
            
            var self = this;
            this._datasourcePlugin.dbListColumns(this._project.enrichSource, this._project.enrichTable, function(response) {
                if (response.status == "OK") {
                    var rightFields = response.value;
                    rightFields.forEach(function (field) {
                        if (field.type == "int") {
                            field.type = "integer";
                        }
                    });
                    self._selectedEnrich = {
                        leftFields  : [],
                        rightFields : rightFields,
                        joinClause  : [],
                    };
                    self._showEnrich();
                }
            });
        },
        
        _onChangeEnrichJoinType : function(value) {
            if (this._project == null) return;
            
            this._project.enrichJoinType = value;
            this._project.__enrich_changed__ = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _populateEnrichSourceSelect : function(callback) {
            if (this._project == null) return;
            var self = this;
            var value = this._project.enrichSource;
            if (value == null) value = "";
            this._datasourcePlugin.dsListDataSources(function(response) {
                if (response.status == "OK") {
                    var options = [self.OPTION_NONE];
                    response.value.forEach(function(item) {
                        options.push({
                            value : JSON.stringify(item),
                            label : item.name,
                        });
                    });
                    self._enrichSource.removeOption(self._enrichSource.getOptions());
                    self._enrichSource.addOption(options);
                    self._enrichSource.set("value", value, false);
                    if (callback) callback();
                }
            });
        },

        _populateEnrichDatabaseSelect : function(callback) {
            if (this._project == null || this._project.enrichSource == null) return;
            var self = this;
            var value = this._project.enrichDatabase;
            if (value == null) value = "";
            this._datasourcePlugin.dbListDatabase(this._project.enrichSource, function(response) {
                if (response.status == "OK") {
                    var options = [self.OPTION_NONE];
                    options.push({
                        value : response.value,
                        label : response.value,
                    });
                    self._enrichDatabase.removeOption(self._enrichDatabase.getOptions());
                    self._enrichDatabase.addOption(options);
                    if (value == response.value) {
                        self._enrichDatabase.set("value", value, false);
                    } else {
                        self._project.enrichDatabase = response.value;
                        self._enrichDatabase.set("value", response.value, true);
                    }
                    if (callback) callback();
                }
            });
        },

        _populateEnrichTableSelect : function(callback) {
            if (this._project == null || this._project.enrichSource == null || this._project.enrichDatabase == null) return;
            var self = this;
            var value = this._project.enrichTable;
            if (value == null) value = "";
            this._datasourcePlugin.dbListTables(this._project.enrichSource, this._project.enrichDatabase, function(response) {
                if (response.status == "OK") {
                    var options = [self.OPTION_NONE];
                    response.value.forEach(function(item) {
                        options.push({
                            value : JSON.stringify(item),
                            label : item.name,
                        });
                    });
                    self._enrichTable.removeOption(self._enrichTable.getOptions());
                    self._enrichTable.addOption(options);
                    self._enrichTable.set("value", value, false);
                    if (callback) callback();
                }
            });
        },

        _onClickFetchTable: function () {
            this._populateEnrichTableSelect();
        },
        
         _initAggregateDisplay: function() {
            this._updateAggregateDisplay();

            if (this._project.aggregateWindow) {
                var aggregate = this._project.aggregateWindow;
                this._isMetricAggr.set("value", aggregate.aggregate, false);
                this._windowSize.set("value", aggregate.windowSize, false);
                this._windowSizeUnit.set("value", aggregate.windowUnit, false);
                this._OOOSize.set("value", aggregate.OOOSize, false);
                this._OOOUnit.set("value", aggregate.OOOUnit, false);
                this._heartbeatDelaySize.set("value", aggregate.hbDelaySize, false);
                this._heartbeatDelayUnit.set("value", aggregate.hbDelayUnit, false);
                this._stopEmptyWindow.set("value", aggregate.stopEmptyWindow, false);
            }
        },

        _updateAggregateDisplay: function() {
            var aggregate = this._project.aggregateWindow;
            if (aggregate.aggregate) {
                for (var i = 1; i < 7; i++) {
                    domStyle.set(this["_aggrHide" + i], "display", "none");
                }

                for (var i = 1; i < 8; i++) {
                    domStyle.set(this["_aggrShow" + i], "display", "");
                }
            } else {
                for (var i = 1; i < 8; i++) {
                    domStyle.set(this["_aggrShow" + i], "display", "none");
                }
                
                for (var i = 1; i < 7; i++) {
                    domStyle.set(this["_aggrHide" + i], "display", "");
                }
            }
        },

        _onChangeMetricAggr: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.aggregate = value;
            this._updateAggregateDisplay();

            this._outputNeedsUpdate = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeWindowSize: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.windowSize = value;

            this._outputNeedsUpdate = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeWindowSizeUnit: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.windowUnit = value;

            this._outputNeedsUpdate = true;
            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeOOOSize: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.OOOSize = value;

            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeOOOUnit: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.OOOUnit = value;

            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeHeartbeatDelaySize: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.hbDelaySize = value;

            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeHeartbeatDelayUnit: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.hbDelayUnit = value;

            this._projectIsDirty = true;
            this._updateSelection();
        },

        _onChangeStopEmpryWindow: function(value) {
            var aggregate = this._project.aggregateWindow;
            aggregate.stopEmptyWindow = value;

            this._projectIsDirty = true;
            this._updateSelection();
        }]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[            this.updateWidthAndHeight(this.vtWidth, this.vtHeight);
            
            if (evt.NuovaStella != null) {
                this._plugin = evt.NuovaStella;
                console.debug("##### Nuova Stella plugin: " + this._plugin["$uri"]);
            }

            var self = this;
            switch (evt.action) {
                case "load":
                    domStyle.set(this.domNode, {
                        "pointer-events" : "inherit",
                        "opacity"        : "inherit",
                    });
                    this._project = evt.project;
                    this._projectIsDirty = false;
                    this._schemaIsDirty  = false;
                    this._resultIsDirty  = false;
                    this._pivotIsDirty   = false;
                    this._countIsDirty   = false;
                    this._enrichIsDirty  = false;
                    this._outputIsDirty  = false;
                    this._qdcIsDirty     = false;
                    this._metricIsDirty  = false;
                    this._pivotNeedsUpdate  = false;
                    this._countNeedsUpdate  = false;
                    this._enrichNeedsUpdate = false;
                    this._outputNeedsUpdate = false;
                    this._qdcNeedsUpdate    = false;
                    this._metricNeedsUpdate = false;
                    this._svcName.set("value", this._project.svc, false);
                    this._svcLabel.set("value", this._project.svcLabel || "", false);
                    this._compName.set("value", this._project.comp, false);
                    this._compLabel.set("value", this._project.compLabel || "", false);
                    this._appName.set("value", this._project.app, false);
                    this._appLabel.set("value", this._project.appLabel || "", false);
                    this._filenameFilter.set("value", this._project.filenameFilter, false);
                    this._filenameExtension.set("value", this._project.filenameExtension, false);
                    this._sourceGroup.set("value", this._project.sourceGroup, false);
                    this._targetGroup.set("value", this._project.targetGroup, false);
                    this._namePrefix.set("value", this._project.prefix, false);
                    this._spaceName.set("value", this._project.space, false);
                    this._hdfsServerURL.set("value", this._project.hdfsServerURL, false);
                    this._timezone.set("value", this._project.timezone, false);
                    this._dst.set("value", this._project.dst, false);
                    this._delimiterType.set("value", this._project.delimiterType, false);
                    if (this._project.delimiterType == "userDef") {
                        this._delimiter.set("value", this._project.delimiter, false);
                        this._delimiter.set("disabled", false);
                    }
                    else {
                        this._delimiter.set("value", "");
                        this._delimiter.set("disabled", true);
                    }
                    this._selectedSchema = null;
                    this._resetDetail();
                    this._initViewTabs();
                    this._updateNameDefaults();
                    this._updateSelection();
                    break;
                case "save":
                    self._commonPlugin.pbShowProgressBar("saveProject", "Saving project...");
                    self._updatePivot(function() {
                        self._updateCount(function() {
                            self._updateEnrich(function() {
                                self._updateOutput(function() {
                                    self._updateQDC(function() {
                                        self._plugin.saveProject(self._project, self._selectedSchema, self._selectedPivot, self._selectedCount, self._selectedEnrich, self._selectedOutput, self._selectedQDC, self._selectedMetric, function(response) {
                                            if (response.status == "OK") {
                                                self._project.__hdfs_changed__ = false;
                                                self._project.__space_changed__ = false;
                                                self._project.__prjname_changed__ = false;
                                                self._project.__filter_changed__ = false;
                                                self._project.__enrich_changed__ = false;
                                                self._projectIsDirty = false;
                                                self._schemaIsDirty  = false;
                                                self._resultIsDirty  = false;
                                                self._pivotIsDirty   = false;
                                                self._countIsDirty   = false;
                                                self._enrichIsDirty  = false;
                                                self._outputIsDirty  = false;
                                                self._qdcIsDirty     = false;
                                                self._metricIsDirty  = false;
                                                self._pivotNeedsUpdate  = false;
                                                self._countNeedsUpdate  = false;
                                                self._enrichNeedsUpdate = false;
                                                self._outputNeedsUpdate = false;
                                                self._qdcNeedsUpdate    = false;
                                                self._metricNeedsUpdate = false;
                                                self._updateUIEvent("save-complete", null);
                                                self._updateSelection();
                                                self._commonPlugin.pbHideProgressBar("saveProject");
                                            } else {
                                                self._commonPlugin.pbHideProgressBar("saveProject");
                                                self.controller._scriptManager._args.message("error", "Project", self._commonPlugin.getErrorFromThrownException(response.error), null);
                                            }
                                        });
                                    });
                                });
                            });
                        });
                    });
                    break;
                case "close":
                    domStyle.set(this.domNode, {
                        "pointer-events" : "none",
                        "opacity"        : 0.5
                    });
                    this._project = null;
                    this._projectIsDirty = false;
                    this._schemaIsDirty  = false;
                    this._resultIsDirty  = false;
                    this._pivotIsDirty   = false;
                    this._countIsDirty   = false;
                    this._enrichIsDirty  = false;
                    this._outputIsDirty  = false;
                    this._qdcIsDirty     = false;
                    this._metricIsDirty  = false;
                    this._pivotNeedsUpdate  = false;
                    this._countNeedsUpdate  = false;
                    this._enrichNeedsUpdate = false;
                    this._outputNeedsUpdate = false;
                    this._qdcNeedsUpdate    = false;
                    this._metricNeedsUpdate = false;
                    this._svcName.set("value", "", false);
                    this._svcLabel.set("value", "", false);
                    this._compName.set("value", "", false);
                    this._compLabel.set("value", "", false);
                    this._appName.set("value", "", false);
                    this._appLabel.set("value", "", false);
                    this._filenameFilter.set("value", "", false);
                    this._filenameExtension.set("value", "", false);
                    this._sourceGroup.set("value", "", false);
                    this._targetGroup.set("value", "", false);
                    this._namePrefix.set("value", "", false);
                    this._spaceName.set("value", "", false);
                    this._hdfsServerURL.set("value", "", false);
                    this._timezone.set("value", "", false);
                    this._dst.set("value", "", false);
                    this._delimiterType.set("value", "csv", false);
                    this._delimiter.set("value", "");
                    this._delimiter.set("disabled", true);
                    this._resetDetail();
                    this._sampleName.set("value", "", false);
                    this._sampleType.set("value", "", false);
                    this._sampleSize.set("value", "", false);
                    this._updateNameDefaults();
                    this._updateSelection();
                    this._createViewTabs(false, function() {
                        self._setSelectedView("view/parse");
                    });
                    break;
                case "refresh":
                    domStyle.set(this.domNode, {
                        "pointer-events" : "inherit",
                        "opacity"        : "inherit",
                    });
                    this._project = evt.project;
                    this._projectIsDirty = false;
                    this._schemaIsDirty  = false;
                    this._resultIsDirty  = false;
                    this._pivotIsDirty   = false;
                    this._countIsDirty   = false;
                    this._enrichIsDirty  = false;
                    this._outputIsDirty  = false;
                    this._qdcIsDirty     = false;
                    this._metricIsDirty  = false;
                    this._pivotNeedsUpdate  = false;
                    this._countNeedsUpdate  = false;
                    this._enrichNeedsUpdate = false;
                    this._outputNeedsUpdate = false;
                    this._qdcNeedsUpdate    = false;
                    this._metricNeedsUpdate = false;
                    
                    this._svcName.set("value", this._project.svc, false);
                    this._svcLabel.set("value", this._project.svcLabel || "", false);
                    this._compName.set("value", this._project.comp, false);
                    this._compLabel.set("value", this._project.compLabel || "", false);
                    this._appName.set("value", this._project.app, false);
                    this._appLabel.set("value", this._project.appLabel || "", false);
                    this._filenameFilter.set("value", this._project.filenameFilter, false);
                    this._filenameExtension.set("value", this._project.filenameExtension, false);
                    this._sourceGroup.set("value", this._project.sourceGroup, false);
                    this._targetGroup.set("value", this._project.targetGroup, false);
                    this._namePrefix.set("value", this._project.prefix, false);
                    this._spaceName.set("value", this._project.space, false);
                    this._hdfsServerURL.set("value", this._project.hdfsServerURL, false);
                    this._timezone.set("value", this._project.timezone, false);
                    this._dst.set("value", this._project.dst, false);
                    this._delimiterType.set("value", this._project.delimiterType, false);
                    if (this._project.delimiterType == "userDef") {
                        this._delimiter.set("value", this._project.delimiter, false);
                        this._delimiter.set("disabled", false);
                    }
                    else {
                        this._delimiter.set("value", "");
                        this._delimiter.set("disabled", true);
                    }
                    
                    this._resetDetail();
                    this._initViewTabs();
                    this._filenameFilter.set("value", this._project.filenameFilter, false);
                    this._filenameExtension.set("value", this._project.filenameExtension, false);
                    this._updateSelection();
                    break;
                case "update":
                    this._commonPlugin.pbShowProgressBar("updateProject", "Create/Update models and artifacts...");
                    this._plugin.updateProject(this._project, 'Default', evt.options, function(response) {
                        if (response.status == "OK") {
                            self.controller._scriptManager._args.message("growl", "Project", "Project models and artifacts created/updated.", null);
                        }
                        else {
                            self.controller._scriptManager._args.message("error", "Project", self._commonPlugin.getErrorFromThrownException(response.error), null);
                        }
                        self._commonPlugin.pbHideProgressBar("updateProject");
                        self._updateSelection();
                    });
                    break;
                case "reset":
                    this._commonPlugin.pbShowProgressBar("resetProject", "Reset models and artifacts...");
                    this._plugin.resetProject(this._project, "Default", evt.options, function(response) {
                        if (response.status == "OK") {
                        }
                        else {
                        }
                        self._commonPlugin.pbHideProgressBar("resetProject");
                        self._updateSelection();
                    });
                    break;
            }]]>
        </CodeText>
        <CodeText segment="#updateWidthAndHeight">
          <![CDATA[            var mainBox = domGeom.getMarginBox(this._mainDiv);
            
            w = mainBox.w;
            h = mainBox.h;
            
            var box = domGeom.getMarginBox(this._tableProjectInfo);
            var availableWidth = w - 2;
            var availableHeight = h - 25 - box.h - 8;

            domStyle.set(this._divSchema, {
                width  : availableWidth + "px",
                height : Math.floor(availableHeight/2) + "px",
            });

            domStyle.set(this._divResult, {
                width  : availableWidth + "px",
                height : Math.floor(availableHeight/2) + "px",
            });

            domStyle.set(this._divPivot, {
                width  : availableWidth + "px",
                height : Math.floor(availableHeight/2) + "px",
            });

            domStyle.set(this._divCount, {
                width  : availableWidth + "px",
                height : Math.floor(availableHeight/2) + "px",
            });

            domStyle.set(this._divAdvanced, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divPreProcess, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divParse, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divMap, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divEnrich, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divQDC, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divOutput, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });
            
            domStyle.set(this._divResource, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divParser, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divAnomaly, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });

            domStyle.set(this._divSystem, {
                width  : availableWidth + "px",
                height : availableHeight + "px",
            });
            
            if (this._viewTabBar != null) {
                domStyle.set(this._viewTabBar.leftDiv, {
                    width : "100%",
                });
                this._adjustViewTabSpacing();
            }

            this._resizeIncidentConfig();
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[
            var buttonLabel  = "Compute Defaults";
            var dialogTitle  = "Set analysis time range";
            var widgetPath   = "/app/dbp/user/via_common/dbpm/VIA - Time Range Picker/TimeRangePicker";
            var widgetConfig = {
                "predefined" : []
            };
            var btn = createPopupDialogButton(this._computeSettingsSpan, buttonLabel, null, dialogTitle, 495, 350, widgetPath, widgetConfig,
                                              lang.hitch(this, "_getAnalysisTimeRange"), lang.hitch(this, "_onSetAnalysisTimeRange"));
            domStyle.set(btn.domNode.firstChild, {
                "border-radius" : "",
                "font-size" : "10px",
            });

            this._cbSwagOnly.set("checked", true);
            
            this._svcName.pattern = this._plugin.nameConstraints().svc.patternContent;
            this._svcName.invalidMessage = this._plugin.nameConstraints().svc.patternMismatch;
            this._compName.pattern = this._plugin.nameConstraints().comp.patternContent;
            this._compName.invalidMessage = this._plugin.nameConstraints().comp.patternMismatch;            
            this._appName.pattern = this._plugin.nameConstraints().app.patternContent;
            this._appName.invalidMessage = this._plugin.nameConstraints().app.patternMismatch;]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            this._plugin = Plugin();
            this._commonPlugin = Plugin("VIA - Common");
            this._datasourcePlugin = Plugin("VIA - Data Source Plugin");
            this._hideIgnoredFields = false;
            this._pauseChangePropagation = false;
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="nuova-stella" style="width:100%;height:100%;border:none;background-color:white;" data-dojo-attach-point="_mainDiv">
    <style>
    .horizontal-flex {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        box-sizing: border-box;
    }
    
    .vertical-flex {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-content: center;
        box-sizing: border-box;
    }
    .DRConnectButton {
        float: right;
        padding-left: 2px;
        width: 88px;
        height: 24px;
        border-bottom: solid 1px lightgray;
        border-radius: 0px;
        cursor: pointer;
        background: white;
    }
    .DRControl .dijitTextBox {
        cursor: auto;
        -webkit-appearance: none;
        -moz-appearance: none;
        border-bottom: 1px solid #148ac4;
        background-color: transparent;
        border: none;
        box-sizing: border-box;
        color: currentColor;
        padding-left: 5px;
        padding-top: 0px;
        position: relative;
        width: 100%;
        height: 25px;
    }
    .DRControl .dijitTextBox .dijitInputField .dijitInputInner {
        line-height: 12px;
        color: #148ac4;
        font-family: Arial;
        font-size: 14px;
        width: 100%;
        height: 18px;
    }
    .DRControl .selectMXStyle:hover {
        background-image: none;
    }
    .DRControl .selectMXStyle {
        border: none;
        border-radius: 0px;
        border-bottom: 1px solid #148ac4;
        background-image: none;
    }
    .DRControl .selectMXStyle .dijitButtonContents {
        border: none;
    }
    .DRControl .selectMXStyle .dijitArrowButton {
        background: transparent;
        border: none;
    }
    .DRTabbar .tabBarItem {
        background: transparent;
        border: none;
        border-right: none;
        margin: 0;
    }
    .DRTabbar .dojoDndItemSelected {
        background-color: rgba(245, 245, 245, 1) !important;
        border-top: 1px solid rgb(20, 138, 196) !important;
        border-left: 1px solid rgb(20, 138, 196) !important;
        border-right: 1px solid rgb(20, 138, 196) !important;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
        margin: 0px;
        padding: 0px;
        color: rgb(20, 138, 196);
    }
    .DRTabbar .showMaskSpan {
        width: 100%;
        height: calc(1% - -6px);
        margin-bottom: -10px;
        background-color: #FFF;
    }
    .DRTabbar .hideMaskSpan {
        width: 0;
        height: 0;
    }
    .DRTabbar .nameDiv {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
        width: 100% !important;
        line-height: 24px;
        font-size: 13px;
    }
    .DRTabbar .leftDiv {
        background-color: white !important;
        padding-left: 20px;
    }
    .nuova-stella .dgrid .dgrid-selected .dgrid-cell {
        color: black !important;
    }
    .nuova-stella .dgrid .reserved-row {
        background-color: rgba(0,0,0,.1);
        font-style : italic;
    }
    .nuova-stella .dgrid .dgrid-selected.reserved-row {
        background-color: rgba(20, 138, 196, 0.6);
        font-style : italic;
    }
    .nuova-stella .dgrid .protected-cell {
        background-color: rgba(0,0,0,.1);
        font-style : italic;
    }
    .nuova-stella .dgrid .dgrid-selected .protected-cell {
        background-color: rgba(20, 138, 196, 0.6);
        font-style : italic;
    }
    </style>
    <table cellspacing="5" data-dojo-attach-point="_tableProjectInfo" style="width:100%;border:none;background-color:white;padding:0px 0px 10px 0px;">
        <tr style="width:100%;">
            <td style="width:200px;padding-right:5px;text-align:right;">Service Name:</td>
            <td style="width:25%;">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       title="Models and other service artifacts are created using the service name. Highly recommended that you reset the project to remove generated models and artifacts before changing service name to avoid orphan-ing those generated models and artifacts."
                       data-dojo-type="dijit/form/ValidationTextBox"  data-dojo-props="regExp:'[_a-zA-Z0-9 ]+', invalidMessage:'Service can only contain a-z A-Z  _  and space.'"  data-dojo-attach-point="_svcName" data-dojo-attach-event="change:_onChangeSvcName"/>
            </td>
            <td style="width:200px;padding-right:5px;text-align:right;">Subservice Name:</td>
            <td style="width:25%;">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       title="Models and other service artifacts are created using the subservice name. Highly recommended that you reset the project to remove generated models and artifacts before changing subservice name to avoid orphan-ing those generated models and artifacts."
                       data-dojo-type="dijit/form/ValidationTextBox"  data-dojo-props="regExp:'[_a-zA-Z0-9 ]+', invalidMessage:'Sub Service can only contain a-z A-Z  _  and space.'"  data-dojo-attach-point="_compName" data-dojo-attach-event="change:_onChangeCompName"/>
            </td>
            <td style="width:200px;padding-right:5px;text-align:right;">Component Name:</td>
            <td style="width:25%;">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       title="Models and other service artifacts are created using the component name. Highly recommended that you reset the project to remove generated models and artifacts before changing component name to avoid orphan-ing those generated models and artifacts."
                       data-dojo-type="dijit/form/ValidationTextBox"  data-dojo-props="regExp:'[_a-zA-Z0-9 ]+', invalidMessage:'Component can only contain a-z A-Z  _  and space.'"  data-dojo-attach-point="_appName" data-dojo-attach-event="change:_onChangeAppName"/>
            </td>
            <td style="width:200px;padding-right:5px;text-align:right;"></td>
            <td style="width:25%;">
            </td>
        </tr>
        <tr style="width:100%;">
            <td style="padding-right:5px;text-align:right;">Label:</td>
            <td style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_svcLabel" data-dojo-attach-event="change:_onChangeSvcLabel"/>
            </td>
            <td style="padding-right:5px;text-align:right;">Label:</td>
            <td style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_compLabel" data-dojo-attach-event="change:_onChangeCompLabel"/>
            </td>
            <td style="padding-right:5px;text-align:right;">Label:</td>
            <td style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_appLabel" data-dojo-attach-event="change:_onChangeAppLabel"/>
            </td>
            <td style="padding-right:5px;text-align:right;"></td>
            <td style="">
            </td>
        </tr>
        <tr style="width:100%;">
            <td style="padding-right:5px;text-align:right;">Sample Name:</td>
            <td colspan="3" style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;background-color:rgba(0,0,0,.1);pointer-events:none;" readonly="readonly"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_sampleName"/>
            </td>
            <td style="padding-right:5px;text-align:right;">Type/Size:</td>
            <td style="">
                <input type="text" style="width:calc(50% - 25px);font-family:monospace;background-color:rgba(0,0,0,.1);pointer-events:none;" readonly="readonly"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_sampleType"/>
                <div style="display:inline-block;width:11px;text-align:center;">/</div>
                <input type="text" style="width:calc(50% - 25px);font-family:monospace;background-color:rgba(0,0,0,.1);pointer-events:none;" readonly="readonly"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_sampleSize"/>
            </td>
            <td style="padding-right:5px;text-align:right;">Delimiter:</td>
            <td style="">
                <select style="width:200px;font-family:monospace;"
                        data-dojo-type="dijit/form/Select" data-dojo-attach-point="_delimiterType" data-dojo-attach-event="change:_onChangeDelimiterType">
                    <option value="csv">Comma Separated Values</option>
                    <option value="tsv">Tab Separated Values</option>
                    <option value="userDef">User Defined</option>
                </select>
                <input type="text" style="width:80px;font-family:monospace;"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_delimiter" data-dojo-attach-event="change:_onChangeDelimiter"/>
            </td>
        </tr>
        <tr style="width:100%;">
            <td style="padding-right:5px;text-align:right;">Space:</td>
            <td style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       data-dojo-type="dijit/form/ValidationTextBox"  data-dojo-props="regExp:'[a-zA-Z\u0080-\u024f\u0800-\u1fff\u2070-\u9fff\ ][\\w\u0080-\u024f\u0800-\u1fff\u2070-\u9fff\\- ]{0,79}', invalidMessage:'Invalid space name'" data-dojo-attach-point="_spaceName" data-dojo-attach-event="change:_onChangeSpaceName"/>
            </td>
            <td style="padding-right:5px;text-align:right;">HDFS Server URL:</td>
            <td colspan="3" style="">
                <input type="text" style="width:calc(100% - 30px);font-family:monospace;"
                       data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_hdfsServerURL" data-dojo-attach-event="change:_onChangeHdfsServerURL"/>
            </td>
            <td style="padding-right:5px;text-align:right;"></td>
            <td style="">
            </td>
        </tr>
    </table>
    <div data-dojo-attach-point='_viewTabDiv' style="width:100%;height:28px;"></div>
    <div data-dojo-attach-point="_divPreProcess" style="display:none;">
        <table style="width:calc(100% - 10px);height:calc(100% + 10px);" border="0" cellspacing="0" cellpadding="0">
            <tr>
                <td style="width:40%;height:100%;padding-right:5px;">
                    <div style="width:100%;height:30px;font-weight:bold;font-size:18px;">
                        <span style="font-weight:bold;font-size:18px;">Source Text:</span>
                        <span data-dojo-attach-point="_divPreMimeType" style="font-family:Courier New;font-size:18px;padding-left:5px;"></span>
                        <span data-dojo-attach-point="_divPreJsonEncoding" style="font-family:Courier New;font-size:18px;padding-left:5px;"></span>
                    </div>
                    <div data-dojo-attach-point="_divPreContent" style="width:100%;height:calc(100% - 40px);border:thin solid lightgray;" class=""></div>
                </td>
                <td style="width:60%;height:100%;">
                    <div style="width:100%;height:30px;">
                        <span style="font-weight:bold;font-size:18px;">Javascript Script:</span>
                        <span style="font-family:Courier New;font-size:18px;padding-left:5px;">mapJSONtoCSV(jsonText, isRuntime)</span>
                        <button type="button" style="float:right;font-size:10px;"
                                data-dojo-type="dijit/form/Button" data-dojo-attach-point="_evalPreScriptBtn"
                                data-dojo-attach-event="click:_onClickEvalPreScript">Evaluate</button>
                    </div>
                    <div data-dojo-attach-point="_divPreScript" style="width:100%;height:60%;border:thin solid lightgray;" class=""></div>
                    <div data-dojo-attach-point="_divPreResult" style="width:100%;height:calc(40% - 40px);border:thin solid lightgray;">
                        <textarea data-dojo-attach-point="_divPreTextArea" style="width:calc(100% - 10px);height:calc(100% - 10px);font-family:Courier New;white-space:pre;" class="" readonly="true"></textarea>
                    </div>
                </td>
            </tr>
        </table>
    </div>
    <div data-dojo-attach-point="_divParse" style="display:none;">
        <div data-dojo-attach-point="_divSchema" style="padding:5px;" class="">
            <div style="width:calc(100% - 10px);height:30px;">
                <span style="font-weight:bold;font-size:18px;">
                    Schema <span style="font-weight:normal;font-style:italic;">(* double-click to edit)</span>
                </span>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_clearAttributeTypesBtn"
                        data-dojo-attach-event="click:_onClickClearAttributeTypes">Clear All</button>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_setAttributeTypeDefaultsBtn"
                        data-dojo-attach-event="click:_onClickSetAttributeTypeDefaults">Set Defaults</button>
                <span style="float:right;margin-top:3px;padding-left:20px;padding-right:3px;">Attribute Type:</span>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_ignoreAllBtn"
                        data-dojo-attach-event="click:_onClickIgnoreAll">Ignore All</button>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_ignoreSelectedBtn"
                        data-dojo-attach-event="click:_onClickIgnoreSelected">Ignore Selected</button>
                <span style="float:right;padding-right:20px;">
                    <input id="hideIgnored" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-event="change:_onChangeHideIgnored" style="margin-top:-4px;"/>
                    <label for="hideIgnored" style="margin-top:4px;outline:none;pointer-events:none;font-style:italic;">Hide Ignored Fields</label>
                </span>
                <span style="float:right;padding-right:20px;">
                    <input id="pauseChangePropagation" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-event="change:_onChangePauseChangePropagation" style="margin-top:-4px;"/>
                    <label for="pauseChangePropagation" style="margin-top:4px;outline:none;pointer-events:none;font-style:italic;">Pause Change Propagation</label>
                </span>
            </div>
            <div data-dojo-attach-point="_divSchemaGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 40px);"></div>
        </div>
        <div data-dojo-attach-point="_divResult" style="padding:5px;" class="">
            <div style="width:calc(100% - 10px);height:30px;font-weight:bold;font-size:18px;">Result</div>
            <div data-dojo-attach-point="_divResultGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 40px);"></div>
        </div>
    </div>
    <div data-dojo-attach-point="_divMap" style="display:none;">
        <div data-dojo-attach-point="_divPivot" style="padding:5px;" class="">
            <div style="width:calc(100% - 10px);height:30px;font-size:18px;">
                <span style="font-weight:bold;font-size:18px;">Pivot <span style="font-weight:normal;font-style:italic;">(* double-click to edit)</span>
                </span>
            <button type="button" style="float:right;font-size:10px;"
                data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteMetricBtn"
                data-dojo-attach-event="click:_onClickDeleteMetric">Delete</button>
            <button type="button" style="float:right;font-size:10px;"
                data-dojo-type="dijit/form/Button" data-dojo-attach-point="_addMetricBtn"
                data-dojo-attach-event="click:_onClickAddMetric">Add</button>
        </div>
            <div data-dojo-attach-point="_divPivotGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 40px);"></div>
        </div>
        <div data-dojo-attach-point="_divCount" style="padding:5px;" class="">
            <div style="width:calc(100% - 10px);height:30px;">
                <span style="font-weight:bold;font-size:18px;">
                    Count <span style="font-weight:normal;font-style:italic;">(* double-click to edit)</span>
                </span>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteCountBtn"
                        data-dojo-attach-event="click:_onClickDeleteCount">Delete</button>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_editCountBtn"
                        data-dojo-attach-event="click:_onClickEditCount">Edit</button>
                <button type="button" style="float:right;font-size:10px;"
                        data-dojo-type="dijit/form/Button" data-dojo-attach-point="_addCountBtn"
                        data-dojo-attach-event="click:_onClickAddCount">Add</button>
            </div>
            <div data-dojo-attach-point="_divCountGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 40px);"></div>
        </div>
    </div>
    <div data-dojo-attach-point="_divEnrich" style="display:none;padding:5px;">
        <div style="width:250px;height:100%;display:inline-block;vertical-align:top;">
            <div style="font-size:14px;font-weight:bold;padding:15px 0px 5px 0px;">Join Type:</div>
            <select style="width:calc(100% - 10px);height:30px;font-size:12px;font-family:monospace;font-size:12px;"
                    data-dojo-type="dijit/form/Select" data-dojo-attach-point="_enrichJoinType"
                    data-dojo-attach-event="change:_onChangeEnrichJoinType" data-dojo-props="maxHeight:200">
                    <!-- only support inner join and left join now -->
                    <option value="InnerJoin">Inner Join (2 way and n-way join)</option>
                    <!-- <option value="SemiJoin_WhiteList">Semi Join</option> -->
                    <!-- <option value="SemiJoin_BlackList">Anti Join</option> -->
                    <option value="LeftOuterJoin">Left Outer Join</option>
                    <!-- <option value="CrossProduct">Cross Product (2 way and n-way join)</option> -->
            </select>
            <div style="font-size:14px;font-weight:bold;padding:5px 0px 5px 0px;">Data Source:</div>
            <select style="width:calc(100% - 10px);height:30px;font-size:12px;font-family:monospace;"
                    data-dojo-type="dijit/form/Select" data-dojo-attach-point="_enrichSource"
                    data-dojo-attach-event="change:_onChangeEnrichSource" data-dojo-props="maxHeight:200">
                <option value="">(none)</option>
            </select>
            <div style="font-size:14px;font-weight:bold;padding:15px 0px 5px 0px;display:none;">Database Name:</div>
            <select style="width:calc(100% - 10px);height:30px;font-size:12px;font-family:monospace;display:none;"
                    data-dojo-type="dijit/form/Select" data-dojo-attach-point="_enrichDatabase"
                    data-dojo-attach-event="change:_onChangeEnrichDatabase" data-dojo-props="maxHeight:200">
                <option value="">(none)</option>
            </select>
            <div style="font-size:14px;font-weight:bold;padding:15px 0px 5px 0px;">Reference Table:</div>
            <select style="width:calc(100% - 10px);height:30px;font-size:12px;font-family:monospace;font-size:12px;"
                    data-dojo-type="dijit/form/Select" data-dojo-attach-point="_enrichTable"
                    data-dojo-attach-event="change:_onChangeEnrichTable" data-dojo-props="maxHeight:200">
                <option value="">(none)</option>
            </select>
            <div style="width:calc(100%); height:30px; padding-top: 5px;">
                <button type="button" style="float:left;font-size:10px;"
                    data-dojo-type="dijit/form/Button" data-dojo-attach-point="_fetchTableBtn"
                    data-dojo-attach-event="click:_onClickFetchTable">
                        Fetch Table List
                </button>
            </div>
        </div>
        <div style="width:calc(100% - 265px);height:100%;display:inline-block;border:thin solid lightgray;" data-dojo-attach-point="_divEnrichGrid">
        </div>
    </div>
    <div data-dojo-attach-point="_divOutput" style="display:none;padding:5px;" class="">
        <div style="width:calc(100% - 10px);height:30px;">
            <span style="font-weight:bold;font-size:18px;">
                Output <span style="font-weight:normal;font-style:italic;">(* double-click to edit)</span>
            </span>
            <button type="button" style="float:right;font-size:10px;"
                    data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteOutputBtn"
                    data-dojo-attach-event="click:_onClickDeleteOutput">Delete</button>
            <button type="button" style="float:right;font-size:10px;"
                    data-dojo-type="dijit/form/Button" data-dojo-attach-point="_addOutputBtn"
                    data-dojo-attach-event="click:_onClickAddOutput">Add</button>
        </div>
        <div style="border:thin solid lightgray;width:calc(100% - 10px); height:calc(100% - 30px);" data-dojo-attach-point="_divOutputGrid">
        </div>
    </div>
    <div data-dojo-attach-point="_divQDC" style="display:none;padding:5px;">
        <div class="vertical-flex" style="height: 100%; width: 100%;">
            <div style="width: 100%; height: auto; flex-shrink:0;">
                <div style="width: 100%; height: 25px">
                    <span style="font-weight:bold;font-size:18px;">
                        System Model Join Conditions
                    </spn>
                </div>
                <div style="width:100%;height:auto;" data-dojo-attach-point="_qdcSleDiv">
                    <div data-dojo-attach-point='sleContainer'></div>
                </div>
                <div style="width: 100%; height: 1px; display: block; margin: 5px 0px; background-color: #CCCCCC;"></div>
            </div>
            <div style="height:calc(100% - 60px); width: 100%; flex-shrink: 1;">
                <table cellpadding="0" cellspacing="0" border="0" style="width:100%; height:100%;" data-dojo-attach-point="_divQDCTable">
                    <tr data-dojo-attach-point="_divQDCTopRow">
                        <td style="width:40%;">
                            <div style="width:100%;height:100%;">
                                <div style="width:calc(100% - 10px);height:30px;">
                                    <span style="font-weight:bold;font-size:18px;">Associated Service/Subservice/Component</span>
                                    <button type="button" style="float:right;font-size:10px;"
                                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteSubserviceBtn"
                                            data-dojo-attach-event="click:_onClickDeleteSubservice">Delete</button>
                                    <button type="button" style="float:right;font-size:10px;"
                                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_addSubserviceBtn"
                                            data-dojo-attach-event="click:_onClickAddSubservice">Add</button>
                                </div>
                                <div data-dojo-attach-point="_divSubserviceGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 30px);" class=""></div>
                            </div>
                        </td>
                        <td style="width:60%">
                            <div style="width:100%;height:100%;">
                                <div style="width:calc(100% - 10px);height:30px;">
                                    <span style="font-weight:bold;font-size:18px;">Qualifying Dimension Constraints</span>
                                    <button type="button" style="float:right;font-size:10px;"
                                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_deleteQDCBtn"
                                            data-dojo-attach-event="click:_onClickDeleteQDC">Delete</button>
                                    <button type="button" style="float:right;font-size:10px;"
                                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_editQDCBtn"
                                            data-dojo-attach-event="click:_onClickEditQDC">Edit</button>
                                    <button type="button" style="float:right;font-size:10px;"
                                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_addQDCBtn"
                                            data-dojo-attach-event="click:_onClickAddQDC">Add</button>
                                    <div style="float:right;font-size:10px;padding-left: 5px;width: 5px;height: 100%;display: inline-block;"></div>
                                    <select style="width:100px;font-family:monospace;float:right;" 
                                        data-dojo-type="dijit/form/Select" 
                                        data-dojo-attach-point="_qdcOperator" 
                                        data-dojo-attach-event="change:_onChangeQdcOperator">
                                        <option value="and">AND</option>
                                        <option value="or">OR</option>
                                    </select>
                                    <span style="float:right;font-size:14px;">Operator:</span>
                                    <div style="float:right;font-size:10px;padding-left: 5px;width: 5px;height: 100%;display: inline-block;"></div>
                                    <select style="width:150px;font-family:monospace;float:right;" 
                                        data-dojo-type="dijit/form/Select" 
                                        data-dojo-attach-point="_qdcScopeSelect" 
                                        data-dojo-attach-event="change:_onChangeQdcScope">
                                    </select>
                                    <span style="float:right;font-size:14px;">Scope:</span>
                                </div>
                                <div data-dojo-attach-point="_divQDCGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 30px);" class=""></div>
                            </div>
                        </td>
                    </tr>
                    <tr data-dojo-attach-point="_divQDCBottomRow">
                        <td colspan="2" style="padding-top:4px;">
                            <div style="width:100%;height:calc(100% - 4px);">
                                <div style="width:calc(100% - 10px);height:30px;">
                                    <span style="font-weight:bold;font-size:18px;">Metric/Service/Subservice/Component Associations</span>
                                </div>
                                <div data-dojo-attach-point="_divMetricGrid" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 30px);" class=""></div>
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    <div data-dojo-attach-point="_divAdvanced" style="display:none;" class="">
        <table cellspacing="5" data-dojo-attach-point="_tableAdvancedInfo" style="width:100%;border:none;background-color:white;padding:0px 0px 10px 0px;">
            <tr style="width:100%;">
                <td style="text-align:right; width: 160px;">Filename Suffix:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;" placeholder="Defaults to match all names"
                           data-dojo-type="dijit/form/ValidationTextBox" data-dojo-attach-point="_filenameFilter" 
                           
                           data-dojo-attach-event="change:_onChangeFilenameFilter"/>
                </td>
                <td style="text-align:right;width: 160px;">Filename Extension:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;"
                           data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_filenameExtension" data-dojo-attach-event="change:_onChangeFilenameExtension"/>
                </td>
                <td style="text-align:right;width: 160px;">Timezone:</td>
                <td style="width: calc(25% - 160px);">
                    <select style="width:calc(100% - 10px);font-family:monospace;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_timezone" data-dojo-attach-event="change:_onChangeTimezone">
                    </select>
                </td>
                <td style="text-align:right;width: 160px;">Daylight Savings:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-point="_dst" data-dojo-attach-event="change:_onChangeDST" />
                </td>
            </tr>
            <tr style="width:100%; display: none;">
                <td style="text-align:right;width: 160px;">Name Prefix:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;"
                           data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_namePrefix" data-dojo-attach-event="change:_onChangeNamePrefix"/>
                </td>
                <td style="text-align:right;width: 160px;">Source Group:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;"
                           data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_sourceGroup" data-dojo-attach-event="change:_onChangeSourceGroup"/>
                </td>
                <td style="text-align:right;width: 160px;">Target Group:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;"
                           data-dojo-type="dijit/form/TextBox" data-dojo-attach-point="_targetGroup" data-dojo-attach-event="change:_onChangeTargetGroup"/>
                </td>
                <td style="text-align:right;width: 160px;"></td>
                <td style="width: calc(25% - 160px);">
                </td>
            </tr>
            <tr style="width:100%;">
                <td style="text-align:right;width: 160px;">Aggregate:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-point="_isMetricAggr" data-dojo-attach-event="change:_onChangeMetricAggr" />
                </td>
                <td style="text-align:right;width: 160px;"  data-dojo-attach-point="_aggrHide1">
                </td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrHide2">
                </td>
                <td style="text-align:right;width: 160px;"" data-dojo-attach-point="_aggrHide3">
                </td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrHide4">
                </td>
                <td style="text-align:right;width: 160px;" data-dojo-attach-point="_aggrHide5">
                </td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrHide6">
                </td>
                <td style="text-align:right;width: 160px;" data-dojo-attach-point="_aggrShow1">Window Size:</td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrShow2">
                    <input type="text" style="width:calc(100% - 80px);font-family:monospace;" data-dojo-type="dijit/form/NumberSpinner" data-dojo-props="constraints:{min:0}"
                        data-dojo-attach-point="_windowSize" data-dojo-attach-event="change:_onChangeWindowSize" />
                    <select style="width:50px;font-family:monospace;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_windowSizeUnit" data-dojo-attach-event="change:_onChangeWindowSizeUnit">
                        <option value="S">Sec</option>
                        <option value="N">Minute</option>
                    </select>
                </td>
                <td style="text-align:right;width: 160px;" data-dojo-attach-point="_aggrShow3">Out Of Order Delay:</td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrShow4">
                    <input type="text" style="width:calc(100% - 80px);font-family:monospace;" data-dojo-type="dijit/form/NumberSpinner" data-dojo-props="constraints:{min:0}" 
                        data-dojo-attach-point="_OOOSize" data-dojo-attach-event="change:_onChangeOOOSize" />
                    <select style="width:50px;font-family:monospace;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_OOOUnit" data-dojo-attach-event="change:_onChangeOOOUnit">
                        <option value="S">Sec</option>
                        <option value="N">Minute</option>
                    </select>
                </td>
                <td style="text-align:right;width: 160px;" data-dojo-attach-point="_aggrShow5"></td>
                <td style="width: calc(25% - 160px);" data-dojo-attach-point="_aggrShow6">
                </td>
            </tr>
            <tr style="width:100%; display:none;" data-dojo-attach-point="_aggrShow7">
                <td style="text-align:right;width: 160px;">Heartbeat Delay:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 80px);font-family:monospace;" data-dojo-type="dijit/form/NumberSpinner" data-dojo-props="constraints:{min:0}" 
                        data-dojo-attach-point="_heartbeatDelaySize" data-dojo-attach-event="change:_onChangeHeartbeatDelaySize" />
                    <select style="width:50px;font-family:monospace;" data-dojo-type="dijit/form/Select" data-dojo-attach-point="_heartbeatDelayUnit" data-dojo-attach-event="change:_onChangeHeartbeatDelayUnit">
                        <option value="S">Sec</option>
                        <option value="N">Minute</option>
                    </select>
                </td>
                <td style="text-align:right;width: 160px;">Stop When Window Empty:</td>
                <td style="width: calc(25% - 160px);">
                    <input type="text" style="width:calc(100% - 10px);font-family:monospace;" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-point="_stopEmptyWindow" data-dojo-attach-event="change:_onChangeStopEmpryWindow" />
                </td>
                <td style="text-align:right;width: 160px;"></td>
                <td style="width: calc(25% - 160px);">
                </td>
                <td style="text-align:right;width: 160px;"></td>
                <td style="width: calc(25% - 160px);">
                </td>
            </tr>
            <tr style="width:100%;">
                <td colspan="8" style="text-align:left;font-size:larger;font-weight:bold;padding-top:10px;">Incident Detection</td>
            </tr>
            <tr style="width:100%;">
                <td colspan="7" style="text-align:left;white-space:normal;">
                    Automatically identify basic thresholds to configure VIA for incident detection.
                    If Baseline Score is selected for the detection algorithm to use, baselines must
                    be computed for each day of the week before we can calculate default thresholds.
                    Currently, the logic for computing thresholds is based simply on taking the
                    99, 97, 95 and 90 percentile value for High, Medium, Low and Warmup. Future enhancements
                    will take advantage of more complex, ML/AI based approach to determine default thresholds.
                </td>
                <td style="">
                    <span data-dojo-attach-point="_computeSettingsSpan"></span>
                    <input id="cbSwagOnly" data-dojo-type="dijit/form/CheckBox" data-dojo-attach-point="_cbSwagOnly"/>
                    <label for="cbSwagOnly" style="outline:none;pointer-events:none;font-style:italic;padding-right:20px;vertical-align:bottom;">Sampling only</label>
                    <button type="button" style="font-size:10px;"
                            data-dojo-type="dijit/form/Button" data-dojo-attach-point="_changeSettingBtn"
                            data-dojo-attach-event="click:_onClickChangeSetting">Change Setting</button>
                </td>
            </tr>
        </table>
        <div data-dojo-attach-point="_divIncidentConfig" style="width:calc(100% - 4px);height:200px;" class="">
        </div>
    </div>
    <div data-dojo-attach-point="_divResource" style="display:none;padding:5px;" class="">
        <div data-dojo-attach-point="_divResourceModel" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 0px);"></div>
    </div>
    <div data-dojo-attach-point="_divParser" style="display:none;padding:5px;" class="">
        <div data-dojo-attach-point="_divParserModel" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 0px);" class="script-div scriptDiv "></div>
    </div>
    <div data-dojo-attach-point="_divAnomaly" style="display:none;padding:5px;" class="">
        <div data-dojo-attach-point="_divAnomalyModel" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 0px);" class="script-div scriptDiv "></div>
    </div>
    <div data-dojo-attach-point="_divSystem" style="display:none;padding:5px;" class="">
        <div data-dojo-attach-point="_divSystemModel" style="border:thin solid lightgray;width:calc(100% - 10px);height:calc(100% - 0px);"></div>
    </div>
</div>
]]>
        </HtmlText>
        <SchemaText>
          <![CDATA[var schema = [];
schema.push({ name:"schema",        label:"Schema",         type:"any[]",   _isDimension:false, _isMeasure:false });
schema.push({ name:"result",        label:"Result",         type:"any[]",   _isDimension:false, _isMeasure:false });
schema.push({ name:"pivot",         label:"Pivot",          type:"any[]",   _isDimension:false, _isMeasure:false });
schema.push({ name:"output",        label:"Output",         type:"any[]",   _isDimension:false, _isMeasure:false });
schema.push({ name:"schemaChanged", label:"Schema Changed", type:"boolean", _isDimension:false, _isMeasure:false });
schema.push({ name:"pivotChanged",  label:"Pivot Changed",  type:"boolean", _isDimension:false, _isMeasure:false });
schema.push({ name:"outputChanged", label:"Output Changed", type:"boolean", _isDimension:false, _isMeasure:false });
return schema;
]]>
        </SchemaText>
      </Widget>
    </Widgets>
    <Functions>
      <Function name="createEnrichTypeMismatchDialog" args="message" private="false">
        <CodeText>
          <![CDATA[prompt(
    "Type Mismatch",
    message,
    [
    ],
    [
        {label: "Yes", value: true, "class": "saveButton", rejectInvalidItem : true}
    ],
    {
        width: "500px",
        "container" : {
            "background-color" : "white",
        },
        "form-label" : {
            "width" : "10%",
            "white-space" : "nowrap",
        },
        "form-value" : {
            "width" : "90%",
        },
    },
    function(value, info) {

    }
);
]]>
        </CodeText>
      </Function>
      <Function name="createProjectDialog" args="callback" private="false">
        <CodeText>
          <![CDATA[prompt(
    "New Service Project",
    "Please provide information to create new project.",
    [
        {name: "svc", label: "Service", type: "string", value: "", disabled: false, 
            style: {
                "width" : "250px",
                "height" : "30px",
                "font-family" : "monospace",
            },
            attributes : {
                pattern : this.nameConstraints().svc.pattern,
                required : true
            }, 
            errorMessage : {
                patternMismatch  : this.nameConstraints().svc.patternMismatch,
                valueMissing : "Service can't be empty",
            }
        },
        {name: "comp", label: "Sub Service", type: "string", value: "", disabled: false, 
            style: {
                "width" : "250px",
                "height" : "30px",
                "font-family" : "monospace",
            },
            attributes : {
                pattern : this.nameConstraints().comp.pattern,
                required : true
            },
            errorMessage : {
                patternMismatch  : this.nameConstraints().comp.patternMismatch,
                valueMissing : "Sub Service can't be empty",
            }
        
        },
        {name: "app", label: "Component", type: "string", value: "", disabled: false, 
            style: {
                "width" : "250px",
                "height" : "30px",
                "font-family" : "monospace",
            },
            attributes : {
                pattern : this.nameConstraints().app.pattern,
                required : true
            },
            errorMessage : {
                patternMismatch  : this.nameConstraints().app.patternMismatch,
                valueMissing : "Component can't be empty",
            }
        },
    ],
    [
        {label: "Yes", value: true, "class": "saveButton", rejectInvalidItem : true},
        {label: "No", value: false},
    ],
    {
        width: "500px",
        "container" : {
            "background-color" : "white",
        },
        "form-label" : {
            "width" : "10%",
            "white-space" : "nowrap",
        },
        "form-value" : {
            "width" : "90%",
        },
    },
    function(value, info) {
        if (value) {
            callback(info);
        }
    }
);
]]>
        </CodeText>
      </Function>
      <Function name="createProjectFilterBar" args="grid,store" private="false">
        <CodeText>
          <![CDATA[// add custom code
const parent = document.createElement('div');
parent.classList.add('projectFilterBar');
const id = Math.random().toString(36).substr(2, 9);
parent.append(createFilterInput(), sortSwitch(id), sortButton(id),sortDecreaseButton(id), styleTag());
return parent;

function sortButton(id){
    const button = document.createElement('label');
    button.htmlFor = id;
    button.innerHTML = '<i class="fas fa-sort-alpha-down"></i>';
    button.classList.add('button', 'sortButton');
    return button;
}

function sortSwitch(id){
    const _switch = document.createElement('input');
    _switch.type = 'checkbox';
    _switch.id = id;
    _switch.classList.add('sortSwitch');
    _switch.addEventListener('change', sort);
    return _switch;
    
    function sort(evt){
        if(evt.target.checked)
            grid.set('sort', [{ property : 'prjName', descending : true }] );
        else
            grid.set('sort', 'prjName');
    }
}

function sortDecreaseButton(id){
    const button = document.createElement('label');
    button.htmlFor = id;
    button.innerHTML = '<i class="fas fa-sort-alpha-down-alt"></i>';
    button.classList.add('button', 'sortDecreaseButton');
    return button;
}

function createFilterInput(){
    const input = document.createElement('input');
    input.placeholder = 'enter key terms to filter list';
    input.classList.add('filterInput');
    input.addEventListener('input', handleInput);
    return input;
}

function filter(filterInput, item, index, items){
    if(!item.prjName) return !filterInput;
    return item.prjName.toLowerCase().indexOf(filterInput) >= 0;
}

function handleInput(event){
    if(!document.body.contains(event.target)) return;
    if(refreshJob) window.clearTimeout(refreshJob);
    var refreshJob = window.setTimeout(refresh, 300);
    
    function refresh(){
        grid.set('collection', store.filter(filter.bind(this, event.target.value.toLowerCase())));
        refreshJob = null;
    }
}

function styleTag(){
    var styles = [
        '.projectFilterBar { border-bottom : 1px solid #148ac4; display : flex; gap : 12px; padding : 0 12px 0 12px }',
        '.projectFilterBar .button { font-size : 20px; } ',
        '.projectFilterBar .sortButton { display : initial } ',
        '.projectFilterBar .sortDecreaseButton { display : none } ',
        '.projectFilterBar :checked ~ .sortButton { display : none } ',
        '.projectFilterBar :checked ~ .sortDecreaseButton { display : initial } ',
        '.projectFilterBar .filterInput { flex : 1 1 auto; border : 0 } ',
        '.projectFilterBar .sortSwitch { display : none } '
    ];
    const styleTag = document.createElement('style');
    styleTag.textContent = styles.join('\n');
    return styleTag;
}]]>
        </CodeText>
      </Function>
      <Function name="deleteProjectDialog" args="controller,StatusService,CommonPlugin,callback" private="false">
        <CodeText>
          <![CDATA[var self = this;
CommonPlugin.popupDialog("Delete Project(s)", 700, 400, false, function(dialog, domGeom, domStyle, domClass, domAttr, domConstruct, on) {

    function getSelectedItems(grid)
    {
        var items = [];
        var data = grid.collection.fetchSync();
        for (var i=0; i<data.length; i++) {
            var item = data[i];
            if (grid.selection[item.prjName] == true) {
                items.push(item);
            }
        }
        return items;
    }
    function onSelect(evt) {
        dialog.value = getSelectedItems(evt.grid);
        dialog.setOkButtonEnable(dialog.value.length > 0);
    }

    require(["af/utils/GridUtil"], function(GridUtil) {
        var div = domConstruct.create("div", {
            "class" : "via-scroller",
            "style" : 'display : flex; flex-direction : column; height : 100%'
        });
        dialog.containerNode.appendChild(div);
        
        var dgridDiv = domConstruct.create("div", {
            "style" : "flex : 1 1 auto" 
        });
        div.append(dgridDiv);
        CommonPlugin.pbShowProgressBar("listProjects", "Retrieving list of projects...");
        self.listProjectPickerList(function(response) {
            if (response.status == "OK") {
                var projects = response.value;
                var columns = [{
                    field : "prjName",
                    label : "Project Name",
                    style : "font-family:monospace;cursor:pointer;",
                    sortable : true,
                }, {
                    field : "uuid",
                    label : "UUID",
                    style : "",
                    renderCell: function (object, value, node) {
                        StatusService.showNotificationToElement(controller, {uuid: value}, node);
                    }
                }];
                var store = GridUtil.createGridStore("prjName", projects);
                var grid = GridUtil.createGridWidget("Projects", dgridDiv, false, null, columns, store,
                                                     onSelect, null, "extended", onSelect, null);
                grid.set('sort', 'prjName');
                div.insertBefore(self.createProjectFilterBar( grid, store), dgridDiv);
            }
            CommonPlugin.pbHideProgressBar("listProjects");
        })
    });

    dialog.setOkButtonEnable(false);

}, callback, "OK");


]]>
        </CodeText>
      </Function>
      <Function name="getFunctionList" args="" private="false">
        <CodeText>
          <![CDATA[return {
	"spark": {
		"list": [
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_group_text.png",
				"group.backgroundColor": "95,111,161",
				"code": "false",
				"helper": "spark/flow/helpers/Group",
				"displayName": "Group",
				"name": "Group",
				"groupLabel": "Group",
				"group.labelColor": "68,68,68",
				"toCustom": "false",
				"dependent": false,
				"group": "Annotation",
				"desc": "Combine blocks together"
			},
			{
				"image": "/vitria-oi/app/spark/block/FeedStreamTarget/FeedTarget.png",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "Feed",
				"acceptedSourceTypes": [
					"DStream"
				],
				"displayOrder": "50",
				"outputType": "*",
				"label": "Feed",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"name": "FeedStreamTarget",
				"model": [
					{
						"editorType": "feedPicker",
						"name": "feed",
						"*": {
							"label": "label"
						},
						"label": "Feed",
						"type": "object",
						"constraints": {
							"type": "feedPicker",
							"args": {
								"children": [
									"bind"
								]
							}
						},
						"optional": true
					},
					{
						"editorType": "feedSchemaMapping",
						"name": "mapping",
						"*": {
							"label": "label"
						},
						"label": "Mapping",
						"type": "string",
						"constraints": "feedSchemaMapping",
						"optional": true
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.xml": "constraints.args.options.0.label",
							"options.json": "constraints.args.options.1.label",
							"options.csv": "constraints.args.options.2.label"
						},
						"group": "common",
						"name": "format",
						"label": "Format",
						"desc": "The output event format",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "",
						"value": "xml",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "XML",
										"value": "xml"
									},
									{
										"label": "JSON",
										"value": "json"
									},
									{
										"label": "CSV",
										"value": "csv"
									}
								],
								"needPlaceholder": false,
								"multiple": false
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.comma": "constraints.args.options.0.label",
							"options.tab": "constraints.args.options.1.label",
							"options.user": "constraints.args.options.2.label"
						},
						"group": "common",
						"name": "delimiterType",
						"label": "Delimiter Type",
						"desc": "The CSV format delimiter type",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "format",
						"controlValue": "csv",
						"value": "comma",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Comma Separated",
										"value": "comma"
									},
									{
										"label": "Tab Separated",
										"value": "tab"
									},
									{
										"label": "User Specified",
										"value": "user"
									}
								],
								"needPlaceholder": false,
								"multiple": false
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "delimiter",
						"label": "Delimiter",
						"desc": "The user specified delimiter value",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "delimiterType",
						"controlValue": "user",
						"value": ""
					}
				],
				"dependent": false,
				"group": "Target",
				"desc": "Feed Target"
			},
			{
				"group.backgroundColor": "106,61,153",
				"image": "/vitria-oi/app/spark/html/images/functions/adf_kpiBlock.png",
				"widget": "spark/kpi/widgets/KPIFunctionWidget",
				"context.menu": "edit:spark.kpi:context.menu.edit",
				"displayName": "KPI",
				"displayOrder": "80",
				"helper": "spark/kpi/helpers/KPIFunctionHelper",
				"name": "KPI",
				"group.labelColor": "black",
				"style": "app/spark/html/themes/hybrid/default/css/function-kpi.css",
				"toCustom": "false",
				"dependent": true,
				"key": "ADF_KPI_Module",
				"group": "Transform",
				"desc": "KPI Function"
			},
			{
				"group.backgroundColor": "255,181,62",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_subflow.png",
				"widget": "spark/property/subflow/SubflowWidget",
				"context.menu": "gotoSubflow:spark.editor:context.menu.gotoSubflow",
				"displayName": "Subflow",
				"displayOrder": "500",
				"groupLabel": "Subflow",
				"groupImage": "/vitria-oi/app/spark/html/images/functions/icon_subflow.png",
				"helper": "spark/property/subflow/SubflowHelper",
				"name": "subflow",
				"group.labelColor": "68,68,68",
				"toCustom": "false",
				"dependent": true,
				"group": "Subflow",
				"desc": "Link a separated subflow diagram",
				"inputMinCount": 1,
				"inputMaxCount": 100,
				"outputMinCount": 1,
				"outputMaxCount": 100,
				"acceptedSourceTypes": [
					"RDD",
					"DStream",
					"DataFrame"
				],
				"outputType": "*",
				"libraries": ""
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_parse.png",
				"group.backgroundColor": "106,61,153",
				"helper": "spark/flow/helpers/Parse",
				"displayName": "Parse",
				"name": "Parse",
				"displayOrder": "10",
				"groupLabel": "Processors",
				"group.labelColor": "68,68,68",
				"dependent": false,
				"group": "Transform",
				"desc": "Convert data into structured data"
			},
			{
				"group.backgroundColor": "255,181,62",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_batch_target.png",
				"helper": "spark/flow/helpers/BatchTarget",
				"displayName": "Batch",
				"name": "BatchTarget",
				"displayOrder": "10",
				"groupLabel": "Targets",
				"group.labelColor": "68,68,68",
				"dependent": false,
				"group": "Target",
				"desc": "Output data for a single batch processing"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_geo_join.png",
				"widget": "spark/geojoin/widgets/GeoJoinFunctionWidget",
				"helper": "spark/geojoin/helpers/GeoJoinFunctionHelper",
				"displayName": "Geo Join",
				"name": "GeoJoin",
				"displayOrder": "35",
				"style": "app/spark/html/themes/hybrid/default/css/function-geojoin.css",
				"dependent": false,
				"key": "ADF_GeoSpatial_Module",
				"group": "Transform",
				"desc": "Join multi data set containing geospatial information"
			},
			{
				"group.backgroundColor": "20,138,196",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_batch.png",
				"helper": "spark/flow/helpers/BatchSource",
				"displayName": "Batch",
				"name": "BatchSource",
				"displayOrder": "10",
				"groupLabel": "Sources",
				"group.labelColor": "68,68,68",
				"dependent": true,
				"group": "Source",
				"desc": "Input data source for a single batch processing"
			},
			{
				"image": "/vitria-oi/app/spark/block/SparkML/icon-22.png",
				"group.backgroundColor": "66,193,80",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "ML Pipeline",
				"acceptedSourceTypes": [
					"RDD",
					"DStream",
					"DataFrame"
				],
				"displayOrder": "20",
				"groupLabel": "Predictive",
				"outputType": "*",
				"label": "ML Pipeline",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "SparkML",
				"group.labelColor": "68,68,68",
				"model": [
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.training": "constraints.args.options.0.label",
							"options.evaluation": "constraints.args.options.1.label"
						},
						"name": "mode",
						"label": "Running Mode",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": false,
						"escapeValue": true,
						"value": "training",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Training",
										"value": "training"
									},
									{
										"label": "Evaluation",
										"value": "evaluation"
									}
								],
								"multiple": false,
								"refs": []
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "modelLocation",
						"label": "Model Location",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"constraints": {
							"args": {}
						}
					},
					{
						"editorType": "statement",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "stages",
						"label": "Pipeline Configuration",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": true,
						"controlName": "mode",
						"controlValue": "training",
						"constraints": {
							"type": "statement",
							"args": {
								"singleLine": "false",
								"path": "spark_block/SparkML/mldef.json"
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "duration",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "refreshInterval",
						"label": "Refresh Interval",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"value": {
							"number": 2,
							"unit": "DAYS"
						},
						"constraints": {
							"type": "range",
							"args": {
								"rangeType": "timeInterval",
								"interval": "relative",
								"valueType": "object",
								"showLabel": false,
								"hideHelp": true,
								"units": "SECONDS,MINUTES,HOURS,DAYS,WEEKS",
								"itemStyle": "width:200px;"
							}
						}
					},
					{
						"editorType": "projection",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "projection",
						"label": "Configure Field Projection",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"controlName": "mode",
						"controlValue": "training",
						"constraints": {
							"type": "projection",
							"args": {
								"nodeType": "all",
								"sourcePrefix": "false",
								"renameable": false,
								"draggable": false,
								"addible": false,
								"expandArray": false,
								"types": [
									"string",
									"boolean",
									"integer",
									"long",
									"double",
									"float",
									"date",
									"time",
									"org.apache.spark.ml.linalg.Vector",
									"datetime",
									"array"
								],
								"defaultProjection": true,
								"syncProjection": true,
								"refs": [
									{
										"name": "defaultProjection",
										"ref": ""
									}
								]
							}
						},
						"sourceSchemaSensitive": true,
						"generateSchema": false
					},
					{
						"editorType": "caseClass",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "case",
						"label": "Case Class",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"value": {
							"name": "",
							"ref": false
						},
						"constraints": "caseClass"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "projectioncopy",
						"label": "property.projectioncopy.label",
						"type": "object",
						"optional": true,
						"hidden": true,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					}
				],
				"dependent": false,
				"key": "ADF_Mllib",
				"group": "Predictive",
				"desc": "Machine learning pipeline training and evaluation"
			},
			{
				"image": "/vitria-oi/app/spark/block/Notification/notification-block.png",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "Notification",
				"acceptedSourceTypes": [
					"DStream"
				],
				"displayOrder": "20",
				"groupLabel": "Alerts & Notifications",
				"outputType": "*",
				"label": "Notification",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"code.generateNotification": "code.generateNotification.js",
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "Notification",
				"model": [
					{
						"editorType": "textInput",
						"*": {
							"label": "label"
						},
						"name": "topicName",
						"label": "Topic Name",
						"type": "string",
						"disabled": false,
						"escapeValue": true,
						"value": "NotificationTopic"
					},
					{
						"editorType": "richText",
						"*": {
							"label": "label",
							"title": "constraints.args.title"
						},
						"name": "subject",
						"label": "Subject",
						"type": "string",
						"disabled": false,
						"escapeValue": false,
						"constraints": {
							"type": "richText",
							"args": {
								"sourceVariables": true,
								"globalProperties": true,
								"buildInVariables": "_user_,_timestamp_",
								"plainText": true,
								"title": "Subject"
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "richText",
						"*": {
							"label": "label",
							"title": "constraints.args.title"
						},
						"name": "shortMessage",
						"label": "Short Message",
						"type": "string",
						"disabled": false,
						"escapeValue": false,
						"constraints": {
							"type": "richText",
							"args": {
								"sourceVariables": true,
								"globalProperties": true,
								"buildInVariables": "_user_,_timestamp_",
								"plainText": true,
								"title": "Short Message"
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "richText",
						"*": {
							"label": "label",
							"title": "constraints.args.title"
						},
						"name": "longMessage",
						"label": "Long Message",
						"type": "string",
						"disabled": false,
						"escapeValue": false,
						"constraints": {
							"type": "richText",
							"args": {
								"sourceVariables": true,
								"globalProperties": true,
								"buildInVariables": "_user_,_timestamp_",
								"title": "Long Message"
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "fieldSelect",
						"*": {
							"label": "label"
						},
						"name": "alertId",
						"label": "Alert ID",
						"type": "string",
						"optional": "true",
						"disabled": false,
						"escapeValue": true,
						"constraints": {
							"type": "fieldSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"expandArray": false,
								"types": [
									"string",
									"boolean",
									"integer",
									"long",
									"double",
									"float",
									"date",
									"time",
									"datetime",
									"array"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "tableResource",
						"*": {
							"label": "label"
						},
						"name": "alertResource",
						"label": "Alert Table Resource",
						"hideLabel": false,
						"type": "object",
						"optional": "true",
						"constraints": {
							"type": "tableResource",
							"args": {}
						}
					}
				],
				"toCustom": "false",
				"dependent": false,
				"key": "ADF_Notification",
				"group": "AlertsNotifications",
				"desc": "Notification",
				"code.generateModel": "code.generateModel.js"
			},
			{
				"image": "/vitria-oi/app/spark/block/ThrottleQuery/icon-22.png",
				"inputMaxCount": 0,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "Throttle Query",
				"acceptedSourceTypes": [],
				"displayOrder": "1000",
				"outputType": "DStream",
				"label": "Throttle Query",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"useHive": "true",
				"inputMinCount": 0,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "ThrottleQuery",
				"model": [
					{
						"editorType": "typeScript",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "sql",
						"label": "SQL Statement",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": false,
						"escapeValue": false,
						"resolveProperty": false,
						"value": "",
						"constraints": {
							"type": "typeScript",
							"args": {
								"scriptMode": "sql",
								"scriptSection": "false",
								"header": "false"
							}
						}
					},
					{
						"editorType": "caseClass",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "case",
						"label": "Case Class",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"resolveProperty": false,
						"value": {
							"name": "",
							"ref": "true",
							"userTyped": false
						},
						"constraints": "caseClass",
						"excluded": true
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "dtFieldName",
						"label": "Growing Field",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"resolveProperty": false,
						"enumSource": ""
					},
					{
						"editorType": "timeRange",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "fromTo",
						"label": "Date Range",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"resolveProperty": false,
						"value": {
							"timezone": "Asia/Shanghai",
							"daylight": "false"
						},
						"constraints": {
							"type": "timeRange",
							"args": {}
						}
					},
					{
						"editorType": "duration",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "timeStep",
						"label": "Step",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"resolveProperty": false,
						"controlName": "",
						"value": {
							"number": "1",
							"unit": "DAYS"
						},
						"constraints": {
							"type": "range",
							"args": {
								"rangeType": "timeInterval",
								"interval": "relative",
								"valueType": "object",
								"showLabel": false,
								"hideHelp": true,
								"units": "MINUTES,HOURS,DAYS",
								"itemStyle": "width:200px;"
							}
						}
					},
					{
						"editorType": "number",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "stepOffset",
						"label": "Start Offset",
						"type": "integer",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"resolveProperty": false,
						"value": 0,
						"constraints": {
							"min": "-999999",
							"max": "0",
							"step": "1",
							"places": "",
							"maxLength": ""
						}
					},
					{
						"editorType": "boolean",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "stop",
						"label": "Stop App ",
						"type": "boolean",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"resolveProperty": false,
						"value": "true"
					}
				],
				"dependent": false,
				"group": "Source",
				"desc": ""
			},
			{
				"group.backgroundColor": "95,111,161",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_annotation_text.png",
				"code": "false",
				"helper": "spark/flow/helpers/TextAnnotations",
				"displayName": "Text Annotation",
				"name": "TextAnnotations",
				"groupLabel": "Annotation",
				"group.labelColor": "68,68,68",
				"toCustom": "false",
				"dependent": false,
				"group": "Annotation",
				"desc": "Adding text description to the data flow"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_ad_hoc.png",
				"helper": "spark/flow/helpers/Adhoc",
				"displayName": "Custom",
				"name": "Adhoc",
				"displayOrder": "500",
				"toCustom": "false",
				"dependent": false,
				"group": "Transform",
				"desc": "Custom data processing logic using Scala code"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_kafka_source.png",
				"widget": "spark/kafka/widgets/KafkaSourceFunctionWidget",
				"helper": "spark/kafka/helpers/KafkaSourceFunctionHelper",
				"displayName": "Kafka",
				"name": "kafkaSource",
				"displayOrder": "60",
				"style": "app/spark/html/themes/hybrid/default/css/function-kafka.css",
				"toCustom": "false",
				"dependent": true,
				"key": "ADF_Kafka_Module",
				"group": "Source",
				"desc": "Load data from kafka source"
			},
			{
				"image": "/vitria-oi/app/spark/block/Python/text-x-python.png",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "Python",
				"acceptedSourceTypes": [
					"RDD",
					"DStream",
					"DataFrame"
				],
				"displayOrder": "30",
				"libraries": [
					"org.zeroturnaround:zt-zip:1.12"
				],
				"outputType": "*",
				"label": "Python Block",
				"groupImage": "",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "Python",
				"model": [
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "pythonCommand",
						"label": "Python command line",
						"desc": "Python command line used to launch Python, %% will be replaced with Python script path.",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": "python %%"
					},
					{
						"editorType": "radio",
						"*": {
							"label": "label",
							"desc": "desc",
							"data.file": "constraints.args.data.0.label",
							"data.script": "constraints.args.data.1.label"
						},
						"group": "common",
						"name": "pythonScriptSelect",
						"label": "Select Python Script",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": "file",
						"constraints": {
							"type": "input",
							"args": {
								"inputType": "radio",
								"data": [
									{
										"value": "file",
										"label": "Specify Python File"
									},
									{
										"value": "script",
										"label": "Input Python Script"
									}
								],
								"itemStyle": "width:300px;"
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "pythonFile",
						"label": "Python File Name",
						"desc": "A local file for python script",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "pythonScriptSelect",
						"controlValue": "file",
						"value": ""
					},
					{
						"editorType": "script",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "pythonScript",
						"label": "Python Script",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "pythonScriptSelect",
						"controlValue": "script",
						"constraints": {
							"type": "script",
							"args": {
								"scriptMode": "python",
								"bodyTemplate": "spark/block/Python/script/pTemplate.py",
								"header": "false"
							}
						}
					},
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "libraries",
						"label": "     ",
						"desc": "Configure Python libraries",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": [],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": true,
								"title": "Configure Python libraries",
								"columns": [
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "url",
										"label": "Url",
										"desc": "File/Folder url",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "enable"
									}
								],
								"heightAdaption": true
							}
						}
					},
					{
						"editorType": "caseClass",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "case",
						"label": "Case Class",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"value": {
							"name": "",
							"ref": false,
							"userTyped": false
						},
						"constraints": {
							"type": "caseClass",
							"args": {
								"editOnly": true
							}
						},
						"excluded": true
					},
					{
						"editorType": "outputSchema",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "schema",
						"label": "Output Schema",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"generateSchema": true,
						"sourceSchemaSensitive": true,
						"escapeValue": false,
						"constraints": {
							"type": "outputSchema",
							"args": {
								"constraints": "outputSchema",
								"extendedTypes": [
									{
										"value": "org.apache.spark.ml.linalg.Vector",
										"label": "org.apache.spark.ml.linalg.Vector"
									}
								]
							}
						}
					},
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "properties",
						"label": "Properties",
						"desc": "Configure properties controlling Python process",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": [],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": true,
								"title": "Configure properties",
								"columns": [
									{
										"name": "name",
										"label": "Key",
										"editorType": "sparkSelect",
										"$$extra": "",
										"*": {
											"label": "label",
											"desc": "desc",
											"options.value1": "constraints.args.options.0.label"
										},
										"type": "string",
										"disabled": "false",
										"defaultValue": "python.timeout",
										"constraints": {
											"type": "sparkSelect",
											"args": {
												"needPlaceholder": false,
												"enumDyn": true,
												"options": [
													{
														"label": "python.timeout",
														"value": "python.timeout"
													}
												],
												"refs": []
											}
										}
									},
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "value",
										"label": "Value",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "enable"
									}
								],
								"heightAdaption": true
							}
						}
					},
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "environments",
						"label": "Environment Variables",
						"desc": "Configure environment variables passed to Python process",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": [],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": true,
								"title": "Configure environment variables",
								"columns": [
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "name",
										"label": "Name",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "enable"
									},
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "value",
										"label": "Value",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "enable"
									}
								],
								"heightAdaption": true
							}
						}
					}
				],
				"dependent": true,
				"group": "Predictive",
				"desc": ""
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon__named_window.png",
				"helper": "spark/flow/helpers/Window",
				"displayName": "Window",
				"name": "Window",
				"displayOrder": "70",
				"dependent": false,
				"group": "Transform",
				"supportFrameFanIn": "false",
				"desc": "A streaming building block that create and update a relation"
			},
			{
				"group.backgroundColor": "66,193,80",
				"image": "/vitria-oi/app/spark/block/Evaluation/icon-22.png",
				"inputMaxCount": 1,
				"outputMaxCount": 22,
				"ui.controller": "controller.js",
				"displayName": "Evaluation",
				"acceptedSourceTypes": [
					"RDD"
				],
				"displayOrder": "1000",
				"outputType": "RDD",
				"label": "Evaluation",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "Evaluation",
				"group.labelColor": "68,68,68",
				"model": [
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.BinaryClassificationMetrics": "constraints.args.options.0.label",
							"options.MulticlassMetrics": "constraints.args.options.1.label",
							"options.MultilabelMetrics": "constraints.args.options.2.label",
							"options.RankingMetrics": "constraints.args.options.3.label",
							"options.RegressionMetrics": "constraints.args.options.4.label"
						},
						"group": "common",
						"name": "metrics",
						"label": "Metrics",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"value": "BinaryClassificationMetrics",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Binary Classification Metrics",
										"value": "BinaryClassificationMetrics"
									},
									{
										"label": "Multiclass Metrics",
										"value": "MulticlassMetrics"
									},
									{
										"label": "Multilabel Metrics",
										"value": "MultilabelMetrics"
									},
									{
										"label": "Ranking Metrics",
										"value": "RankingMetrics"
									},
									{
										"label": "Regression Metrics",
										"value": "RegressionMetrics"
									}
								],
								"needPlaceholder": true,
								"multiple": false
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.precision": "constraints.args.options.0.label",
							"options.recall": "constraints.args.options.1.label",
							"options.fmeasure": "constraints.args.options.2.label",
							"options.ROC": "constraints.args.options.3.label",
							"options.auROC": "constraints.args.options.4.label",
							"options.auPRC": "constraints.args.options.5.label"
						},
						"group": "common",
						"name": "bcOutputs",
						"label": "Outputs",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "BinaryClassificationMetrics",
						"value": "precision,recall,fmeasure,ROC,auROC,auPRC",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Precision",
										"value": "precision"
									},
									{
										"label": "Recall",
										"value": "recall"
									},
									{
										"label": "F-Measure",
										"value": "fmeasure"
									},
									{
										"label": "ROC",
										"value": "ROC"
									},
									{
										"label": "Area Under ROC",
										"value": "auROC"
									},
									{
										"label": "Area Under PR",
										"value": "auPRC"
									}
								],
								"needPlaceholder": true,
								"multiple": true
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.accuracy": "constraints.args.options.0.label",
							"options.precision": "constraints.args.options.1.label",
							"options.recall": "constraints.args.options.2.label",
							"options.fmeasure": "constraints.args.options.3.label",
							"options.fpr": "constraints.args.options.4.label",
							"options.tpr": "constraints.args.options.5.label",
							"options.wprecision": "constraints.args.options.6.label",
							"options.wrecall": "constraints.args.options.7.label",
							"options.wfmeasure": "constraints.args.options.8.label",
							"options.wfpr": "constraints.args.options.9.label",
							"options.wtpr": "constraints.args.options.10.label",
							"options.confusionMatrix": "constraints.args.options.11.label"
						},
						"group": "common",
						"name": "mcOutputs",
						"label": "Outputs",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "MulticlassMetrics",
						"value": "accuracy,precision,recall,fmeasure,fpr,tpr,wprecision,wrecall,wfmeasure,wfpr,wtpr,confusionMatrix",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Accuracy",
										"value": "accuracy"
									},
									{
										"label": "Precision",
										"value": "precision"
									},
									{
										"label": "Recall",
										"value": "recall"
									},
									{
										"label": "F-Measure",
										"value": "fmeasure"
									},
									{
										"label": "False Positive Rate",
										"value": "fpr"
									},
									{
										"label": "True Positive Rate",
										"value": "tpr"
									},
									{
										"label": "Weighted Precision",
										"value": "wprecision"
									},
									{
										"label": "Weighted Recall",
										"value": "wrecall"
									},
									{
										"label": "Weighted F-Measure",
										"value": "wfmeasure"
									},
									{
										"label": "Weighted False Positive Rate",
										"value": "wfpr"
									},
									{
										"label": "Weighted True Positive Rate",
										"value": "wtpr"
									},
									{
										"label": "Confusion Matrix",
										"value": "confusionMatrix"
									}
								],
								"needPlaceholder": true,
								"multiple": true
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.mse": "constraints.args.options.0.label",
							"options.rmse": "constraints.args.options.1.label",
							"options.mae": "constraints.args.options.2.label",
							"options.r2": "constraints.args.options.3.label",
							"options.ev": "constraints.args.options.4.label"
						},
						"group": "common",
						"name": "rOutputs",
						"label": "Outputs",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "RegressionMetrics",
						"value": "mse,rmse,mae,r2,ev",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Mean Squared Error",
										"value": "mse"
									},
									{
										"label": "Root Mean Squared Error",
										"value": "rmse"
									},
									{
										"label": "Mean Absolute Error",
										"value": "mae"
									},
									{
										"label": "Coefficient of Determination",
										"value": "r2"
									},
									{
										"label": "Explained Variance",
										"value": "ev"
									}
								],
								"needPlaceholder": true,
								"multiple": true
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.precision": "constraints.args.options.0.label",
							"options.recall": "constraints.args.options.1.label",
							"options.accuracy": "constraints.args.options.2.label",
							"options.precisionByLabel": "constraints.args.options.3.label",
							"options.recallByLabel": "constraints.args.options.4.label",
							"options.f1MeasureByLabel": "constraints.args.options.5.label",
							"options.hammingLoss": "constraints.args.options.6.label",
							"options.subsetAccuracy": "constraints.args.options.7.label",
							"options.f1Measure": "constraints.args.options.8.label",
							"options.microPrecision": "constraints.args.options.9.label",
							"options.microRecall": "constraints.args.options.10.label",
							"options.microF1Measure": "constraints.args.options.11.label"
						},
						"group": "common",
						"name": "mlOutputs",
						"label": "Outputs",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "MultilabelMetrics",
						"value": "precision,recall,accuracy,precisionByLabel,recallByLabel,f1MeasureByLabel,hammingLoss,subsetAccuracy,f1Measure,microPrecision,microRecall,microF1Measure",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Precision",
										"value": "precision"
									},
									{
										"label": "Recall",
										"value": "recall"
									},
									{
										"label": "Accuracy",
										"value": "accuracy"
									},
									{
										"label": "Precision By Label",
										"value": "precisionByLabel"
									},
									{
										"label": "Recall By Label",
										"value": "recallByLabel"
									},
									{
										"label": "F1-Measure By Label",
										"value": "f1MeasureByLabel"
									},
									{
										"label": "Hamming Loss",
										"value": "hammingLoss"
									},
									{
										"label": "Subset Accuracy",
										"value": "subsetAccuracy"
									},
									{
										"label": "F1 Measure",
										"value": "f1Measure"
									},
									{
										"label": "Micro Precision",
										"value": "microPrecision"
									},
									{
										"label": "Micro Recall",
										"value": "microRecall"
									},
									{
										"label": "Micro F1 Measure",
										"value": "microF1Measure"
									}
								],
								"needPlaceholder": true,
								"multiple": true
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.precision": "constraints.args.options.0.label",
							"options.meanAveragePrecision": "constraints.args.options.1.label",
							"options.ndcg": "constraints.args.options.2.label"
						},
						"group": "common",
						"name": "rkOutputs",
						"label": "Outputs",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "RankingMetrics",
						"value": "precision,meanAveragePrecision,ndcg",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Precision",
										"value": "precision"
									},
									{
										"label": "Mean Average Precision",
										"value": "meanAveragePrecision"
									},
									{
										"label": "Normalized Discounted Cumulative Gain",
										"value": "ndcg"
									}
								],
								"needPlaceholder": true,
								"multiple": true
							}
						}
					},
					{
						"editorType": "fieldSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "prediction",
						"label": "Prediction",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "BinaryClassificationMetrics,MulticlassMetrics,RegressionMetrics",
						"constraints": {
							"type": "fieldSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"double"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "fieldSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "label",
						"label": "Label",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "BinaryClassificationMetrics,MulticlassMetrics,RegressionMetrics",
						"constraints": {
							"type": "fieldSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"double"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "fieldSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "labelLiteral",
						"label": "Label Literal",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "MulticlassMetrics",
						"constraints": {
							"type": "fieldSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"string"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "fieldMultiSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "mlPrediction",
						"label": "Prediction",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "MultilabelMetrics,RankingMetrics",
						"constraints": {
							"type": "fieldMultiSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"double"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "fieldMultiSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "mlLabel",
						"label": "Label",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "MultilabelMetrics,RankingMetrics",
						"constraints": {
							"type": "fieldMultiSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"double"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "fMeasureBeta",
						"label": "The beta factor in F-Measure computation",
						"type": "double",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "BinaryClassificationMetrics,MulticlassMetrics",
						"value": 1
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "rank",
						"label": "Rank",
						"type": "string",
						"optional": false,
						"hidden": true,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "metrics",
						"controlValue": "RankingMetrics",
						"value": "1, 3, 5"
					}
				],
				"dependent": false,
				"group": "Predictive",
				"desc": ""
			},
			{
				"image": "/vitria-oi/app/spark/block/inPort/icon_inport.png",
				"inputMaxCount": 0,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"code": false,
				"displayName": "Input Port",
				"acceptedSourceTypes": [
					"RDD",
					"DStream",
					"DataFrame"
				],
				"displayOrder": "0",
				"outputType": "*",
				"label": "Input Port",
				"outputMinCount": 1,
				"isBuilt": true,
				"hidePortLabel": true,
				"inputMinCount": 0,
				"code.template": "code.stg",
				"name": "inPort",
				"fixedSize": true,
				"model": [
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "portType",
						"label": "Port Type",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"generateSchema": true,
						"impactSchema": true,
						"escapeValue": true,
						"value": "*",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Inherited from client",
										"value": "*"
									},
									{
										"label": "RDD",
										"value": "RDD"
									},
									{
										"label": "DStream",
										"value": "DStream"
									},
									{
										"label": "DataFrame",
										"value": "DataFrame"
									}
								],
								"multiple": false
							}
						}
					},
					{
						"editorType": "typePicker",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "type",
						"label": "Type",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"constraints": {
							"type": "typePicker",
							"args": {
								"kind": "all"
							}
						},
						"generateSchema": true
					}
				],
				"toCustom": false,
				"dependent": false,
				"group": "Subflow",
				"desc": "Define input port properties"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_stream.png",
				"helper": "spark/flow/helpers/StreamSource",
				"displayName": "Streaming",
				"name": "StreamSource",
				"displayOrder": "20",
				"groupLabel": "Sources",
				"dependent": true,
				"group": "Source",
				"desc": "Input data source used for continuous stream processing"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_JDBC.png",
				"helper": "spark/flow/helpers/JDBCBatch",
				"displayName": "JDBC Batch",
				"name": "JDBCBatch",
				"displayOrder": "40",
				"groupLabel": "Sources",
				"dependent": true,
				"group": "Source",
				"desc": "JDBCBatch"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_table.png",
				"helper": "spark/flow/helpers/SourceTable",
				"displayName": "Source Table",
				"name": "SourceTable",
				"displayOrder": "30",
				"groupLabel": "Sources",
				"dependent": false,
				"group": "Source",
				"desc": "Input data source for SQL processing"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_join.png",
				"helper": "spark/flow/helpers/Join",
				"displayName": "Join",
				"name": "Join",
				"displayOrder": "30",
				"dependent": false,
				"group": "Transform",
				"desc": "Combine data from multiple sources based on join conditions"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_JDBC_stream.png",
				"helper": "spark/flow/helpers/JDBCStream",
				"displayName": "JDBC Streaming",
				"name": "JDBCStream",
				"displayOrder": "50",
				"groupLabel": "Sources",
				"dependent": true,
				"group": "Source",
				"desc": "Input data source from JDBC resource"
			},
			{
				"group.backgroundColor": "66,193,80",
				"image": "/vitria-oi/app/spark/block/PrepareBlock/icon-22.png",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "ML Parse",
				"acceptedSourceTypes": [
					"RDD",
					"DStream"
				],
				"displayOrder": "1",
				"outputType": "*",
				"label": "ML Parse",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "PrepareBlock",
				"group.labelColor": "68,68,68",
				"model": [
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.libsvm": "constraints.args.options.0.label",
							"options.csv": "constraints.args.options.1.label"
						},
						"name": "format",
						"label": "Format",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"value": "libsvm",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "LIBSVM",
										"value": "libsvm"
									},
									{
										"label": "CSV",
										"value": "csv"
									}
								],
								"multiple": false
							}
						}
					},
					{
						"editorType": "boolean",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "hasHeader",
						"label": "Get field name from the header of CSV",
						"type": "boolean",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": true,
						"value": "true"
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.csv": "constraints.args.options.0.label",
							"options.tsv": "constraints.args.options.1.label",
							"options.other": "constraints.args.options.2.label"
						},
						"name": "delimiterType",
						"label": "Delimiter Type",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"value": "csv",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Comma Separated Values",
										"value": "csv"
									},
									{
										"label": "Tab Separated Values",
										"value": "tsv"
									},
									{
										"label": "User Specified",
										"value": "other"
									}
								],
								"multiple": false,
								"context": {
									"_pid": "3012b34c-fff1-40d6-8819-0e2ad5efe95a"
								},
								"_cid": "38b54e3d-b367-4b67-8cea-192e36534ce4",
								"name": "value"
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "delimiter",
						"label": "Delimiter",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": true,
						"constraints": {
							"args": {}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "labelCol",
						"label": "Output Column Name of Label",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": true,
						"value": "label"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "featureCol",
						"label": "Output Column Name of Feature",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": true,
						"value": "feature"
					},
					{
						"editorType": "number",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "featureNumber",
						"label": "Number of Features",
						"type": "long",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"value": -1,
						"constraints": {
							"min": "-1",
							"max": "999999",
							"step": "1"
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "fieldIndexes",
						"label": "Indices for Feature (eg,0,1,5-10)",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": false,
						"value": "",
						"constraints": {
							"args": {}
						}
					},
					{
						"editorType": "select",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "mergeFunction",
						"label": "Function to merge multiple columns into a feature column",
						"type": "string",
						"optional": false,
						"hidden": "true",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"value": "org.apache.spark.ml.linalg.Vectors.dense"
					},
					{
						"editorType": "caseClass",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "case",
						"label": "Case Class",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"value": {
							"name": "",
							"ref": false
						},
						"constraints": "caseClass"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "header",
						"label": "Header Fields",
						"type": "string",
						"optional": "true",
						"hidden": "true",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					},
					{
						"editorType": "schemaEditor",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "schema",
						"label": "Schema",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"constraints": {
							"type": "parseSchema",
							"args": {
								"constraints": "parseSchema",
								"extendedTypes": [
									{
										"value": "org.apache.spark.ml.linalg.Vector",
										"label": "Vector"
									}
								],
								"addable": false,
								"delete": false,
								"option": true,
								"exclude": true
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "schemaChangeByUI",
						"label": "schemachangebyui",
						"type": "string",
						"optional": true,
						"hidden": true,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					}
				],
				"dependent": false,
				"key": "ADF_Mllib",
				"group": "Predictive",
				"desc": "Machine learning parse data"
			},
			{
				"image": "/vitria-oi/app/spark/block/outPort/icon_outport.png",
				"inputMaxCount": 1,
				"outputMaxCount": 0,
				"ui.controller": "controller.js",
				"code": false,
				"displayName": "Output Port",
				"acceptedSourceTypes": [
					"RDD",
					"DStream",
					"DataFrame"
				],
				"displayOrder": "10",
				"outputType": "*",
				"label": "Output Port",
				"groupImage": "",
				"outputMinCount": 0,
				"isBuilt": true,
				"hidePortLabel": true,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"name": "outPort",
				"fixedSize": true,
				"model": [
					{
						"editorType": "typePicker",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "type",
						"label": "Type",
						"type": "object",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": true,
						"constraints": {
							"type": "typePicker",
							"args": {
								"kind": "all"
							}
						},
						"generateSchema": true
					}
				],
				"toCustom": false,
				"dependent": false,
				"group": "Subflow",
				"desc": "Define output port properties"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_run_JDBC.png",
				"helper": "spark/flow/helpers/RunSQL",
				"displayName": "RunSQL",
				"name": "RunSQL",
				"displayOrder": "100",
				"dependent": false,
				"group": "Transform",
				"desc": "Perform SQL computation on data source table"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/StateMachine.png",
				"widget": "spark/stateMachine/widgets/StateMachineFunctionWidget",
				"helper": "spark/stateMachine/helpers/StateMachineFunctionHelper",
				"displayName": "State Machine",
				"name": "stateMachine",
				"displayOrder": "150",
				"style": "app/spark/html/themes/hybrid/default/css/function-sm.css",
				"dependent": false,
				"key": "ADF_State_Machine",
				"group": "Transform",
				"desc": "State machine building block"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_filter.png",
				"helper": "spark/flow/helpers/Filter",
				"displayName": "Filter",
				"name": "Filter",
				"displayOrder": "20",
				"dependent": false,
				"properties": {
					"schema": false,
					"script": true,
					"scriptLabel": "Filter Expression"
				},
				"group": "Transform",
				"desc": "Filter data based on filtering expressions"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_target_JDBC.png",
				"helper": "spark/flow/helpers/JDBCTarget",
				"displayName": "JDBC",
				"name": "JDBCTarget",
				"displayOrder": "40",
				"groupLabel": "Targets",
				"dependent": false,
				"group": "Target",
				"desc": "Output data to JDBC resource"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_compute.png",
				"helper": "spark/flow/helpers/Compute",
				"displayName": "Derived Fields",
				"name": "Compute",
				"displayOrder": "50",
				"dependent": false,
				"group": "Transform",
				"desc": "Compute additional data fields using calculation expressions"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_predictive_pmml.png",
				"group.backgroundColor": "66,193,80",
				"widget": "spark/predictive/widgets/PMMLFunctionWidget",
				"displayName": "PMML",
				"groupLabel": "Predictive",
				"helper": "spark/predictive/helpers/PMMLFunctionHelper",
				"name": "PMML",
				"style": "app/spark/html/themes/hybrid/default/css/function-predictive.css",
				"group.labelColor": "68,68,68",
				"toCustom": "false",
				"dependent": true,
				"key": "ADF_PMML_Module",
				"group": "Predictive",
				"desc": "Make a prediction on input data according to PMML model"
			},
			{
				"group.backgroundColor": "180,70,70",
				"image": "/vitria-oi/app/spark/block/Alert/alert-block.png",
				"inputMaxCount": 1,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "Alert",
				"acceptedSourceTypes": [
					"DStream"
				],
				"displayOrder": "10",
				"groupLabel": "Alerts & Notifications",
				"outputType": "*",
				"label": "Alert",
				"groupImage": "/vitria-oi/app/spark/block/Alert/AlertNotification_group_icon.png",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "Alert",
				"model": [
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"name": "compute",
						"label": "Alert Mapping",
						"type": "object",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": false,
						"sourceSchemaSensitive": true,
						"value": [
							{
								"name": "Id",
								"label": "Id *",
								"type": "string",
								"sleText": {
									"text": "uuid()",
									"type": "string",
									"option": false
								},
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "EntityId",
								"label": "EntityId *",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "AssociatedEntityId",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "FirstOccurred",
								"label": "FirstOccurred *",
								"type": "datetime",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "LastOccurred",
								"type": "datetime",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Created",
								"label": "Created *",
								"type": "datetime",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Timebin",
								"label": "Timebin *",
								"type": "long",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Measure",
								"label": "Measure *",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "ThresholdSetting",
								"label": "ThresholdSetting *",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "HighThreshold",
								"label": "HighThreshold *",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": false,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "LowThreshold",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Judgement",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "TriggerDuration",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Lat",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Lon",
								"type": "double",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "ContextURL",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							},
							{
								"name": "Detail",
								"type": "string",
								"sleText": "",
								"skip": false,
								"skipable": true,
								"_deletable": false,
								"buildin": true
							}
						],
						"constraints": {
							"type": "grid",
							"args": {
								"popup": false,
								"addable": true,
								"title": "Map alert fields from input fields",
								"columns": [
									{
										"_id": "6d3f30fc-560f-44f2-8bf3-83ac3249419d",
										"*": {
											"label": "label"
										},
										"name": "name",
										"showLabel": true,
										"labelField": "label",
										"label": "Alert Field Name",
										"editorType": "textInput",
										"$$extra": "",
										"type": "string",
										"editable": "false",
										"controlName": "buildin",
										"controlValue": false,
										"initProperty": {
											"buildin": false
										}
									},
									{
										"_id": "a3cf9bee-3511-4761-8c5a-4a27aadb186c",
										"*": {
											"label": "label"
										},
										"name": "type",
										"label": "Data Type",
										"editorType": "sparkSelect",
										"$$extra": "",
										"type": "string",
										"editable": "false",
										"width": 100,
										"controlName": "buildin",
										"controlValue": false,
										"defaultValue": "string",
										"constraints": {
											"type": "sparkSelect",
											"args": {
												"optionsReference": "$global.primitiveTypes"
											}
										}
									},
									{
										"_id": "aeff15b5-2ee5-4173-89e3-fecdfa49b00c",
										"*": {
											"label": "label"
										},
										"name": "sleText",
										"label": "Input Field Expression",
										"editorType": "sle",
										"$$extra": "",
										"type": "object",
										"editable": "false",
										"controlName": "name",
										"controlValue": "Id",
										"controlPolicy": "disable",
										"constraints": {
											"type": "sle",
											"args": {
												"validateProperty": "true",
												"sourcePrefix": "false",
												"nodeType": "primitive",
												"expandArray": false,
												"types": [
													"string",
													"boolean",
													"integer",
													"long",
													"double",
													"float",
													"date",
													"time",
													"datetime",
													"array"
												],
												"refs": [
													{
														"name": "targetType",
														"ref": "$.type"
													},
													{
														"name": "novalidate",
														"ref": "$.skip"
													}
												]
											}
										},
										"sourceSchemaSensitive": true
									},
									{
										"_id": "7c08e97c-12aa-4143-8dfd-3df4cac97816",
										"*": {
											"label": "label"
										},
										"name": "skip",
										"label": "Skip",
										"editorType": "boolean",
										"$$extra": "",
										"type": "checkbox",
										"editable": "false",
										"width": 30,
										"display": "skipable",
										"defaultValue": false,
										"initProperty": {
											"skipable": false
										}
									}
								],
								"heightAdaption": "true"
							}
						}
					},
					{
						"editorType": "caseClass",
						"*": {
							"label": "label"
						},
						"name": "case",
						"label": "Case Class",
						"type": "object",
						"disabled": false,
						"escapeValue": true,
						"value": {
							"ref": false
						},
						"optional": "true",
						"constraints": {
							"type": "caseClass",
							"args": {
								"editOnly": true
							}
						},
						"impactSchema": true
					}
				],
				"dependent": false,
				"key": "ADF_Notification",
				"group": "AlertsNotifications",
				"desc": "Alert"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_streaming_target.png",
				"helper": "spark/flow/helpers/StreamTarget",
				"displayName": "Streaming",
				"name": "StreamTarget",
				"displayOrder": "20",
				"groupLabel": "Targets",
				"dependent": false,
				"group": "Target",
				"desc": "Output data for continuous stream processing"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_kafka_target.png",
				"widget": "spark/kafka/widgets/KafkaTargetFunctionWidget",
				"helper": "spark/kafka/helpers/KafkaTargetFunctionHelper",
				"displayName": "Kafka",
				"name": "kafkaTarget",
				"displayOrder": "50",
				"toCustom": "false",
				"dependent": true,
				"key": "ADF_Kafka_Module",
				"group": "Target",
				"desc": "Output data to kafka target"
			},
			{
				"image": "/vitria-oi/app/spark/html/images/functions/icon_aggregate.png",
				"helper": "spark/flow/helpers/Aggregate",
				"displayName": "Aggregate",
				"name": "Aggregate",
				"displayOrder": "60",
				"dependent": false,
				"properties": {
					"schema": false,
					"script": false,
					"scriptLabel": "Aggregation Expression",
					"windowSpec": true,
					"windowShow": false
				},
				"group": "Transform",
				"desc": "Aggregate data values based on dimension grouping"
			},
			{
				"group.backgroundColor": "66,193,80",
				"image": "/vitria-oi/app/spark/block/Split/icon-22.png",
				"inputMaxCount": 1,
				"outputMaxCount": 22,
				"ui.controller": "controller.js",
				"displayName": "Split",
				"acceptedSourceTypes": [
					"RDD",
					"DataFrame"
				],
				"displayOrder": "1000",
				"outputType": "*",
				"label": "Split",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 1,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "Split",
				"group.labelColor": "68,68,68",
				"model": [
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.randomSplit": "constraints.args.options.0.label",
							"options.sleSplit": "constraints.args.options.1.label",
							"options.stratifiedSampling": "constraints.args.options.2.label"
						},
						"group": "common",
						"name": "type",
						"label": "Type",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"value": "randomSplit",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Random Split",
										"value": "randomSplit"
									},
									{
										"label": "SLE Expression Split",
										"value": "sleSplit"
									},
									{
										"label": "Stratified Sampling",
										"value": "stratifiedSampling"
									}
								],
								"needPlaceholder": true,
								"multiple": false
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "randomSplitSeed",
						"label": "Seed",
						"type": "long",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "randomSplit",
						"value": 10000
					},
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "randomSplitWeights",
						"label": "Weights",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": true,
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "randomSplit",
						"value": [],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": true,
								"title": "Please configure the weights for each split parts. The sum of all weighs should be 1.",
								"columns": [
									{
										"editorType": "number",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "weight",
										"label": "Weight",
										"type": "double",
										"disabled": "false",
										"controlPolicy": "enable",
										"constraints": {
											"min": "0",
											"max": "1",
											"step": "0.1",
											"maxLength": "4"
										}
									}
								],
								"heightAdaption": false
							}
						}
					},
					{
						"editorType": "sle",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "sleExpression",
						"label": "SLE Expression",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "sleSplit",
						"constraints": {
							"type": "sle",
							"args": {
								"validateProperty": "false",
								"targetType": [
									"boolean"
								],
								"sourcePrefix": "false",
								"predefinedPrefixes": [],
								"additionalFields": [],
								"nodeType": "all",
								"expandArray": false,
								"types": [
									"string",
									"boolean",
									"integer",
									"long",
									"double",
									"float",
									"date",
									"time",
									"datetime",
									"array"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.sampleByKey": "constraints.args.options.0.label",
							"options.sampleByKeyExact": "constraints.args.options.1.label"
						},
						"group": "common",
						"name": "ssSampleAPI",
						"label": "Sample Type",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "stratifiedSampling",
						"value": "sampleByKey",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "Approximate",
										"value": "sampleByKey"
									},
									{
										"label": "Exact",
										"value": "sampleByKeyExact"
									}
								],
								"needPlaceholder": true,
								"multiple": false
							}
						}
					},
					{
						"editorType": "fieldSelect",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "ssKeyField",
						"label": "Key Field",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "stratifiedSampling",
						"constraints": {
							"type": "fieldSelect",
							"args": {
								"nodeType": "primitive",
								"sourcePrefix": "false",
								"sourceName": "",
								"expandArray": false,
								"types": [
									"string",
									"boolean",
									"integer",
									"long",
									"double",
									"float",
									"date",
									"time",
									"datetime",
									"array"
								]
							}
						},
						"sourceSchemaSensitive": true
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "ssFraction",
						"label": "Fraction",
						"type": "double",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "stratifiedSampling"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "ssSeed",
						"label": "Seed",
						"type": "long",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "type",
						"controlValue": "stratifiedSampling",
						"value": 10000
					}
				],
				"dependent": false,
				"group": "Predictive",
				"desc": ""
			},
			{
				"image": "/vitria-oi/app/spark/block/MQTTSource/MQTTSource.png",
				"inputMaxCount": 0,
				"outputMaxCount": 1,
				"ui.controller": "controller.js",
				"displayName": "MQTT",
				"acceptedSourceTypes": [
					"DStream"
				],
				"displayOrder": "70",
				"libraries": [
					"${VTBA_HOME}/applications/home/work/spark.app/spark/lib/com.vitria.spark.mqtt.jar",
					"${VTBA_HOME}/applications/home/work/spark.app/spark/lib/org.eclipse.paho.client.mqttv3-1.0.2.jar",
					"${VTBA_HOME}/wildfly/modules/com/vitria/vtlibs/main/vtfc.jar"
				],
				"outputType": "DStream",
				"label": "MQTT",
				"code.variables": "code.variables.json",
				"outputMinCount": 1,
				"inputMinCount": 0,
				"code.template": "code.stg",
				"code.enrichment": "code.enrichment.js",
				"name": "MQTTSource",
				"model": [
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "serverURI",
						"label": "Server URI",
						"desc": "The mqtt server which this component will connect to.",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": [
							{
								"_id": "a65e18ee-5890-4de3-862e-31768f6c1307",
								"protocol": "tcp",
								"host": "",
								"port": "",
								"_deletable": false
							}
						],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": false,
								"title": " ",
								"columns": [
									{
										"editorType": "sparkSelect",
										"*": {
											"label": "label",
											"desc": "desc",
											"options.tcp": "constraints.args.options.0.label",
											"options.ssl": "constraints.args.options.1.label"
										},
										"name": "protocol",
										"label": "Protocol",
										"type": "string",
										"disabled": "false",
										"width": 100,
										"controlPolicy": "enable",
										"constraints": {
											"type": "sparkSelect",
											"args": {
												"options": [
													{
														"label": "TCP",
														"value": "tcp"
													},
													{
														"label": "SSL",
														"value": "ssl"
													}
												],
												"needPlaceholder": false,
												"multiple": false
											}
										}
									},
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "host",
										"label": "Host",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "disable"
									},
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "port",
										"label": "Port",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "disable"
									}
								],
								"heightAdaption": true
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "trustStore",
						"label": "Trust Store",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					},
					{
						"editorType": "password",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "trustStorePassword",
						"label": "Trust Store Password",
						"desc": "Password of TrustStore.",
						"type": "string",
						"optional": true,
						"hidden": false,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "",
						"value": "",
						"constraints": "password"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"group": "common",
						"name": "keyStore",
						"label": "Key Store",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					},
					{
						"editorType": "password",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "keyStorePassword",
						"label": "Key Store Password",
						"desc": "Password of Key Store.",
						"type": "string",
						"optional": true,
						"hidden": false,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "",
						"value": "",
						"constraints": "password"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "keyAlias",
						"label": "Key Alias",
						"desc": "Specify which certification in Key Store will be used for SSL.",
						"type": "string",
						"optional": true,
						"hidden": false,
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": ""
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "clientID",
						"label": "Client ID",
						"desc": "Client ID.",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					},
					{
						"editorType": "grid",
						"*": {
							"label": "label",
							"desc": "desc",
							"title": "constraints.args.title",
							"columns": "constraints.args.columns"
						},
						"group": "common",
						"name": "topics",
						"label": " ",
						"desc": "Identify the topics that mqttSource subscribe to.",
						"type": "object",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"value": [
							{
								"_id": "9e49b5bb-e4a1-4f55-84cb-b2a33de73aea",
								"topicValue": "",
								"_deletable": false
							}
						],
						"constraints": {
							"type": "grid",
							"args": {
								"reorder": "false",
								"popup": false,
								"addable": true,
								"title": " Topics",
								"columns": [
									{
										"editorType": "textInput",
										"*": {
											"label": "label",
											"desc": "desc"
										},
										"name": "topicValue",
										"label": " ",
										"type": "string",
										"disabled": "false",
										"controlPolicy": "enable"
									}
								],
								"heightAdaption": true
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "userName",
						"label": "User Name",
						"desc": "The user name to use for the connection.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true
					},
					{
						"editorType": "password",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "password",
						"label": "Password",
						"desc": "The password to use for the connection.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"value": "",
						"constraints": "password"
					},
					{
						"editorType": "radio",
						"*": {
							"label": "label",
							"desc": "desc",
							"data.default": "constraints.args.data.0.label",
							"data.custom": "constraints.args.data.1.label"
						},
						"group": "common",
						"name": "messageConverterControl",
						"label": "Message Converter",
						"desc": "Customized message converter, the message converter will convert a message from byte array to string.",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": "default",
						"constraints": {
							"type": "input",
							"args": {
								"inputType": "radio",
								"data": [
									{
										"value": "default",
										"label": "Default"
									},
									{
										"value": "custom",
										"label": "Custom"
									}
								],
								"itemStyle": "width:300px;"
							}
						}
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.UTF-8": "constraints.args.options.0.label",
							"options.GB2312": "constraints.args.options.1.label",
							"options.GBK": "constraints.args.options.2.label",
							"options.UTF-16": "constraints.args.options.3.label",
							"options.UTF-16BE": "constraints.args.options.4.label",
							"options.UTF-16LE": "constraints.args.options.5.label",
							"options.UTF-32": "constraints.args.options.6.label",
							"options.UTF-32BE": "constraints.args.options.7.label",
							"options.UTF-32LE": "constraints.args.options.8.label"
						},
						"group": "common",
						"name": "encoding",
						"label": "Encoding",
						"desc": "Encoding used the transform message playload to String.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "messageConverterControl",
						"controlValue": "default",
						"value": "UTF-8",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "UTF-8",
										"value": "UTF-8"
									},
									{
										"label": "GB2312",
										"value": "GB2312"
									},
									{
										"label": "GBK",
										"value": "GBK"
									},
									{
										"label": "UTF-16",
										"value": "UTF-16"
									},
									{
										"label": "UTF-16BE",
										"value": "UTF-16BE"
									},
									{
										"label": "UTF-16LE",
										"value": "UTF-16LE"
									},
									{
										"label": "UTF-32",
										"value": "UTF-32"
									},
									{
										"label": "UTF-32BE",
										"value": "UTF-32BE"
									},
									{
										"label": "UTF-32LE",
										"value": "UTF-32LE"
									}
								],
								"needPlaceholder": false,
								"multiple": false,
								"enumDyn": true,
								"url": "http://10.111.3.139:8080/vitria-oi/rest/app/sparksdk/user/vtbaadmin/sparkmodule/MQTT_CONNECTOR",
								"context": {
									"i18n": {
										"default": {
											"property.sample.label": "Sample Data",
											"property.cleanSession.label": "Clean Session",
											"property.cleanSession.desc": "Specify whether mqtt broker will remember state across reconnects of client.",
											"block.group.group": "Server URI",
											"property.topicLabel.label": "",
											"property.a.label": "a",
											"property.a.options.a": "a",
											"property.a.options.b": "b",
											"property.topicValue.label": "",
											"property.trustStorePassword.label": "Trust Store Password",
											"property.trustStorePassword.desc": "Password of TrustStore.",
											"property.keyStorePassword.label": "Key Store Password",
											"property.keyStorePassword.desc": "Password of Key Store.",
											"property.keyAlias.label": "Key Alias",
											"property.keyAlias.desc": "Specify which certification in Key Store will be used for SSL.",
											"property.filePath.label": "File Path",
											"property.protocol.label": "Protocol",
											"property.protocol.options.tcp": "TCP",
											"property.protocol.options.ssl": "SSL",
											"property.clientID.label": "Client ID",
											"property.clientID.desc": "Client ID.",
											"property.topics.label": " ",
											"property.topics.desc": "Identify the topics that mqttSource subscribe to.",
											"property.topics.title": " Topics",
											"property.topics.columns.topicValue.label": " ",
											"property.messageConverterControl.label": "Message Converter",
											"property.messageConverterControl.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
											"property.messageConverterControl.data.default": "Default",
											"property.messageConverterControl.data.custom": "Custom",
											"property.lwtMessage.label": "LWT Message",
											"property.lwtMessage.desc": "The content of LWT Message.",
											"property.trustStore.label": "Trust Store",
											"property.trustStore.desc": "Trust Store File.",
											"property.trustStore.title": " ",
											"property.trustStore.columns.type.label": " Type",
											"property.trustStore.columns.type.options.hdfs": "HDFS",
											"property.trustStore.columns.type.options.localFile": "Local File",
											"property.trustStore.columns.type.options.sparkFile": "Spark File",
											"property.trustStore.columns.filePath.label": "File Path",
											"property.type.label": "Type",
											"property.type.options.hdfs": "HDFS",
											"property.type.options.localFile": "Local File",
											"property.type.options.sparkFile": "Spark File",
											"property.keyStore.label": "Key Store",
											"property.keyStore.desc": "Key Store file.",
											"property.keyStore.title": " ",
											"property.keyStore.columns.type.label": "Type",
											"property.keyStore.columns.type.options.hdfs": "HDFS",
											"property.keyStore.columns.type.options.localFile": "Local File",
											"property.keyStore.columns.type.options.sparkFile": "Spark File",
											"property.keyStore.columns.filePath.label": "File Path",
											"property.encoding.label": "Encoding",
											"property.encoding.desc": "Encoding used the transform message playload to String.",
											"property.encoding.options.UTF-8": "UTF-8",
											"property.encoding.options.GB2312": "GB2312",
											"property.encoding.options.GBK": "GBK",
											"property.encoding.options.UTF-16": "UTF-16",
											"property.encoding.options.UTF-16BE": "UTF-16BE",
											"property.encoding.options.UTF-16LE": "UTF-16LE",
											"property.encoding.options.UTF-32": "UTF-32",
											"property.encoding.options.UTF-32BE": "UTF-32BE",
											"property.encoding.options.UTF-32LE": "UTF-32LE",
											"property.lwtMessageEncoding.label": "LWT Message Encoding",
											"property.lwtMessageEncoding.desc": "Encoding used the transform LWT message String to payload.",
											"property.lwtMessageEncoding.options.UTF-8": "UTF-8",
											"property.lwtMessageEncoding.options.GB2312": "GB2312",
											"property.lwtMessageEncoding.options.GBK": "GBK",
											"property.lwtMessageEncoding.options.UTF-16": "UTF-16",
											"property.lwtMessageEncoding.options.UTF-16BE": "UTF-16BE",
											"property.lwtMessageEncoding.options.UTF-16LE": "UTF-16LE",
											"property.lwtMessageEncoding.options.UTF-32": "UTF-32",
											"property.lwtMessageEncoding.options.UTF-32BE": "UTF-32BE",
											"property.lwtMessageEncoding.options.UTF-32LE": "UTF-32LE",
											"property.lwtMessageControl.label": "LWT Message Converter",
											"property.lwtMessageControl.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
											"property.lwtMessageControl.data.default": "Default",
											"property.lwtMessageControl.data.custom": "Custom",
											"property.lwtMessageControl.data.none": "None",
											"property.lwtTopic.label": "LWT Topic",
											"property.lwtTopic.desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
											"property.lwtMessageRetained.label": "LWT Message Retained",
											"property.lwtMessageRetained.desc": "Specified whether retained flag will be set for LWT Message.",
											"property.messageConverterScript.label": "Message Converter Script",
											"property.messageConverterScript.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
											"property.lwtMessageConverterScript.label": "LWT Message Converter Script",
											"property.lwtMessageConverterScript.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
											"property.host.label": "Host",
											"property.password.label": "Password",
											"property.password.desc": "The password to use for the connection.",
											"property.userName.label": "User Name",
											"property.userName.desc": "The user name to use for the connection.",
											"property.port.label": "Port",
											"property.serverURI.label": "Server URI",
											"property.serverURI.desc": "The mqtt server which this component will connect to.",
											"property.serverURI.title": " ",
											"property.serverURI.columns.protocol.label": "Protocol",
											"property.serverURI.columns.protocol.options.tcp": "TCP",
											"property.serverURI.columns.protocol.options.ssl": "SSL",
											"property.serverURI.columns.host.label": "Host",
											"property.serverURI.columns.port.label": "Port"
										}
									},
									"_pid": "d16711d9-352a-482b-8402-433f6e25203f"
								},
								"_cid": "70986fc3-d566-4b93-8982-304559e6a667",
								"name": "value"
							}
						}
					},
					{
						"editorType": "script",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "messageConverterScript",
						"label": "Message Converter Script",
						"desc": "Customized message converter, the message converter will convert a message from byte array to string.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "messageConverterControl",
						"controlValue": "custom",
						"value": "",
						"constraints": {
							"type": "script",
							"args": {
								"scriptMode": "scala",
								"scriptSection": "true",
								"helpContent": "spark/block/MQTTSource/help/messageconverter.json",
								"bodyTemplate": "spark/block/MQTTSource/help/messageconverter.js",
								"header": "false"
							}
						}
					},
					{
						"editorType": "boolean",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "cleanSession",
						"label": "Clean Session",
						"desc": "Specify whether mqtt broker will remember state across reconnects of client.",
						"type": "boolean",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"value": "true"
					},
					{
						"editorType": "radio",
						"*": {
							"label": "label",
							"desc": "desc",
							"data.default": "constraints.args.data.0.label",
							"data.custom": "constraints.args.data.1.label",
							"data.none": "constraints.args.data.2.label"
						},
						"group": "common",
						"name": "lwtMessageControl",
						"label": "LWT Message Converter",
						"desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "",
						"value": "none",
						"constraints": {
							"type": "input",
							"args": {
								"inputType": "radio",
								"data": [
									{
										"value": "default",
										"label": "Default"
									},
									{
										"value": "custom",
										"label": "Custom"
									},
									{
										"value": "none",
										"label": "None"
									}
								],
								"itemStyle": "width:300px;"
							}
						}
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "lwtTopic",
						"label": "LWT Topic",
						"desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "lwtMessageControl",
						"controlValue": "default,custom"
					},
					{
						"editorType": "textInput",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "lwtMessage",
						"label": "LWT Message",
						"desc": "The content of LWT Message.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "lwtMessageControl",
						"controlValue": "default"
					},
					{
						"editorType": "sparkSelect",
						"*": {
							"label": "label",
							"desc": "desc",
							"options.UTF-8": "constraints.args.options.0.label",
							"options.GB2312": "constraints.args.options.1.label",
							"options.GBK": "constraints.args.options.2.label",
							"options.UTF-16": "constraints.args.options.3.label",
							"options.UTF-16BE": "constraints.args.options.4.label",
							"options.UTF-16LE": "constraints.args.options.5.label",
							"options.UTF-32": "constraints.args.options.6.label",
							"options.UTF-32BE": "constraints.args.options.7.label",
							"options.UTF-32LE": "constraints.args.options.8.label"
						},
						"group": "common",
						"name": "lwtMessageEncoding",
						"label": "LWT Message Encoding",
						"desc": "Encoding used the transform LWT message String to payload.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": true,
						"controlName": "lwtMessageControl",
						"controlValue": "default",
						"value": "UTF-8",
						"constraints": {
							"type": "sparkSelect",
							"args": {
								"options": [
									{
										"label": "UTF-8",
										"value": "UTF-8"
									},
									{
										"label": "GB2312",
										"value": "GB2312"
									},
									{
										"label": "GBK",
										"value": "GBK"
									},
									{
										"label": "UTF-16",
										"value": "UTF-16"
									},
									{
										"label": "UTF-16BE",
										"value": "UTF-16BE"
									},
									{
										"label": "UTF-16LE",
										"value": "UTF-16LE"
									},
									{
										"label": "UTF-32",
										"value": "UTF-32"
									},
									{
										"label": "UTF-32BE",
										"value": "UTF-32BE"
									},
									{
										"label": "UTF-32LE",
										"value": "UTF-32LE"
									}
								],
								"needPlaceholder": false,
								"multiple": false,
								"enumDyn": true,
								"context": {
									"i18n": {
										"default": {
											"property.sample.label": "Sample Data",
											"property.cleanSession.label": "Clean Session",
											"property.cleanSession.desc": "Specify whether mqtt broker will remember state across reconnects of client.",
											"block.group.group": "Server URI",
											"property.topicLabel.label": "",
											"property.a.label": "a",
											"property.a.options.a": "a",
											"property.a.options.b": "b",
											"property.topicValue.label": "",
											"property.trustStorePassword.label": "Trust Store Password",
											"property.trustStorePassword.desc": "Password of TrustStore.",
											"property.keyStorePassword.label": "Key Store Password",
											"property.keyStorePassword.desc": "Password of Key Store.",
											"property.keyAlias.label": "Key Alias",
											"property.keyAlias.desc": "Specify which certification in Key Store will be used for SSL.",
											"property.filePath.label": "File Path",
											"property.protocol.label": "Protocol",
											"property.protocol.options.tcp": "TCP",
											"property.protocol.options.ssl": "SSL",
											"property.clientID.label": "Client ID",
											"property.clientID.desc": "Client ID.",
											"property.topics.label": " ",
											"property.topics.desc": "Identify the topics that mqttSource subscribe to.",
											"property.topics.title": " Topics",
											"property.topics.columns.topicValue.label": " ",
											"property.messageConverterControl.label": "Message Converter",
											"property.messageConverterControl.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
											"property.messageConverterControl.data.default": "Default",
											"property.messageConverterControl.data.custom": "Custom",
											"property.lwtMessage.label": "LWT Message",
											"property.lwtMessage.desc": "The content of LWT Message.",
											"property.trustStore.label": "Trust Store",
											"property.trustStore.desc": "Trust Store File.",
											"property.trustStore.title": " ",
											"property.trustStore.columns.type.label": " Type",
											"property.trustStore.columns.type.options.hdfs": "HDFS",
											"property.trustStore.columns.type.options.localFile": "Local File",
											"property.trustStore.columns.type.options.sparkFile": "Spark File",
											"property.trustStore.columns.filePath.label": "File Path",
											"property.type.label": "Type",
											"property.type.options.hdfs": "HDFS",
											"property.type.options.localFile": "Local File",
											"property.type.options.sparkFile": "Spark File",
											"property.keyStore.label": "Key Store",
											"property.keyStore.desc": "Key Store file.",
											"property.keyStore.title": " ",
											"property.keyStore.columns.type.label": "Type",
											"property.keyStore.columns.type.options.hdfs": "HDFS",
											"property.keyStore.columns.type.options.localFile": "Local File",
											"property.keyStore.columns.type.options.sparkFile": "Spark File",
											"property.keyStore.columns.filePath.label": "File Path",
											"property.encoding.label": "Encoding",
											"property.encoding.desc": "Encoding used the transform message playload to String.",
											"property.encoding.options.UTF-8": "UTF-8",
											"property.encoding.options.GB2312": "GB2312",
											"property.encoding.options.GBK": "GBK",
											"property.encoding.options.UTF-16": "UTF-16",
											"property.encoding.options.UTF-16BE": "UTF-16BE",
											"property.encoding.options.UTF-16LE": "UTF-16LE",
											"property.encoding.options.UTF-32": "UTF-32",
											"property.encoding.options.UTF-32BE": "UTF-32BE",
											"property.encoding.options.UTF-32LE": "UTF-32LE",
											"property.lwtMessageEncoding.label": "LWT Message Encoding",
											"property.lwtMessageEncoding.desc": "Encoding used the transform LWT message String to payload.",
											"property.lwtMessageEncoding.options.UTF-8": "UTF-8",
											"property.lwtMessageEncoding.options.GB2312": "GB2312",
											"property.lwtMessageEncoding.options.GBK": "GBK",
											"property.lwtMessageEncoding.options.UTF-16": "UTF-16",
											"property.lwtMessageEncoding.options.UTF-16BE": "UTF-16BE",
											"property.lwtMessageEncoding.options.UTF-16LE": "UTF-16LE",
											"property.lwtMessageEncoding.options.UTF-32": "UTF-32",
											"property.lwtMessageEncoding.options.UTF-32BE": "UTF-32BE",
											"property.lwtMessageEncoding.options.UTF-32LE": "UTF-32LE",
											"property.lwtMessageControl.label": "LWT Message Converter",
											"property.lwtMessageControl.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
											"property.lwtMessageControl.data.default": "Default",
											"property.lwtMessageControl.data.custom": "Custom",
											"property.lwtMessageControl.data.none": "None",
											"property.lwtTopic.label": "LWT Topic",
											"property.lwtTopic.desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
											"property.lwtMessageRetained.label": "LWT Message Retained",
											"property.lwtMessageRetained.desc": "Specified whether retained flag will be set for LWT Message.",
											"property.messageConverterScript.label": "Message Converter Script",
											"property.messageConverterScript.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
											"property.lwtMessageConverterScript.label": "LWT Message Converter Script",
											"property.lwtMessageConverterScript.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
											"property.host.label": "Host",
											"property.password.label": "Password",
											"property.password.desc": "The password to use for the connection.",
											"property.userName.label": "User Name",
											"property.userName.desc": "The user name to use for the connection.",
											"property.port.label": "Port",
											"property.serverURI.label": "Server URI",
											"property.serverURI.desc": "The mqtt server which this component will connect to.",
											"property.serverURI.title": " ",
											"property.serverURI.columns.protocol.label": "Protocol",
											"property.serverURI.columns.protocol.options.tcp": "TCP",
											"property.serverURI.columns.protocol.options.ssl": "SSL",
											"property.serverURI.columns.host.label": "Host",
											"property.serverURI.columns.port.label": "Port"
										}
									},
									"_pid": "d16711d9-352a-482b-8402-433f6e25203f"
								},
								"_cid": "c8e2ff80-e15f-4f9e-862f-6e3c7c60f7b3",
								"name": "value"
							}
						}
					},
					{
						"editorType": "script",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "lwtMessageConverterScript",
						"label": "LWT Message Converter Script",
						"desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
						"type": "string",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "lwtMessageControl",
						"controlValue": "custom",
						"value": "",
						"constraints": {
							"type": "script",
							"args": {
								"scriptMode": "scala",
								"scriptSection": "true",
								"helpContent": "spark/block/MQTTSource/help/lwtMessageconverter.json",
								"bodyTemplate": "spark/block/MQTTSource/help/lwtMessageconverter.js",
								"header": "false"
							}
						}
					},
					{
						"editorType": "boolean",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "lwtMessageRetained",
						"label": "LWT Message Retained",
						"desc": "Specified whether retained flag will be set for LWT Message.",
						"type": "boolean",
						"optional": true,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "false",
						"escapeValue": false,
						"controlName": "lwtMessageControl",
						"controlValue": "default,custom",
						"value": "false"
					},
					{
						"editorType": "sourceSample",
						"*": {
							"label": "label",
							"desc": "desc"
						},
						"name": "sample",
						"label": "Sample Data",
						"type": "string",
						"optional": false,
						"hidden": "false",
						"disabled": false,
						"impactSchema": "true",
						"escapeValue": false,
						"constraints": {
							"type": "sourceSample",
							"args": {
								"rows": "4",
								"itemStyle": "height: auto;width: calc(100% - 54px);"
							},
							"impactSchema": true
						},
						"excluded": true
					}
				],
				"dependent": true,
				"key": "ADF_MQTT",
				"group": "Source",
				"desc": "block.desc"
			},
			{
				"name": "Unknown",
				"helper": "spark/flow/helpers/Unknown",
				"widget": "spark/pipe/widgets/ScalaFunctionWidget",
				"displayName": "Unknown",
				"desc": "Unknown building block",
				"group": "Unknown",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_source_batch.png"
			}
		],
		"maps": {
			"Group": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_group_text.png",
					"group.backgroundColor": "95,111,161",
					"code": "false",
					"helper": "spark/flow/helpers/Group",
					"displayName": "Group",
					"name": "Group",
					"groupLabel": "Group",
					"group.labelColor": "68,68,68",
					"toCustom": "false",
					"dependent": false,
					"group": "Annotation",
					"desc": "Combine blocks together"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"FeedStreamTarget": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/FeedStreamTarget/FeedTarget.png",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "Feed",
					"acceptedSourceTypes": [
						"DStream"
					],
					"displayOrder": "50",
					"outputType": "*",
					"label": "Feed",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"name": "FeedStreamTarget",
					"model": [
						{
							"editorType": "feedPicker",
							"name": "feed",
							"*": {
								"label": "label"
							},
							"label": "Feed",
							"type": "object",
							"constraints": {
								"type": "feedPicker",
								"args": {
									"children": [
										"bind"
									]
								}
							},
							"optional": true
						},
						{
							"editorType": "feedSchemaMapping",
							"name": "mapping",
							"*": {
								"label": "label"
							},
							"label": "Mapping",
							"type": "string",
							"constraints": "feedSchemaMapping",
							"optional": true
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.xml": "constraints.args.options.0.label",
								"options.json": "constraints.args.options.1.label",
								"options.csv": "constraints.args.options.2.label"
							},
							"group": "common",
							"name": "format",
							"label": "Format",
							"desc": "The output event format",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "",
							"value": "xml",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "XML",
											"value": "xml"
										},
										{
											"label": "JSON",
											"value": "json"
										},
										{
											"label": "CSV",
											"value": "csv"
										}
									],
									"needPlaceholder": false,
									"multiple": false
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.comma": "constraints.args.options.0.label",
								"options.tab": "constraints.args.options.1.label",
								"options.user": "constraints.args.options.2.label"
							},
							"group": "common",
							"name": "delimiterType",
							"label": "Delimiter Type",
							"desc": "The CSV format delimiter type",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "format",
							"controlValue": "csv",
							"value": "comma",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Comma Separated",
											"value": "comma"
										},
										{
											"label": "Tab Separated",
											"value": "tab"
										},
										{
											"label": "User Specified",
											"value": "user"
										}
									],
									"needPlaceholder": false,
									"multiple": false
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "delimiter",
							"label": "Delimiter",
							"desc": "The user specified delimiter value",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "delimiterType",
							"controlValue": "user",
							"value": ""
						}
					],
					"dependent": false,
					"group": "Target",
					"desc": "Feed Target"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=FeedStreamTarget_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n//__CODING_HERE__:global\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n    //__CODING_HERE__:onInitialized\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n    //__CODING_HERE__:updateOnPasted\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n\r\n    var properties = model.properties;\r\n    if(properties.feed != null && properties.feed.untyped == false) {\r\n        status.push({name : \"mapping\", visible : true});\r\n    } else {\r\n        status.push({name : \"mapping\", visible : false});\r\n        if(properties.mapping) {\r\n            delete properties.mapping;\r\n        }\r\n    }\r\n    if(properties.feed != null && properties.feed.untyped == true) {\r\n        status.push({name : \"format\", visible : true});\r\n    } else {\r\n        status.push({name : \"format\", visible : false});\r\n    }\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n    //__CODING_HERE__:enrichProperty\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n    //__CODING_HERE__:propertyChanged\r\n\tif(event.name == \"feed\") {\r\n        if(event.preValue == null) {\r\n            return;\r\n        }\r\n\r\n\t\tif(event.preValue.name != event.currValue.name) {\r\n\t\t      message(\"warn\", i18n(\"warn.title\"), i18n(\"warn.selected.different.feed\"), null);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    //__CODING_HERE__:getOutputNames\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    //__CODING_HERE__:getOutputSchema\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    //__CODING_HERE__:getOutputDataType\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    if(model.properties.feed == null) {\r\n        logs.push({\r\n            context : context,\r\n            message : i18n(\"msg.property.feed.required\"),\r\n            realType : \"Error\",\r\n            type     : \"Error\"\r\n        });\r\n    }\r\n    var properties = model.properties\r\n    if(properties.feed != null && properties.feed.untyped == true) {\r\n        if (properties.format == \"csv\" && properties.delimiterType == \"user\" && (properties.delimiter == null || properties.delimiter.length == 0)) {\r\n            logs.push({\r\n                context : context,\r\n                message : i18n(\"msg.property.delimiter.required\"),\r\n                realType : \"Error\",\r\n                type     : \"Error\"\r\n            });\r\n        }\r\n\r\n        if(properties.format == \"csv\" && properties.feed.untyped == true) {\r\n            if(model && model.outputs && model.outputs[0]\r\n                && model.outputs[0].dataType != null && model.outputs[0].dataType.indexOf(\"class:\") == 0\r\n                && model.sources[0].sourceData && getClazzList(model.sources[0].sourceData.schema) != null) {\r\n                logs.push({\r\n                    context : context,\r\n                    message : i18n(\"validate.streamtarget.hierachicalcaseclass.cannot.into.non_json.resource\"),\r\n                    realType : \"Error\",\r\n                    type     : \"Error\"\r\n                });\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "FeedStreamTarget",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"KPI": {
				"funcDef": {
					"group.backgroundColor": "106,61,153",
					"image": "/vitria-oi/app/spark/html/images/functions/adf_kpiBlock.png",
					"widget": "spark/kpi/widgets/KPIFunctionWidget",
					"context.menu": "edit:spark.kpi:context.menu.edit",
					"displayName": "KPI",
					"displayOrder": "80",
					"helper": "spark/kpi/helpers/KPIFunctionHelper",
					"name": "KPI",
					"group.labelColor": "black",
					"style": "app/spark/html/themes/hybrid/default/css/function-kpi.css",
					"toCustom": "false",
					"dependent": true,
					"key": "ADF_KPI_Module",
					"group": "Transform",
					"desc": "KPI Function"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 10,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"_validationDerive": "Derive",
				"_validationFilter": "Filter",
				"_validationMeasure": "KPI",
				"_validationMeasureFilters": "KPI filter(s)",
				"_validationDimension": "Dimension(s)",
				"_validationAdditionalDimension": "Additional Dimension(s)",
				"_validationJudgment": "validation.judgment"
			},
			"subflow": {
				"funcDef": {
					"group.backgroundColor": "255,181,62",
					"image": "/vitria-oi/app/spark/html/images/functions/icon_subflow.png",
					"widget": "spark/property/subflow/SubflowWidget",
					"context.menu": "gotoSubflow:spark.editor:context.menu.gotoSubflow",
					"displayName": "Subflow",
					"displayOrder": "500",
					"groupLabel": "Subflow",
					"groupImage": "/vitria-oi/app/spark/html/images/functions/icon_subflow.png",
					"helper": "spark/property/subflow/SubflowHelper",
					"name": "subflow",
					"group.labelColor": "68,68,68",
					"toCustom": "false",
					"dependent": true,
					"group": "Subflow",
					"desc": "Link a separated subflow diagram",
					"inputMinCount": 1,
					"inputMaxCount": 100,
					"outputMinCount": 1,
					"outputMaxCount": 100,
					"acceptedSourceTypes": [
						"RDD",
						"DStream",
						"DataFrame"
					],
					"outputType": "*",
					"libraries": ""
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 100,
				"sourceMinCount": 1,
				"sourceMaxCount": 100,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"disableSourceAuthoring": true,
				"disableOutputAuthoring": true,
				"_proxy": {}
			},
			"Parse": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_parse.png",
					"group.backgroundColor": "106,61,153",
					"helper": "spark/flow/helpers/Parse",
					"displayName": "Parse",
					"name": "Parse",
					"displayOrder": "10",
					"groupLabel": "Processors",
					"group.labelColor": "68,68,68",
					"dependent": false,
					"group": "Transform",
					"desc": "Convert data into structured data"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 2,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"BatchTarget": {
				"funcDef": {
					"group.backgroundColor": "255,181,62",
					"image": "/vitria-oi/app/spark/html/images/functions/icon_batch_target.png",
					"helper": "spark/flow/helpers/BatchTarget",
					"displayName": "Batch",
					"name": "BatchTarget",
					"displayOrder": "10",
					"groupLabel": "Targets",
					"group.labelColor": "68,68,68",
					"dependent": false,
					"group": "Target",
					"desc": "Output data for a single batch processing"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"outputCount": 1
			},
			"GeoJoin": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_geo_join.png",
					"widget": "spark/geojoin/widgets/GeoJoinFunctionWidget",
					"helper": "spark/geojoin/helpers/GeoJoinFunctionHelper",
					"displayName": "Geo Join",
					"name": "GeoJoin",
					"displayOrder": "35",
					"style": "app/spark/html/themes/hybrid/default/css/function-geojoin.css",
					"dependent": false,
					"key": "ADF_GeoSpatial_Module",
					"group": "Transform",
					"desc": "Join multi data set containing geospatial information"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 2,
				"sourceMaxCount": 2,
				"dataTypeEditable": false,
				"_index": 0
			},
			"BatchSource": {
				"funcDef": {
					"group.backgroundColor": "20,138,196",
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_batch.png",
					"helper": "spark/flow/helpers/BatchSource",
					"displayName": "Batch",
					"name": "BatchSource",
					"displayOrder": "10",
					"groupLabel": "Sources",
					"group.labelColor": "68,68,68",
					"dependent": true,
					"group": "Source",
					"desc": "Input data source for a single batch processing"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0
			},
			"SparkML": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/SparkML/icon-22.png",
					"group.backgroundColor": "66,193,80",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "ML Pipeline",
					"acceptedSourceTypes": [
						"RDD",
						"DStream",
						"DataFrame"
					],
					"displayOrder": "20",
					"groupLabel": "Predictive",
					"outputType": "*",
					"label": "ML Pipeline",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "SparkML",
					"group.labelColor": "68,68,68",
					"model": [
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.training": "constraints.args.options.0.label",
								"options.evaluation": "constraints.args.options.1.label"
							},
							"name": "mode",
							"label": "Running Mode",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": false,
							"escapeValue": true,
							"value": "training",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Training",
											"value": "training"
										},
										{
											"label": "Evaluation",
											"value": "evaluation"
										}
									],
									"multiple": false,
									"refs": []
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "modelLocation",
							"label": "Model Location",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"constraints": {
								"args": {}
							}
						},
						{
							"editorType": "statement",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "stages",
							"label": "Pipeline Configuration",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": true,
							"controlName": "mode",
							"controlValue": "training",
							"constraints": {
								"type": "statement",
								"args": {
									"singleLine": "false",
									"path": "spark_block/SparkML/mldef.json"
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "duration",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "refreshInterval",
							"label": "Refresh Interval",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"value": {
								"number": 2,
								"unit": "DAYS"
							},
							"constraints": {
								"type": "range",
								"args": {
									"rangeType": "timeInterval",
									"interval": "relative",
									"valueType": "object",
									"showLabel": false,
									"hideHelp": true,
									"units": "SECONDS,MINUTES,HOURS,DAYS,WEEKS",
									"itemStyle": "width:200px;"
								}
							}
						},
						{
							"editorType": "projection",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "projection",
							"label": "Configure Field Projection",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"controlName": "mode",
							"controlValue": "training",
							"constraints": {
								"type": "projection",
								"args": {
									"nodeType": "all",
									"sourcePrefix": "false",
									"renameable": false,
									"draggable": false,
									"addible": false,
									"expandArray": false,
									"types": [
										"string",
										"boolean",
										"integer",
										"long",
										"double",
										"float",
										"date",
										"time",
										"org.apache.spark.ml.linalg.Vector",
										"datetime",
										"array"
									],
									"defaultProjection": true,
									"syncProjection": true,
									"refs": [
										{
											"name": "defaultProjection",
											"ref": ""
										}
									]
								}
							},
							"sourceSchemaSensitive": true,
							"generateSchema": false
						},
						{
							"editorType": "caseClass",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "case",
							"label": "Case Class",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"value": {
								"name": "",
								"ref": false
							},
							"constraints": "caseClass"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "projectioncopy",
							"label": "property.projectioncopy.label",
							"type": "object",
							"optional": true,
							"hidden": true,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						}
					],
					"dependent": false,
					"key": "ADF_Mllib",
					"group": "Predictive",
					"desc": "Machine learning pipeline training and evaluation"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=SparkML_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n\r\ncontroller.getClassifierParameter = function (stat) {\r\n    var onerestClassifier = {};\r\n    if (stat == null)\r\n        return onerestClassifier;\r\n    var statements = stat.statements;\r\n    if (statements == null)\r\n        return onerestClassifier;\r\n\t\r\n\tvar instanceOutput = {};\r\n    for (var i = 0; i < statements.length; i++) {\r\n        var statement = statements[i];\r\n        var ref = statement.ref;\r\n        if (ref == \"OneVsRest\") {\r\n            var bindings = statement.bindings;\r\n            for (var j = 0; j < bindings.length; j++) {\r\n                var binding = bindings[j];\r\n                if (binding.field == \"classifier\") {\r\n                    if (binding.value != null && binding.value != \"\") {\r\n\t\t\t\t\t\tvar v = binding.value;\r\n\t\t\t\t\t\tonerestClassifier[v] = v;\r\n\t\t\t\t\t}\r\n                    break;\r\n                }\r\n            }\r\n        } else if (ref == \"DecisionTreeClassifier\" || \r\n\t\t\t\t\tref == \"GBTClassifier\" || \r\n\t\t\t\t\tref == \"MultilayerPerceptronClassifier\" || \r\n\t\t\t\t\tref == \"NaiveBayes\" || \r\n\t\t\t\t\tref == \"RandomForestClassifier\" || \r\n\t\t\t\t\tref == \"LogisticRegression\") {\r\n            var bindings = statement.bindings;\r\n            for (var j = 0; j < bindings.length; j++) {\r\n                var binding = bindings[j];\r\n                if (binding.field == \"predictionCol\") {\r\n\t\t\t\t\tif (binding.value != null) {\r\n\t\t\t\t\t\tvar v = binding.value;\r\n\t\t\t\t\t\tif (statement.instanceName != null && statement.instanceName.value != null && statement.instanceName.value != \"\") {\r\n\t\t\t\t\t\t\tinstanceOutput[statement.instanceName.value] = v;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                    break;\r\n                }\r\n            }\t\t\t\r\n\t\t}\r\n    }\r\n    var output = {};\r\n\tfor (var key in onerestClassifier) {\r\n        if (instanceOutput[key] != null) {\r\n\t\t\toutput[instanceOutput[key]] = instanceOutput[key];\r\n\t\t}\r\n\t}\t\t\r\n    return output;\r\n};\r\n\r\ncontroller.getOutputColumn = function (stat) {\r\n    var output = {};\r\n    if (stat == null)\r\n        return output;\r\n    var statements = stat.statements;\r\n    if (statements == null)\r\n        return output;\r\n    for (var i = 0; i < statements.length; i++) {\r\n        var statement = statements[i];\r\n        var ref = statement.ref;\r\n        if (ref != \"SQLTransformer\") {\r\n            var bindings = statement.bindings;\r\n            for (var j = 0; j < bindings.length; j++) {\r\n                var binding = bindings[j];\r\n                if (binding.isOutput == true && binding.value != null) {\r\n                    var isArray = false;\r\n                    if (binding.isArray != null && (binding.isArray == \"true\" || binding.isArray == true)) {\r\n                        isArray = true;\r\n                    }\r\n                    var type = binding.colType;\r\n                    if (type == \"vector\") {\r\n                        type = \"org.apache.spark.ml.linalg.Vector\";\r\n                    }\r\n                    var field = {   name: binding.value,\r\n                                    type: type,\r\n                                    field: binding.field,\r\n                                    isArray: isArray,\r\n                                    exclude: false\r\n                    };\r\n                    output[binding.value] = field;\r\n\t\t\t\t}\r\n            }\r\n        } else if (ref == \"SQLTransformer\" && statement.TypeBuilder != null) {\r\n                var buidOutputType = statement.TypeBuilder.value;\r\n                if (buidOutputType != null) {\r\n                    for (var k = 0; k < buidOutputType.length; k++) {\r\n                        var binding = buidOutputType[k];\r\n                        if (binding.name != null && binding.type != null) {\r\n                            var isArray = false;\r\n                            if (binding.isArray != null && (binding.isArray == \"true\" || binding.isArray == true)) {\r\n                                isArray = true;\r\n                            }\r\n                            \r\n                            var type = binding.type;\r\n                            if (type == \"vector\") {\r\n                                type = \"org.apache.spark.ml.linalg.Vector\";\r\n                            }\r\n                            \r\n                            var field = {\r\n                                        name: binding.name,\r\n                                        type: type,\r\n                                        isArray: isArray,\r\n\t\t\t\t\t\t\t\t\t\t_isArray: isArray,\r\n\t\t\t\t\t\t\t\t\t\tisOptional: false,\r\n\t\t\t\t\t\t\t\t\t\t_isOptional: false,\r\n                                        exclude: false\r\n                            };\r\n                            output[binding.name] = field;\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n        }\r\n    }\r\n\t/*\r\n\tvar para = controller.getClassifierParameter(stat);\r\n\tvar trimedOutput = {};\r\n\tfor (var key in output) {\r\n\t\tif (para[key] == null) {\r\n\t\t\ttrimedOutput[key] = output[key];\r\n\t\t}\r\n\t}\r\n    return trimedOutput;\r\n\t*/\r\n\treturn output;\r\n};\r\n\r\n// by default, the item is not excluded.\r\n// only previous schema specifies it is excluded, it will be taken as excluded item.\r\ncontroller.getExcludeFlag = function (name, uiList) {\r\n    if (uiList.length == 0)\r\n        return false;\r\n    for (var i = 0; i < uiList.length; i++) {\r\n        if (uiList[i].name == name) {\r\n            if (uiList[i].exclude == true) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\ncontroller.exist = function(ui, name) {\r\n    if (ui == null)\r\n        return false;\r\n    for (var i = 0; i < ui.length; i++) {\r\n        var item = ui[i];\r\n        if (item.name == name) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n// only merge exclude item\r\ncontroller.mergeUIStatus = function(ui, copy) {\r\n    var uiclone = lang.clone(ui);\r\n    if (copy != null && copy.length > 0) {\r\n        for (var i = 0; i < copy.length; i++) {\r\n            var item = copy[i];\r\n            if (item.exclude != null && (item.exclude == true || item.exclude == \"true\")) {\r\n                if (!controller.exist(uiclone, item.name)) {\r\n                    ui.push(item);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return ui;\r\n};\r\n\r\ncontroller.updateSchemaProject = function(model, newOutput) {\r\n   \r\n    var items = [];\r\n    var uiStatus = [];\r\n        \r\n    var uiList =[];\r\n    if (model.properties.projection == null) {\r\n        model.properties.projection ={};\r\n        model.properties.projection.items =[];\r\n        model.properties.projection.uiStatus = [];\r\n    }\r\n    \r\n    if (model.properties.projection.uiStatus != null) {\r\n        uiList = model.properties.projection.uiStatus;\r\n        if (model.properties.projectioncopy != null && model.properties.projectioncopy.uiStatus != null) {\r\n            uiList = controller.mergeUIStatus(uiList, model.properties.projectioncopy.uiStatus);\r\n        }        \r\n    }\r\n\r\n    if (model.sources[0].sourceData != null) {\r\n        var sourceSchema = model.sources[0].sourceData.schema;\r\n        if (sourceSchema != null) {\r\n            for (var i = 0; i < sourceSchema.length; i++) {\r\n                var item = sourceSchema[i];\r\n                var exclude = controller.getExcludeFlag(item.name, uiList);\r\n                \r\n                uiStatus.push({ name: item.name, \r\n                                label: item.label, \r\n                                type: item.type,\r\n                                source: \"source.\" + item.name,\r\n                                level: 1, \r\n                                isOptional: item._isOptional, \r\n                                isArray: item._isArray, \r\n                                exclude: exclude});            \r\n                if (!exclude) {\r\n                    items.push({\r\n                            label: item.label,\r\n                            name: item.name,\r\n                            source: \"source.\" + item.name});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    var newOutput = controller.getOutputColumn(model.properties.stages);\r\n    for (var key in newOutput) {\r\n        var item = newOutput[key];\r\n        var exclude = controller.getExcludeFlag(item.name, uiList);\r\n        uiStatus.push({\r\n                    name: item.name,\r\n                    label: item.name, \r\n                    type: item.type, \r\n                    source: \"source.\" + item.name,\r\n                    level: 1,                    \r\n                    isOptional: false,\r\n                    isArray: item.isArray,                    \r\n                    exclude: exclude});\r\n        \r\n        if (!exclude) {\r\n            items.push({\r\n                        label: item.name,\r\n                        name: item.name,\r\n                        source: \"source.\" + item.name});\r\n        }\r\n    }    \r\n    model.properties.projection.uiStatus = uiStatus;\r\n    model.properties.projection.items = items;\r\n    var copy = {uiStatus: uiStatus,\r\n                items: items\r\n    };\r\n    model.properties.projectioncopy = lang.clone(copy);\r\n      \r\n};\r\n\r\ncontroller.isOutput = function(name, whitelist) {\r\n    if (whitelist.length == 0)\r\n        return true;\r\n    for (var i = 0; i < whitelist.length; i++) {\r\n        var item = whitelist[i];\r\n        if (item.name == name) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\ncontroller.validateSource = function(flowModel, model, logs, context) {\r\n};\r\n\r\ncontroller.validateStage = function(flowModel, model, logs, context) {\r\n    var stages = model.properties.stages;\r\n    if (stages == null) {/*\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.stages.required\"),\r\n            realType : \"Error\",\r\n            type     : \"Error\"\r\n        });            */\r\n    } else {\r\n        var statements = stages.statements;\r\n        if (statements == null || statements.length == 0) {\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.stages.required\"),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n            });                                                                                                                                                   \r\n        } else {\r\n            for (var i = 0; i < statements.length; i++) {\r\n\t\t\t\tvar found = false;\r\n                if (statements[i]._validationLog != null && statements[i]._validationLog.length > 0) {\r\n\t\t\t\t\tfor (var j = 0; j < statements[i]._validationLog.length; j++) {\r\n\t\t\t\t\t\tvar vlog = statements[i]._validationLog[j];\r\n\t\t\t\t\t\t// migration issue:\r\n\t\t\t\t\t\t// if the message is string, the message type is error\r\n\t\t\t\t\t\t// if the message is object, the message structure {type:...  , message: ...}            \t\r\n\t\t\t\t\t\tif (typeof vlog === 'string' || vlog.type == \"Error\") {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (found) {\r\n                    logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.stages.error\"),\r\n                        realType : \"Error\",\r\n                        type     : i18n(\"validate.error.flag\")\r\n                    });                                                                                                                                                                           \r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\ncontroller.validateOutputSchem = function (flowModel, model, logs, context) {\r\n    if (model.outputs == null || \r\n        model.outputs.length == 0 || \r\n        model.outputs[0] == null || \r\n        model.outputs[0].length == 0 ||\r\n        model.outputs[0].schema == null ||\r\n        model.outputs[0].schema.length == 0) {\r\n\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.output.schema.required\"),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        }); \r\n    }\r\n};\r\n\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n    //debugger;\r\n    return model.properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n        //debugger;\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    //debugger;\r\n\tvar visible = false;\r\n\tif (model.properties.mode == \"evaluation\") {\r\n\t\tvisible = true;\r\n\t\tif (model.sources != null && model.sources.length > 0 &&  model.sources[0].sourceData != null && model.sources[0].sourceData.outputType == \"RDD\") {\r\n\t\t\tvisible = false;\r\n\t\t}\r\n\t}\r\n\tstatus.push({name: \"refreshInterval\", visible: visible});\t\t\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n        //debugger;\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n    //debugger;\r\n    var impacts = [];\r\n    if (event.name == \"stages\") {\r\n        var newColumn = controller.getOutputColumn(event.newValue);\r\n        controller.updateSchemaProject(model, newColumn);    \r\n        impacts.push( {\"name\": \"projection\",\r\n                           \"value\": model.properties.projection});        \r\n    }\r\n    return     impacts;\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.updateOnSourceSchemaChanged = function(flowModel, model) {\r\n    var newColumn = controller.getOutputColumn(model.properties[\"stages\"]);\r\n    var oldValue = lang.clone(model.properties[\"projection\"]);\r\n    controller.updateSchemaProject(model, newColumn);\r\n    var newValue = lang.clone(model.properties[\"projection\"]);\r\n    return [{key: \"projection\", preValue: oldValue, currValue: newValue, value: newValue}];\r\n};\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    //debugger;\r\n    if(outputName != \"out\") {\r\n        return [{name: \"label\", label: \"Label\", type: \"string\"},\r\n                {name: \"index\", label: \"Index\", type: \"integer\"}];\r\n    }\r\n    if (model.properties.mode == \"evaluation\" && (model.properties.stages == null || model.properties.stages.statements == null || model.properties.stages.statements.length == 0)) {\r\n        return schema;\r\n    }\r\n    // regenerate schema again. it keeps exclude flag.\r\n    var newOutput = controller.getOutputColumn(model.properties.stages);\r\n    controller.updateSchemaProject(model, newOutput);\r\n        \r\n    var whitelist =[];\r\n    if (model.properties.projection != null && model.properties.projection.items != null) {\r\n        whitelist = model.properties.projection.items;\r\n    }\r\n\r\n    if (model.sources[0].sourceData != null && model.sources[0].sourceData.schema != null) {\r\n        var sourceSchema = model.sources[0].sourceData.schema;\r\n        for (var i = 0; i < sourceSchema.length; i++) {\r\n            var item = sourceSchema[i];\r\n            if (controller.isOutput(item.name, whitelist)) {\r\n\t\t\t\tvar isOptional = item.isOptional;\r\n\t\t\t\tif (isOptional == null) {\r\n\t\t\t\t\tisOptional = item._isOptional;\r\n\t\t\t\t}\r\n\t\t\t\tvar isArray = item.isArray;\r\n\t\t\t\tif (isArray == null) {\r\n\t\t\t\t\tisArray = item._isArray;\r\n\t\t\t\t}\r\n                schema.push({name: item.name, label: item.label, type: item.type, _isOptional: isOptional, _isArray: isArray, exclude: item.exclude});\r\n            }\r\n        }\r\n    }\r\n    \r\n//    var newOutput = controller.getOutputColumn(model.properties.stages);\r\n    for (var key in newOutput) {\r\n        if (controller.isOutput(newOutput[key].name, whitelist)) {\r\n            schema.push(newOutput[key]);\r\n        }\r\n    }\r\n\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    dataType = \"(Long,String,Double)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n\r\n//__CODING_START__:evaluateModelProperty\r\ncontroller.evaluateModelProperty = function(controller, flowModel, item, callback) {\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    //debugger;\r\n    controller.validateSource(flowModel, model, logs, context);    \r\n    \r\n    if (model.properties.mode == \"training\") {\r\n        controller.validateStage(flowModel, model, logs, context);\r\n    } else {\r\n        controller.validateOutputSchem(flowModel, model, logs, context);\r\n    }\r\n        \r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "SparkML",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"Notification": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/Notification/notification-block.png",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "Notification",
					"acceptedSourceTypes": [
						"DStream"
					],
					"displayOrder": "20",
					"groupLabel": "Alerts & Notifications",
					"outputType": "*",
					"label": "Notification",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"code.generateNotification": "code.generateNotification.js",
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "Notification",
					"model": [
						{
							"editorType": "textInput",
							"*": {
								"label": "label"
							},
							"name": "topicName",
							"label": "Topic Name",
							"type": "string",
							"disabled": false,
							"escapeValue": true,
							"value": "NotificationTopic"
						},
						{
							"editorType": "richText",
							"*": {
								"label": "label",
								"title": "constraints.args.title"
							},
							"name": "subject",
							"label": "Subject",
							"type": "string",
							"disabled": false,
							"escapeValue": false,
							"constraints": {
								"type": "richText",
								"args": {
									"sourceVariables": true,
									"globalProperties": true,
									"buildInVariables": "_user_,_timestamp_",
									"plainText": true,
									"title": "Subject"
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "richText",
							"*": {
								"label": "label",
								"title": "constraints.args.title"
							},
							"name": "shortMessage",
							"label": "Short Message",
							"type": "string",
							"disabled": false,
							"escapeValue": false,
							"constraints": {
								"type": "richText",
								"args": {
									"sourceVariables": true,
									"globalProperties": true,
									"buildInVariables": "_user_,_timestamp_",
									"plainText": true,
									"title": "Short Message"
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "richText",
							"*": {
								"label": "label",
								"title": "constraints.args.title"
							},
							"name": "longMessage",
							"label": "Long Message",
							"type": "string",
							"disabled": false,
							"escapeValue": false,
							"constraints": {
								"type": "richText",
								"args": {
									"sourceVariables": true,
									"globalProperties": true,
									"buildInVariables": "_user_,_timestamp_",
									"title": "Long Message"
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "fieldSelect",
							"*": {
								"label": "label"
							},
							"name": "alertId",
							"label": "Alert ID",
							"type": "string",
							"optional": "true",
							"disabled": false,
							"escapeValue": true,
							"constraints": {
								"type": "fieldSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"expandArray": false,
									"types": [
										"string",
										"boolean",
										"integer",
										"long",
										"double",
										"float",
										"date",
										"time",
										"datetime",
										"array"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "tableResource",
							"*": {
								"label": "label"
							},
							"name": "alertResource",
							"label": "Alert Table Resource",
							"hideLabel": false,
							"type": "object",
							"optional": "true",
							"constraints": {
								"type": "tableResource",
								"args": {}
							}
						}
					],
					"toCustom": "false",
					"dependent": false,
					"key": "ADF_Notification",
					"group": "AlertsNotifications",
					"desc": "Notification",
					"code.generateModel": "code.generateModel.js"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=Notification_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n    var desc = model.desc;\r\n    if ((desc != null) && (desc != \"\")) {\r\n        var topicName = desc.replace(/[ ]/g, \"_\");\r\n        model.properties.topicName = topicName;\r\n    }\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n    var desc = model.desc;\r\n    if ((desc != null) && (desc != \"\")) {\r\n        var topicName = desc.replace(/[ ]/g, \"_\");\r\n        model.properties.topicName = topicName;\r\n    }\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    if (model.sources[0].sourceData != null)\r\n        schema = model.sources[0].sourceData.schema;\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    if (model.sources[0].sourceData != null)\r\n        dataType = model.sources[0].sourceData.dataType;\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    if (model.func != \"Notification\")\n        return;\n    var curTopic = model.properties.topicName;\n    if ((curTopic == null) || (curTopic == \"\"))\n        return;\n    \n    //debugger;\n    \n    var curId = model._nodeId;\n    var nodes = flowModel.nodes;\n    if (nodes) {\n        for (var i = 0 ; i < nodes.length; i++) {\n            var type = nodes[i].type;\n            if (type != \"Notification\")\n                continue;\n            if (curId === nodes[i].id)\n                continue;\n            var topic = nodes[i].model.properties.topicName;\n            if (topic === curTopic) {\r\n                logs.push({\n                    context : context,\n                    message  : i18n(\"validate.notification.topic.duplicate\", [curTopic]),\n                    realType : \"Error\",\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\n                });\n            }\n        }\n    }\r\n};\r\n\r\n/** \r\n * Support bind global properties \r\n * \r\n **/\r\ncontroller.getPropertySetting = function(flowModel, model) {\r\n    return [\"subject\", \"shortMessage\"];\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "Notification",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"ThrottleQuery": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/ThrottleQuery/icon-22.png",
					"inputMaxCount": 0,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "Throttle Query",
					"acceptedSourceTypes": [],
					"displayOrder": "1000",
					"outputType": "DStream",
					"label": "Throttle Query",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"useHive": "true",
					"inputMinCount": 0,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "ThrottleQuery",
					"model": [
						{
							"editorType": "typeScript",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "sql",
							"label": "SQL Statement",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": false,
							"escapeValue": false,
							"resolveProperty": false,
							"value": "",
							"constraints": {
								"type": "typeScript",
								"args": {
									"scriptMode": "sql",
									"scriptSection": "false",
									"header": "false"
								}
							}
						},
						{
							"editorType": "caseClass",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "case",
							"label": "Case Class",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"resolveProperty": false,
							"value": {
								"name": "",
								"ref": "true",
								"userTyped": false
							},
							"constraints": "caseClass",
							"excluded": true
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "dtFieldName",
							"label": "Growing Field",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"resolveProperty": false,
							"enumSource": ""
						},
						{
							"editorType": "timeRange",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "fromTo",
							"label": "Date Range",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"resolveProperty": false,
							"value": {
								"timezone": "Asia/Shanghai",
								"daylight": "false"
							},
							"constraints": {
								"type": "timeRange",
								"args": {}
							}
						},
						{
							"editorType": "duration",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "timeStep",
							"label": "Step",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"resolveProperty": false,
							"controlName": "",
							"value": {
								"number": "1",
								"unit": "DAYS"
							},
							"constraints": {
								"type": "range",
								"args": {
									"rangeType": "timeInterval",
									"interval": "relative",
									"valueType": "object",
									"showLabel": false,
									"hideHelp": true,
									"units": "MINUTES,HOURS,DAYS",
									"itemStyle": "width:200px;"
								}
							}
						},
						{
							"editorType": "number",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "stepOffset",
							"label": "Start Offset",
							"type": "integer",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"resolveProperty": false,
							"value": 0,
							"constraints": {
								"min": "-999999",
								"max": "0",
								"step": "1",
								"places": "",
								"maxLength": ""
							}
						},
						{
							"editorType": "boolean",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "stop",
							"label": "Stop App ",
							"type": "boolean",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"resolveProperty": false,
							"value": "true"
						}
					],
					"dependent": false,
					"group": "Source",
					"desc": ""
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=ThrottleQuery_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n\t//model.properties.case.name =\" \";\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model, propertyDef) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n    \r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event, flow, defModel) {\r\n\t if(event.name == \"sql\"){\r\n        var tmpPropertyDef = null;\r\n        for(var i =0; i < defModel.length; i++){\r\n            if(defModel[i].name == \"case\"){\r\n                tmpPropertyDef = parseJSON(JSON.stringify(defModel[i]));\r\n                tmpPropertyDef.value = model.properties[\"case\"];\r\n                break;\r\n            }\r\n        }\r\n        if(tmpPropertyDef !== null){\r\n            updateProperty(tmpPropertyDef);   \r\n        }\r\n    }\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    \n    \n    \r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getPropertySetting\r\n/**\r\n *  Return the property names array. The property in this array can be bind to global property.\r\n */\r\ncontroller.getPropertySetting = function(flowModel, model){\r\n    var propertyNames = [];\r\n    propertyNames = [\"fromTo\",\"timeStep\",\"stepOffset\",\"stop\"]\r\n    return propertyNames;\r\n}\r\n//__CODING_END__\r\n\r\n//__CODING_START__:validate\r\n/**\r\n * Validate properties of the building block, and collect warning or error into logs\r\n * @param flowModel flow model definition,\r\n * @param model model definition of building block (contains \"sources\", \"outputs\", \"properties\")\r\n * @param logs validation logs\r\n * @param context {category: \"\", nodeId: \"\"}\r\n * Append validation entry into logs with keys (context, message, type and realType)\r\n *     logs.push({\r\n *          context : context,\r\n *          message  : \"\",\r\n *          realType : \"Error\",\r\n *          type     : \"Error\"\r\n *      });\r\n **/\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    if(model.properties.case.ref===\"false\" || model.properties.case.name===\" \"||model.properties.case.name===\"\"){\r\n        logs.push({\r\n            context: context,\r\n            message: \"The \\\"Case Class\\\" must refer to an existing case class.\",\r\n            realType:\"Error\",\r\n            type: \"Error\"\r\n        });\r\n    }\r\n    \r\n    var start = new Date(model.properties.fromTo.start);\r\n    var end =  new Date(model.properties.fromTo.end);\r\n    if(start.getTime() >= end.getTime()){\r\n    \tlogs.push({\r\n            context: context,\r\n            message: \"The start date of \\\"Date Range\\\" should early than the end date.\",\r\n            realType:\"Error\",\r\n            type: \"Error\"\r\n        });\r\n    }     \r\n};\r\n//__CODING_END__\r\n\r\nreturn controller;\r\n",
					"_funcName": "ThrottleQuery",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"TextAnnotations": {
				"funcDef": {
					"group.backgroundColor": "95,111,161",
					"image": "/vitria-oi/app/spark/html/images/functions/icon_annotation_text.png",
					"code": "false",
					"helper": "spark/flow/helpers/TextAnnotations",
					"displayName": "Text Annotation",
					"name": "TextAnnotations",
					"groupLabel": "Annotation",
					"group.labelColor": "68,68,68",
					"toCustom": "false",
					"dependent": false,
					"group": "Annotation",
					"desc": "Adding text description to the data flow"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"Adhoc": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_ad_hoc.png",
					"helper": "spark/flow/helpers/Adhoc",
					"displayName": "Custom",
					"name": "Adhoc",
					"displayOrder": "500",
					"toCustom": "false",
					"dependent": false,
					"group": "Transform",
					"desc": "Custom data processing logic using Scala code"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 100,
				"sourceMinCount": 0,
				"sourceMaxCount": 100,
				"dataTypeEditable": true,
				"_index": 0
			},
			"kafkaSource": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_kafka_source.png",
					"widget": "spark/kafka/widgets/KafkaSourceFunctionWidget",
					"helper": "spark/kafka/helpers/KafkaSourceFunctionHelper",
					"displayName": "Kafka",
					"name": "kafkaSource",
					"displayOrder": "60",
					"style": "app/spark/html/themes/hybrid/default/css/function-kafka.css",
					"toCustom": "false",
					"dependent": true,
					"key": "ADF_Kafka_Module",
					"group": "Source",
					"desc": "Load data from kafka source"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"preDefineConfs": [
					{
						"name": "auto.commit.interval.ms",
						"label": "auto.commit.interval.ms",
						"defaultValue": "5000"
					},
					{
						"name": "check.crcs",
						"label": "check.crcs",
						"defaultValue": "true"
					},
					{
						"name": "client.id",
						"label": "client.id",
						"defaultValue": ""
					},
					{
						"name": "connections.max.idle.ms",
						"label": "connections.max.idle.ms",
						"defaultValue": "540000"
					},
					{
						"name": "exclude.internal.topics",
						"label": "exclude.internal.topics",
						"defaultValue": "true"
					},
					{
						"name": "fetch.max.wait.ms",
						"label": "fetch.max.wait.ms",
						"defaultValue": "500"
					},
					{
						"name": "fetch.min.bytes",
						"label": "fetch.min.bytes",
						"defaultValue": "1"
					},
					{
						"name": "group.id",
						"label": "group.id",
						"defaultValue": ""
					},
					{
						"name": "heartbeat.interval.ms",
						"label": "heartbeat.interval.ms",
						"defaultValue": "3000"
					},
					{
						"name": "interceptor.classes",
						"label": "interceptor.classes",
						"defaultValue": ""
					},
					{
						"name": "max.partition.fetch.bytes",
						"label": "max.partition.fetch.bytes",
						"defaultValue": "1048576"
					},
					{
						"name": "max.poll.records",
						"label": "max.poll.records",
						"defaultValue": "2147483647"
					},
					{
						"name": "metadata.max.age.ms",
						"label": "metadata.max.age.ms",
						"defaultValue": "300000"
					},
					{
						"name": "metrics.num.samples",
						"label": "metrics.num.samples",
						"defaultValue": "2"
					},
					{
						"name": "metrics.sample.window.ms",
						"label": "metrics.sample.window.ms",
						"defaultValue": "30000"
					},
					{
						"name": "receive.buffer.bytes",
						"label": "receive.buffer.bytes",
						"defaultValue": "65536"
					},
					{
						"name": "reconnect.backoff.ms",
						"label": "reconnect.backoff.ms",
						"defaultValue": "50"
					},
					{
						"name": "request.timeout.ms",
						"label": "request.timeout.ms",
						"defaultValue": "40000"
					},
					{
						"name": "retry.backoff.ms",
						"label": "retry.backoff.ms",
						"defaultValue": "100"
					},
					{
						"name": "sasl.mechanism",
						"label": "sasl.mechanism",
						"defaultValue": "GSSAPI"
					},
					{
						"name": "sasl.kerberos.kinit.cmd",
						"label": "sasl.kerberos.kinit.cmd",
						"defaultValue": "/usr/bin/kinit"
					},
					{
						"name": "sasl.kerberos.min.time.before.relogin",
						"label": "sasl.kerberos.min.time.before.relogin",
						"defaultValue": "60000"
					},
					{
						"name": "sasl.kerberos.ticket.renew.jitter",
						"label": "sasl.kerberos.ticket.renew.jitter",
						"defaultValue": "0.05"
					},
					{
						"name": "sasl.kerberos.ticket.renew.window.factor",
						"label": "sasl.kerberos.ticket.renew.window.factor",
						"defaultValue": "0.8"
					},
					{
						"name": "sasl.kerberos.service.name",
						"label": "sasl.kerberos.service.name",
						"defaultValue": ""
					},
					{
						"name": "security.protocol",
						"label": "security.protocol",
						"defaultValue": "PLAINTEXT"
					},
					{
						"name": "send.buffer.bytes",
						"label": "send.buffer.bytes",
						"defaultValue": "131072"
					},
					{
						"name": "session.timeout.ms",
						"label": "session.timeout.ms",
						"defaultValue": "30000"
					},
					{
						"name": "ssl.endpoint.identification.algorithm",
						"label": "ssl.endpoint.identification.algorithm",
						"defaultValue": ""
					},
					{
						"name": "ssl.key.password",
						"label": "ssl.key.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.keymanager.algorithm",
						"label": "ssl.keymanager.algorithm",
						"defaultValue": "SunX509"
					},
					{
						"name": "ssl.keystore.location",
						"label": "ssl.keystore.location",
						"defaultValue": ""
					},
					{
						"name": "ssl.keystore.password",
						"label": "ssl.keystore.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.keystore.type",
						"label": "ssl.keystore.type",
						"defaultValue": "JKS"
					},
					{
						"name": "ssl.protocol",
						"label": "ssl.protocol",
						"defaultValue": "TLS"
					},
					{
						"name": "ssl.provider",
						"label": "ssl.provider",
						"defaultValue": ""
					},
					{
						"name": "ssl.trustmanager.algorithm",
						"label": "ssl.trustmanager.algorithm",
						"defaultValue": "PKIX"
					},
					{
						"name": "ssl.truststore.location",
						"label": "ssl.truststore.location",
						"defaultValue": ""
					},
					{
						"name": "ssl.truststore.password",
						"label": "ssl.truststore.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.truststore.type",
						"label": "ssl.truststore.type",
						"defaultValue": "JKS"
					}
				]
			},
			"Python": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/Python/text-x-python.png",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "Python",
					"acceptedSourceTypes": [
						"RDD",
						"DStream",
						"DataFrame"
					],
					"displayOrder": "30",
					"libraries": [
						"org.zeroturnaround:zt-zip:1.12"
					],
					"outputType": "*",
					"label": "Python Block",
					"groupImage": "",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "Python",
					"model": [
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "pythonCommand",
							"label": "Python command line",
							"desc": "Python command line used to launch Python, %% will be replaced with Python script path.",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": "python %%"
						},
						{
							"editorType": "radio",
							"*": {
								"label": "label",
								"desc": "desc",
								"data.file": "constraints.args.data.0.label",
								"data.script": "constraints.args.data.1.label"
							},
							"group": "common",
							"name": "pythonScriptSelect",
							"label": "Select Python Script",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": "file",
							"constraints": {
								"type": "input",
								"args": {
									"inputType": "radio",
									"data": [
										{
											"value": "file",
											"label": "Specify Python File"
										},
										{
											"value": "script",
											"label": "Input Python Script"
										}
									],
									"itemStyle": "width:300px;"
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "pythonFile",
							"label": "Python File Name",
							"desc": "A local file for python script",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "pythonScriptSelect",
							"controlValue": "file",
							"value": ""
						},
						{
							"editorType": "script",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "pythonScript",
							"label": "Python Script",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "pythonScriptSelect",
							"controlValue": "script",
							"constraints": {
								"type": "script",
								"args": {
									"scriptMode": "python",
									"bodyTemplate": "spark/block/Python/script/pTemplate.py",
									"header": "false"
								}
							}
						},
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "libraries",
							"label": "     ",
							"desc": "Configure Python libraries",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": [],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": true,
									"title": "Configure Python libraries",
									"columns": [
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "url",
											"label": "Url",
											"desc": "File/Folder url",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "enable"
										}
									],
									"heightAdaption": true
								}
							}
						},
						{
							"editorType": "caseClass",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "case",
							"label": "Case Class",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"value": {
								"name": "",
								"ref": false,
								"userTyped": false
							},
							"constraints": {
								"type": "caseClass",
								"args": {
									"editOnly": true
								}
							},
							"excluded": true
						},
						{
							"editorType": "outputSchema",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "schema",
							"label": "Output Schema",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"generateSchema": true,
							"sourceSchemaSensitive": true,
							"escapeValue": false,
							"constraints": {
								"type": "outputSchema",
								"args": {
									"constraints": "outputSchema",
									"extendedTypes": [
										{
											"value": "org.apache.spark.ml.linalg.Vector",
											"label": "org.apache.spark.ml.linalg.Vector"
										}
									]
								}
							}
						},
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "properties",
							"label": "Properties",
							"desc": "Configure properties controlling Python process",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": [],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": true,
									"title": "Configure properties",
									"columns": [
										{
											"name": "name",
											"label": "Key",
											"editorType": "sparkSelect",
											"$$extra": "",
											"*": {
												"label": "label",
												"desc": "desc",
												"options.value1": "constraints.args.options.0.label"
											},
											"type": "string",
											"disabled": "false",
											"defaultValue": "python.timeout",
											"constraints": {
												"type": "sparkSelect",
												"args": {
													"needPlaceholder": false,
													"enumDyn": true,
													"options": [
														{
															"label": "python.timeout",
															"value": "python.timeout"
														}
													],
													"refs": []
												}
											}
										},
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "value",
											"label": "Value",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "enable"
										}
									],
									"heightAdaption": true
								}
							}
						},
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "environments",
							"label": "Environment Variables",
							"desc": "Configure environment variables passed to Python process",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": [],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": true,
									"title": "Configure environment variables",
									"columns": [
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "name",
											"label": "Name",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "enable"
										},
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "value",
											"label": "Value",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "enable"
										}
									],
									"heightAdaption": true
								}
							}
						}
					],
					"dependent": true,
					"group": "Predictive",
					"desc": ""
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=Python_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model, propertyDef) {\r\n    var status = [];\r\n    if(model.sources && model.sources.length > 0 && model.sources[0].sourceData && model.sources[0].sourceData.outputType == \"DataFrame\"){\r\n        status.push({name:\"case\", visible:false});\r\n    }\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n    if(event.name == \"pythonScript\"){\r\n        //replace tab with 4 spaces\r\n        var preVal = event.newValue;\r\n        var newVal = preVal.replace(/\\t/g, \"    \");\r\n        event.currValue = newVal;\r\n        event.newValue = newVal;\r\n        event.value = newVal;\r\n        model.properties.pythonScript = newVal;\r\n        propertyDef.value = newVal;\r\n    }\r\n    \r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:validate\r\n/**\r\n * Validate properties of the building block, and collect warning or error into logs\r\n * @param flowModel flow model definition,\r\n * @param model model definition of building block (contains \"sources\", \"outputs\", \"properties\")\r\n * @param logs validation logs\r\n * @param context {category: \"\", nodeId: \"\"}\r\n * Append validation entry into logs with keys (context, message, type and realType)\r\n *     logs.push({\r\n *          context : context,\r\n *          message  : \"\",\r\n *          realType : \"Error\",\r\n *          type     : \"Error\"\r\n *      });\r\n **/\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    var properties = model.properties;\n    /*\n    if(!properties.pythonFile && !properties.pythonScript) {\n        logs.push({\n            context : context,\n            message  : \"Please fill one of Python File URL or Python Script at least\",\n            realType : \"Error\",\n            type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\n        });\n    }\n    */\n    if(model.sources && model.sources.length == 1 && model.sources[0].sourceData && model.sources[0].sourceData.schema) {\n        var sourceSchema = model.sources[0].sourceData.schema; // no clazz\n        var subType = \"\";\n        for(var i=0; i < sourceSchema.length; i++) {\n            var field = sourceSchema[i];\n            if(field.clazz) {\n                subType = field.clazz;\n                break;\n            }\n        } \n        if(subType) {\n            logs.push({\n                context : context,\n                message  : \"Source schema contains hiararchy structure (\"+subType+\"), python only accept flatten structure\",\n                realType : \"Error\",\n                type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\n            });\n        }\n    }\r\n    \r\n    var props = properties.properties;\r\n    array.forEach(props, function(p){\r\n        if(p.name){\r\n            if(!p.value){\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.property.value.empty\", [p.name]),\r\n                    realType : \"Error\",\r\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n                });                \r\n            } else{\r\n                \r\n                if(p.name == \"python.timeout\" && !(/^\\+?[1-9]\\d*$/.test(p.value))){\r\n                    logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.property.timeout.wrong\"),\r\n                        realType : \"Error\",\r\n                        type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n                    });                     \r\n                }\r\n                \r\n            }\r\n        }\r\n        \r\n        \r\n    });\r\n    \r\n};\r\n//__CODING_END__\r\n\r\nreturn controller;\r\n",
					"_funcName": "Python",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"Window": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon__named_window.png",
					"helper": "spark/flow/helpers/Window",
					"displayName": "Window",
					"name": "Window",
					"displayOrder": "70",
					"dependent": false,
					"group": "Transform",
					"supportFrameFanIn": "false",
					"desc": "A streaming building block that create and update a relation"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 4,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"Evaluation": {
				"funcDef": {
					"group.backgroundColor": "66,193,80",
					"image": "/vitria-oi/app/spark/block/Evaluation/icon-22.png",
					"inputMaxCount": 1,
					"outputMaxCount": 22,
					"ui.controller": "controller.js",
					"displayName": "Evaluation",
					"acceptedSourceTypes": [
						"RDD"
					],
					"displayOrder": "1000",
					"outputType": "RDD",
					"label": "Evaluation",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "Evaluation",
					"group.labelColor": "68,68,68",
					"model": [
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.BinaryClassificationMetrics": "constraints.args.options.0.label",
								"options.MulticlassMetrics": "constraints.args.options.1.label",
								"options.MultilabelMetrics": "constraints.args.options.2.label",
								"options.RankingMetrics": "constraints.args.options.3.label",
								"options.RegressionMetrics": "constraints.args.options.4.label"
							},
							"group": "common",
							"name": "metrics",
							"label": "Metrics",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"value": "BinaryClassificationMetrics",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Binary Classification Metrics",
											"value": "BinaryClassificationMetrics"
										},
										{
											"label": "Multiclass Metrics",
											"value": "MulticlassMetrics"
										},
										{
											"label": "Multilabel Metrics",
											"value": "MultilabelMetrics"
										},
										{
											"label": "Ranking Metrics",
											"value": "RankingMetrics"
										},
										{
											"label": "Regression Metrics",
											"value": "RegressionMetrics"
										}
									],
									"needPlaceholder": true,
									"multiple": false
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.precision": "constraints.args.options.0.label",
								"options.recall": "constraints.args.options.1.label",
								"options.fmeasure": "constraints.args.options.2.label",
								"options.ROC": "constraints.args.options.3.label",
								"options.auROC": "constraints.args.options.4.label",
								"options.auPRC": "constraints.args.options.5.label"
							},
							"group": "common",
							"name": "bcOutputs",
							"label": "Outputs",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "BinaryClassificationMetrics",
							"value": "precision,recall,fmeasure,ROC,auROC,auPRC",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Precision",
											"value": "precision"
										},
										{
											"label": "Recall",
											"value": "recall"
										},
										{
											"label": "F-Measure",
											"value": "fmeasure"
										},
										{
											"label": "ROC",
											"value": "ROC"
										},
										{
											"label": "Area Under ROC",
											"value": "auROC"
										},
										{
											"label": "Area Under PR",
											"value": "auPRC"
										}
									],
									"needPlaceholder": true,
									"multiple": true
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.accuracy": "constraints.args.options.0.label",
								"options.precision": "constraints.args.options.1.label",
								"options.recall": "constraints.args.options.2.label",
								"options.fmeasure": "constraints.args.options.3.label",
								"options.fpr": "constraints.args.options.4.label",
								"options.tpr": "constraints.args.options.5.label",
								"options.wprecision": "constraints.args.options.6.label",
								"options.wrecall": "constraints.args.options.7.label",
								"options.wfmeasure": "constraints.args.options.8.label",
								"options.wfpr": "constraints.args.options.9.label",
								"options.wtpr": "constraints.args.options.10.label",
								"options.confusionMatrix": "constraints.args.options.11.label"
							},
							"group": "common",
							"name": "mcOutputs",
							"label": "Outputs",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "MulticlassMetrics",
							"value": "accuracy,precision,recall,fmeasure,fpr,tpr,wprecision,wrecall,wfmeasure,wfpr,wtpr,confusionMatrix",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Accuracy",
											"value": "accuracy"
										},
										{
											"label": "Precision",
											"value": "precision"
										},
										{
											"label": "Recall",
											"value": "recall"
										},
										{
											"label": "F-Measure",
											"value": "fmeasure"
										},
										{
											"label": "False Positive Rate",
											"value": "fpr"
										},
										{
											"label": "True Positive Rate",
											"value": "tpr"
										},
										{
											"label": "Weighted Precision",
											"value": "wprecision"
										},
										{
											"label": "Weighted Recall",
											"value": "wrecall"
										},
										{
											"label": "Weighted F-Measure",
											"value": "wfmeasure"
										},
										{
											"label": "Weighted False Positive Rate",
											"value": "wfpr"
										},
										{
											"label": "Weighted True Positive Rate",
											"value": "wtpr"
										},
										{
											"label": "Confusion Matrix",
											"value": "confusionMatrix"
										}
									],
									"needPlaceholder": true,
									"multiple": true
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.mse": "constraints.args.options.0.label",
								"options.rmse": "constraints.args.options.1.label",
								"options.mae": "constraints.args.options.2.label",
								"options.r2": "constraints.args.options.3.label",
								"options.ev": "constraints.args.options.4.label"
							},
							"group": "common",
							"name": "rOutputs",
							"label": "Outputs",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "RegressionMetrics",
							"value": "mse,rmse,mae,r2,ev",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Mean Squared Error",
											"value": "mse"
										},
										{
											"label": "Root Mean Squared Error",
											"value": "rmse"
										},
										{
											"label": "Mean Absolute Error",
											"value": "mae"
										},
										{
											"label": "Coefficient of Determination",
											"value": "r2"
										},
										{
											"label": "Explained Variance",
											"value": "ev"
										}
									],
									"needPlaceholder": true,
									"multiple": true
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.precision": "constraints.args.options.0.label",
								"options.recall": "constraints.args.options.1.label",
								"options.accuracy": "constraints.args.options.2.label",
								"options.precisionByLabel": "constraints.args.options.3.label",
								"options.recallByLabel": "constraints.args.options.4.label",
								"options.f1MeasureByLabel": "constraints.args.options.5.label",
								"options.hammingLoss": "constraints.args.options.6.label",
								"options.subsetAccuracy": "constraints.args.options.7.label",
								"options.f1Measure": "constraints.args.options.8.label",
								"options.microPrecision": "constraints.args.options.9.label",
								"options.microRecall": "constraints.args.options.10.label",
								"options.microF1Measure": "constraints.args.options.11.label"
							},
							"group": "common",
							"name": "mlOutputs",
							"label": "Outputs",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "MultilabelMetrics",
							"value": "precision,recall,accuracy,precisionByLabel,recallByLabel,f1MeasureByLabel,hammingLoss,subsetAccuracy,f1Measure,microPrecision,microRecall,microF1Measure",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Precision",
											"value": "precision"
										},
										{
											"label": "Recall",
											"value": "recall"
										},
										{
											"label": "Accuracy",
											"value": "accuracy"
										},
										{
											"label": "Precision By Label",
											"value": "precisionByLabel"
										},
										{
											"label": "Recall By Label",
											"value": "recallByLabel"
										},
										{
											"label": "F1-Measure By Label",
											"value": "f1MeasureByLabel"
										},
										{
											"label": "Hamming Loss",
											"value": "hammingLoss"
										},
										{
											"label": "Subset Accuracy",
											"value": "subsetAccuracy"
										},
										{
											"label": "F1 Measure",
											"value": "f1Measure"
										},
										{
											"label": "Micro Precision",
											"value": "microPrecision"
										},
										{
											"label": "Micro Recall",
											"value": "microRecall"
										},
										{
											"label": "Micro F1 Measure",
											"value": "microF1Measure"
										}
									],
									"needPlaceholder": true,
									"multiple": true
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.precision": "constraints.args.options.0.label",
								"options.meanAveragePrecision": "constraints.args.options.1.label",
								"options.ndcg": "constraints.args.options.2.label"
							},
							"group": "common",
							"name": "rkOutputs",
							"label": "Outputs",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "RankingMetrics",
							"value": "precision,meanAveragePrecision,ndcg",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Precision",
											"value": "precision"
										},
										{
											"label": "Mean Average Precision",
											"value": "meanAveragePrecision"
										},
										{
											"label": "Normalized Discounted Cumulative Gain",
											"value": "ndcg"
										}
									],
									"needPlaceholder": true,
									"multiple": true
								}
							}
						},
						{
							"editorType": "fieldSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "prediction",
							"label": "Prediction",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "BinaryClassificationMetrics,MulticlassMetrics,RegressionMetrics",
							"constraints": {
								"type": "fieldSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"double"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "fieldSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "label",
							"label": "Label",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "BinaryClassificationMetrics,MulticlassMetrics,RegressionMetrics",
							"constraints": {
								"type": "fieldSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"double"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "fieldSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "labelLiteral",
							"label": "Label Literal",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "MulticlassMetrics",
							"constraints": {
								"type": "fieldSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"string"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "fieldMultiSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "mlPrediction",
							"label": "Prediction",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "MultilabelMetrics,RankingMetrics",
							"constraints": {
								"type": "fieldMultiSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"double"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "fieldMultiSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "mlLabel",
							"label": "Label",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "MultilabelMetrics,RankingMetrics",
							"constraints": {
								"type": "fieldMultiSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"double"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "fMeasureBeta",
							"label": "The beta factor in F-Measure computation",
							"type": "double",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "BinaryClassificationMetrics,MulticlassMetrics",
							"value": 1
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "rank",
							"label": "Rank",
							"type": "string",
							"optional": false,
							"hidden": true,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "metrics",
							"controlValue": "RankingMetrics",
							"value": "1, 3, 5"
						}
					],
					"dependent": false,
					"group": "Predictive",
					"desc": ""
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 22,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=Evaluation_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model, propertyDef) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    names = [\"precision\",\"recall\",\"fmeasure\",\"ROC\",\"auROC\",\"auPRC\"];\n    if (model.properties.metrics == \"BinaryClassificationMetrics\") {\n        names = model.properties.bcOutputs.split(\",\");\n    }\n    if (model.properties.metrics == \"MulticlassMetrics\") {\n        names = model.properties.mcOutputs.split(\",\");\n    }\n    if (model.properties.metrics == \"RegressionMetrics\") {\n        names = model.properties.rOutputs.split(\",\");\n    }\n    if (model.properties.metrics == \"MultilabelMetrics\") {\n        names = model.properties.mlOutputs.split(\",\");\n    }\n    if (model.properties.metrics == \"RankingMetrics\") {\n        names = model.properties.rkOutputs.split(\",\");\n    }\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n\n    if (model.properties.metrics == \"BinaryClassificationMetrics\") {\n        if (outputName == \"precision\") {\n            schema = [{name:\"threshold\", type:\"double\", isOptional:false, isArray:false}, {name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"recall\") {\n            schema = [{name:\"threshold\", type:\"double\", isOptional:false, isArray:false}, {name:\"recall\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"fmeasure\") {\n            schema = [{name:\"threshold\", type:\"double\", isOptional:false, isArray:false}, {name:\"fMeasure\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"ROC\") {\n            schema = [{name:\"falsePositiveRate\", type:\"double\", isOptional:false, isArray:false}, {name:\"truePositiveRate\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"auROC\") {\n            schema = [{name:\"auROC\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"auPRC\") {\n            schema = [{name:\"auPRC\", type:\"double\", isOptional:false, isArray:false}];\n        }\n    } else if (model.properties.metrics == \"MulticlassMetrics\") {\n        var outputDouble = false;\n        if (typeof(model.properties.labelLiteral) == \"undefined\" || model.properties.labelLiteral == \"\") {\n            outputDouble = true;\n        }\n        if (outputName == \"accuracy\") {\n            schema = [{name:\"accuracy\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"precision\") {\n            if (outputDouble) {\n                schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"label\", type:\"string\", isOptional:false, isArray:false}, {name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n            }\n        }\n        if (outputName == \"recall\") {\n            if (outputDouble) {\n                schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"recall\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"label\", type:\"string\", isOptional:false, isArray:false}, {name:\"recall\", type:\"double\", isOptional:false, isArray:false}];\n            }\n        }\n        if (outputName == \"fmeasure\") {\n            if (outputDouble) {\n                schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"fmeasure\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"label\", type:\"string\", isOptional:false, isArray:false}, {name:\"fmeasure\", type:\"double\", isOptional:false, isArray:false}];\n            }\n        }\n        if (outputName == \"fpr\") {\n            if (outputDouble) {\n                schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"fpr\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"label\", type:\"string\", isOptional:false, isArray:false}, {name:\"fpr\", type:\"double\", isOptional:false, isArray:false}];\n            }\n        }\n        if (outputName == \"tpr\") {\n            if (outputDouble) {\n                schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"tpr\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"label\", type:\"string\", isOptional:false, isArray:false}, {name:\"tpr\", type:\"double\", isOptional:false, isArray:false}];\n            }\n        }\n        if (outputName == \"wprecision\") {\n            schema = [{name:\"weightedPrecision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"wrecall\") {\n            schema = [{name:\"weightedRecall\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"wfmeasure\") {\n            schema = [{name:\"weightedFmeasure\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"wfpr\") {\n            schema = [{name:\"weightedFPR\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"wtpr\") {\n            schema = [{name:\"weightedTPR\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"confusionMatrix\") {\n            if (outputDouble) {\n                schema = [{name:\"actual\", type:\"double\", isOptional:false, isArray:false}, {name:\"predicted\", type:\"double\", isOptional:false, isArray:false}, {name:\"value\", type:\"double\", isOptional:false, isArray:false}];\n            } else {\n                schema = [{name:\"actual\", type:\"string\", isOptional:false, isArray:false}, {name:\"predicted\", type:\"string\", isOptional:false, isArray:false}, {name:\"value\", type:\"double\", isOptional:false, isArray:false}];\n            }\n            // schema = [{name:\"confusionMatrix\", type:\"org.apache.spark.ml.linalg.Matrix\", isOptional:false, isArray:false}];\n        }\n    } else if (model.properties.metrics == \"RegressionMetrics\") {\n        if (outputName == \"mse\") {\n            schema = [{name:\"meanSquaredError\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"rmse\") {\n            schema = [{name:\"rootMeanSquaredError\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"mae\") {\n            schema = [{name:\"meanAbsoluteError\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"r2\") {\n            schema = [{name:\"coefficientofDetermination\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"ev\") {\n            schema = [{name:\"explainedVariance\", type:\"double\", isOptional:false, isArray:false}];\n        }\n    } else if (model.properties.metrics == \"MultilabelMetrics\") {\n        if (outputName == \"precision\") {\n            schema = [{name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"recall\") {\n            schema = [{name:\"recall\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"accuracy\") {\n            schema = [{name:\"accuracy\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"precisionByLabel\") {\n            schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"recallByLabel\") {\n            schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"recall\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"f1MeasureByLabel\") {\n            schema = [{name:\"label\", type:\"double\", isOptional:false, isArray:false}, {name:\"f1Measure\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"hammingLoss\") {\n            schema = [{name:\"hammingLoss\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"subsetAccuracy\") {\n            schema = [{name:\"subsetAccuracy\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"f1Measure\") {\n            schema = [{name:\"f1Measure\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"microPrecision\") {\n            schema = [{name:\"microPrecision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"microRecall\") {\n            schema = [{name:\"microRecall\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"microF1Measure\") {\n            schema = [{name:\"microF1Measure\", type:\"double\", isOptional:false, isArray:false}];\n        }\n    } else if (model.properties.metrics == \"RankingMetrics\") {\n        if (outputName == \"precision\") {\n            schema = [{name:\"rank\", type:\"Int\", isOptional:false, isArray:false}, {name:\"precision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"meanAveragePrecision\") {\n            schema = [{name:\"meanAveragePrecision\", type:\"double\", isOptional:false, isArray:false}];\n        }\n        if (outputName == \"ndcg\") {\n            schema = [{name:\"rank\", type:\"Int\", isOptional:false, isArray:false}, {name:\"ndcg\", type:\"double\", isOptional:false, isArray:false}];\n        }\n    }\n\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    \n    if (model.properties.metrics == \"BinaryClassificationMetrics\") {\n        if (outputName == \"precision\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"recall\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"fmeasure\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"ROC\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"auROC\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"auPRC\") {\n            dataType = \"Double\";\n        }\n    } else if (model.properties.metrics == \"MulticlassMetrics\") {\n        var outputDouble = false;\n        if (typeof(model.properties.labelLiteral) == \"undefined\" || model.properties.labelLiteral == \"\") {\n            outputDouble = true;\n        }\n        if (outputName == \"accuracy\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"precision\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double)\";\n            } else {\n                dataType = \"(String, Double)\";\n            }\n        }\n        if (outputName == \"recall\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double)\";\n            } else {\n                dataType = \"(String, Double)\";\n            }\n        }\n        if (outputName == \"fmeasure\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double)\";\n            } else {\n                dataType = \"(String, Double)\";\n            }\n        }\n        if (outputName == \"fpr\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double)\";\n            } else {\n                dataType = \"(String, Double)\";\n            }\n        }\n        if (outputName == \"tpr\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double)\";\n            } else {\n                dataType = \"(String, Double)\";\n            }\n        }\n        if (outputName == \"wprecision\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"wrecall\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"wfmeasure\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"wfpr\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"wtpr\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"confusionMatrix\") {\n            if (outputDouble) {\n                dataType = \"(Double, Double, Double)\";\n            } else {\n                dataType = \"(String, String, Double)\";\n            }\n            // dataType = \"org.apache.spark.ml.linalg.Matrix\";\n        }\n    } else if (model.properties.metrics == \"RegressionMetrics\") {\n        if (outputName == \"mse\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"rmse\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"mae\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"r2\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"ev\") {\n            dataType = \"Double\";\n        }\n    } else if (model.properties.metrics == \"MultilabelMetrics\") {\n        if (outputName == \"precision\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"recall\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"accuracy\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"precisionByLabel\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"recallByLabel\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"f1MeasureByLabel\") {\n            dataType = \"(Double, Double)\";\n        }\n        if (outputName == \"hammingLoss\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"subsetAccuracy\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"f1Measure\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"microPrecision\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"microRecall\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"microF1Measure\") {\n            dataType = \"Double\";\n        }\n    } else if (model.properties.metrics == \"RankingMetrics\") {\n        if (outputName == \"precision\") {\n            dataType = \"(Int, Double)\";\n        }\n        if (outputName == \"meanAveragePrecision\") {\n            dataType = \"Double\";\n        }\n        if (outputName == \"ndcg\") {\n            dataType = \"(Int, Double)\";\n        }\n    }\n    \r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:validate\r\n/**\r\n * Validate properties of the building block, and collect warning or error into logs\r\n * @param flowModel flow model definition,\r\n * @param model model definition of building block (contains \"sources\", \"outputs\", \"properties\")\r\n * @param logs validation logs\r\n * @param context {category: \"\", nodeId: \"\"}\r\n * Append validation entry into logs with keys (context, message, type and realType)\r\n *     logs.push({\r\n *          context : context,\r\n *          message  : \"\",\r\n *          realType : \"Error\",\r\n *          type     : \"Error\"\r\n *      });\r\n **/\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n};\r\n//__CODING_END__\r\n\r\nreturn controller;\r\n",
					"_funcName": "Evaluation",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"inPort": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/inPort/icon_inport.png",
					"inputMaxCount": 0,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"code": false,
					"displayName": "Input Port",
					"acceptedSourceTypes": [
						"RDD",
						"DStream",
						"DataFrame"
					],
					"displayOrder": "0",
					"outputType": "*",
					"label": "Input Port",
					"outputMinCount": 1,
					"isBuilt": true,
					"hidePortLabel": true,
					"inputMinCount": 0,
					"code.template": "code.stg",
					"name": "inPort",
					"fixedSize": true,
					"model": [
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "portType",
							"label": "Port Type",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"generateSchema": true,
							"impactSchema": true,
							"escapeValue": true,
							"value": "*",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Inherited from client",
											"value": "*"
										},
										{
											"label": "RDD",
											"value": "RDD"
										},
										{
											"label": "DStream",
											"value": "DStream"
										},
										{
											"label": "DataFrame",
											"value": "DataFrame"
										}
									],
									"multiple": false
								}
							}
						},
						{
							"editorType": "typePicker",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "type",
							"label": "Type",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"constraints": {
								"type": "typePicker",
								"args": {
									"kind": "all"
								}
							},
							"generateSchema": true
						}
					],
					"toCustom": false,
					"dependent": false,
					"group": "Subflow",
					"desc": "Define input port properties"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=inPort_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n    if(model.outputs == null) {\r\n        model.outputs = [{name: \"Out\", uid: 0}];\r\n    }\r\n\tmodel.outputs[0].outputType = \"*\";\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = [];\r\n    if(model.properties.type == null && model.outputs && model.outputs[0] && model.outputs[0].schema && model.outputs[0].schema.length > 0)\r\n        schema = model.outputs[0].schema;\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    if(model.properties.type == null && model.outputs && model.outputs[0] && model.outputs[0].dataType){\r\n        dataType = model.outputs[0] && model.outputs[0].dataType;\r\n    }\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, category) {\r\n    if(model.properties.portType != \"*\") {\r\n        var acceptedSourceTypeArray = flowModel.acceptedSourceTypes.split(\",\");\r\n        if(array.indexOf(acceptedSourceTypeArray, model.properties.portType) == -1)\r\n            logs.push({\r\n                context : category,\r\n                message  : i18n(\"validation.property.portType.not.subset.source.type\"),\r\n                realType : \"Error\",\r\n                type     : \"Error\"\r\n            });\r\n    }\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "inPort",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"StreamSource": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_stream.png",
					"helper": "spark/flow/helpers/StreamSource",
					"displayName": "Streaming",
					"name": "StreamSource",
					"displayOrder": "20",
					"groupLabel": "Sources",
					"dependent": true,
					"group": "Source",
					"desc": "Input data source used for continuous stream processing"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 2,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"willGenerateCompleteTypes": true
			},
			"JDBCBatch": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_JDBC.png",
					"helper": "spark/flow/helpers/JDBCBatch",
					"displayName": "JDBC Batch",
					"name": "JDBCBatch",
					"displayOrder": "40",
					"groupLabel": "Sources",
					"dependent": true,
					"group": "Source",
					"desc": "JDBCBatch"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"willGenerateCompleteTypes": true
			},
			"SourceTable": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_table.png",
					"helper": "spark/flow/helpers/SourceTable",
					"displayName": "Source Table",
					"name": "SourceTable",
					"displayOrder": "30",
					"groupLabel": "Sources",
					"dependent": false,
					"group": "Source",
					"desc": "Input data source for SQL processing"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"isDynamicSchema": true
			},
			"Join": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_join.png",
					"helper": "spark/flow/helpers/Join",
					"displayName": "Join",
					"name": "Join",
					"displayOrder": "30",
					"dependent": false,
					"group": "Transform",
					"desc": "Combine data from multiple sources based on join conditions"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 2,
				"sourceMaxCount": 10,
				"dataTypeEditable": false,
				"_index": 0
			},
			"JDBCStream": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_JDBC_stream.png",
					"helper": "spark/flow/helpers/JDBCStream",
					"displayName": "JDBC Streaming",
					"name": "JDBCStream",
					"displayOrder": "50",
					"groupLabel": "Sources",
					"dependent": true,
					"group": "Source",
					"desc": "Input data source from JDBC resource"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"willGenerateCompleteTypes": true
			},
			"PrepareBlock": {
				"funcDef": {
					"group.backgroundColor": "66,193,80",
					"image": "/vitria-oi/app/spark/block/PrepareBlock/icon-22.png",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "ML Parse",
					"acceptedSourceTypes": [
						"RDD",
						"DStream"
					],
					"displayOrder": "1",
					"outputType": "*",
					"label": "ML Parse",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "PrepareBlock",
					"group.labelColor": "68,68,68",
					"model": [
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.libsvm": "constraints.args.options.0.label",
								"options.csv": "constraints.args.options.1.label"
							},
							"name": "format",
							"label": "Format",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"value": "libsvm",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "LIBSVM",
											"value": "libsvm"
										},
										{
											"label": "CSV",
											"value": "csv"
										}
									],
									"multiple": false
								}
							}
						},
						{
							"editorType": "boolean",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "hasHeader",
							"label": "Get field name from the header of CSV",
							"type": "boolean",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": true,
							"value": "true"
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.csv": "constraints.args.options.0.label",
								"options.tsv": "constraints.args.options.1.label",
								"options.other": "constraints.args.options.2.label"
							},
							"name": "delimiterType",
							"label": "Delimiter Type",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"value": "csv",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Comma Separated Values",
											"value": "csv"
										},
										{
											"label": "Tab Separated Values",
											"value": "tsv"
										},
										{
											"label": "User Specified",
											"value": "other"
										}
									],
									"multiple": false,
									"context": {
										"_pid": "3012b34c-fff1-40d6-8819-0e2ad5efe95a"
									},
									"_cid": "38b54e3d-b367-4b67-8cea-192e36534ce4",
									"name": "value"
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "delimiter",
							"label": "Delimiter",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": true,
							"constraints": {
								"args": {}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "labelCol",
							"label": "Output Column Name of Label",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": true,
							"value": "label"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "featureCol",
							"label": "Output Column Name of Feature",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": true,
							"value": "feature"
						},
						{
							"editorType": "number",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "featureNumber",
							"label": "Number of Features",
							"type": "long",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"value": -1,
							"constraints": {
								"min": "-1",
								"max": "999999",
								"step": "1"
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "fieldIndexes",
							"label": "Indices for Feature (eg,0,1,5-10)",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": false,
							"value": "",
							"constraints": {
								"args": {}
							}
						},
						{
							"editorType": "select",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "mergeFunction",
							"label": "Function to merge multiple columns into a feature column",
							"type": "string",
							"optional": false,
							"hidden": "true",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"value": "org.apache.spark.ml.linalg.Vectors.dense"
						},
						{
							"editorType": "caseClass",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "case",
							"label": "Case Class",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"value": {
								"name": "",
								"ref": false
							},
							"constraints": "caseClass"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "header",
							"label": "Header Fields",
							"type": "string",
							"optional": "true",
							"hidden": "true",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						},
						{
							"editorType": "schemaEditor",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "schema",
							"label": "Schema",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"constraints": {
								"type": "parseSchema",
								"args": {
									"constraints": "parseSchema",
									"extendedTypes": [
										{
											"value": "org.apache.spark.ml.linalg.Vector",
											"label": "Vector"
										}
									],
									"addable": false,
									"delete": false,
									"option": true,
									"exclude": true
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "schemaChangeByUI",
							"label": "schemachangebyui",
							"type": "string",
							"optional": true,
							"hidden": true,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						}
					],
					"dependent": false,
					"key": "ADF_Mllib",
					"group": "Predictive",
					"desc": "Machine learning parse data"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=PrepareBlock_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n\ncontroller.isFeatureColumn= function (idx, ranges) {\n    for (var i = 0; i < ranges.length; i++) {\n        if (idx >= ranges[i].min && idx <= ranges[i].max) {\n            return true;\n        }\n    }\n    return false;\n};\n\ncontroller.getRanges= function (index) {\n    var ranges = [];\r\n    if (index == null)\r\n        return ranges;\n    var sections = index.split(\",\");\n    for (var i = 0; i < sections.length; i++) {\n        var sect = sections[i];\n        var boundary = sect.split(\"-\");\n        if (boundary.length == 1) {\n            var a = boundary[0].trim();\n            var min = parseInt(a);\r\n            if (!isNaN(min)) {\n                ranges.push({\"min\": min, \"max\": min});\r\n            }\n        } else if (boundary.length == 2) {\n            var a2 = boundary[0].trim();\n            var b2 = boundary[1].trim();\n            var min2 = parseInt(a2);\n            var max2 = parseInt(b2);\n            if (!isNaN(min2) && !isNaN(max2) && max2 >= min2) {\n                ranges.push({\"min\": min2, \"max\": max2});\n            }\n        }\n    }\n    return ranges;\n};\n\r\ncontroller._isGloablProperty = function(val) {\r\n\tvar exp = \"^\\\\$\\\\{.+\\\\}$\";\r\n\tvar reg = new RegExp(exp);\r\n\tvar ret = false;\r\n\tif (reg.test(val)) {\r\n\t\tret = true;\r\n\t}\r\n\treturn ret;\r\n};\r\n\ncontroller.getSchemaItem= function (name, def) {\n    if (def == null)\n        return null;\n    for (var i = 0; i < def.length; i++) {\n        var item = def[i];\n        if (item.initName == name) {\n            return item;\n        }\n    }\n    return null;\n};\n\r\ncontroller.guessDataType = function(value) {\r\n    if (value != null && (\"true\" == value || \"false\" == value)) {\r\n        return \"boolean\";\r\n    }\r\n    if (value != null) {\r\n        var v = parseInt(value);\r\n        if (!isNaN(v)) {\r\n            if (value.indexOf(\".\") != -1) {\r\n                return \"double\";\r\n            } else {\r\n                return \"integer\";\r\n            }\r\n        }\r\n    }\r\n    return \"string\";\r\n}\r\n\ncontroller.regenerateSchemaDef= function(flow, model, schemaEditorModel) {\n    var def = [];\r\n    \r\n\tvar result = controller.getUpStreamSample(flow, model._nodeId);\r\n\tif (result == null)\r\n\t\treturn;\r\n\t\r\n\tvar line = result[0].data;\r\n    var sampleData = \"\";  \n    if (model.properties.hasHeader == true || model.properties.hasHeader == \"true\") {\n        model.properties.header = line;\r\n        sampleData = result[1].data;\n    } else {\n        model.properties.header = \"\";\r\n        sampleData = result[0].data;\n    }\n    \n    var seperator = model.properties.delimiter;    \n    if (model.properties.delimiterType == \"csv\") {\n        seperator = \",\";\n    } else if (model.properties.delimiterType == \"tsv\") {\n        seperator = \"\\t\";\n    }\n        \n    var fields = line.split(seperator);\r\n    var filedValues = sampleData.split(seperator);\r\n    \n    var ranges = controller.getRanges(model.properties.fieldIndexes);\n    var validFeatureDefine = false;\n    for (var i = 0; i < fields.length; i++) {\n\n        var field = \"\";\n        if (model.properties.hasHeader == true || model.properties.hasHeader == \"true\") {\n            field = fields[i].trim();\n        } else {\n            field = \"field\" + i;\n        }\r\n        var item = null;\n        if (model.properties.schemaChangeByUI == true) {\n            item = controller.getSchemaItem(field, schemaEditorModel);\r\n        }\n        if (item == null) {\n            // create new item\r\n            var dataType = controller.guessDataType(filedValues[i]);            \n            var isFeature = controller.isFeatureColumn(i, ranges); \n            var exclude = false;\n            if (isFeature == true) {\n                exclude = true;\n            }\n            var newItem = {    name: field, \n                            initName: field,\n                            label: field,\n                            type: dataType, \n                            _isOptional: false, \r\n                            isOptional: false, \n                            _isArray: false, \r\n                            isArray: false, \n                            _excluded: exclude, \r\n                            excluded: exclude, \n                            _isDimension: false, \r\n                            isDimension: false,                                     \r\n                            isMeasure: false,\n                            _isMeasure: false};\n            def.push(newItem);\n        } else {\n            // use user definition\n            def.push(item);\n        }\n    }\n    \n    // judge the feature is in the def\n    var feature = controller.getSchemaItem(model.properties.featureCol, schemaEditorModel);\n    if (feature == null) {\n        var featureItem = {\n                            name: model.properties.featureCol,\n                            initName: model.properties.featureCol,\n                            label: model.properties.featureCol,\n                            type: \"org.apache.spark.ml.linalg.Vector\", \n                            _isOptional: false, \r\n                            isOptional: false, \n                            _isArray: false, \r\n                            isArray: false, \n                            _excluded: false, \r\n                            excluded: false, \n                            _isDimension: false, \r\n                            isDimension: false, \r\n                            isMeasure: false,\n                            _isMeasure: false};                    \n        def.push(featureItem);\n    } else {\r\n        def.push(feature);\r\n    }\n        \n    model.properties.schema = def;    \n}\n\ncontroller.generateCSVOutputSchema= function (schemaEditorModel) {\n    var schema = [];\n    if (schemaEditorModel == null)\n        return schema;\n    for (var i = 0; i < schemaEditorModel.length; i++) {\n        var item = schemaEditorModel[i];\n        if (item._excluded == null || item._excluded == false || item._excluded == \"false\") {\n            var row = {\n                name: item.name,\n                type: item.type,\n                isOptional: item._isOptional,\n                isArray: item._isArray\n            }\n            if (row.isArray == null)\n                row.isArray = false;\n            schema.push(row);            \n        }\n    }\n    return schema;\n};\n\r\ncontroller.isReservedWords = function (item){\r\n    var keywords = [\"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\",\r\n                    \"char\", \"class\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"extends\", \"false\",\r\n                    \"final\", \"finally\", \"float\", \"for\", \"goto\", \"if\", \"implements\", \"import\", \"instanceof\", \"int\",\r\n                    \"interface\", \"long\", \"native\", \"new\", \"null\", \"package\", \"private\", \"protected\", \"public\",\r\n                    \"return\", \"short\", \"static\", \"strictfp\", \"super\", \"switch\", \"synchronized\", \"this\", \"throw\",\r\n                    \"throws\", \"transient\", \"true\", \"try\", \"void\", \"volatile\", \"while\"];\r\n\r\n    for(var i = 0; i < keywords.length; i++) {\r\n        if(item == keywords[i]) {\r\n        \treturn true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n\r\ncontroller.validateFieldName= function(item, messagePrefix, flowModel, model, logs, context) {\r\n    var fieldNameRegexp = i18n(\"field.name.regexp\");\r\n    var fieldNameRegExpTest = new RegExp('^' + fieldNameRegexp + '$');\r\n\r\n    if(item.name == \"\"){\r\n        logs.push({\r\n                context : context,\r\n                message  : i18n(messagePrefix + \".required\"),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n        });\r\n    }\r\n    if(item.name != \"\" && !fieldNameRegExpTest.test(item.name)) {\r\n        logs.push({\r\n                context : context,\r\n                message  : i18n(messagePrefix + \".invalid\", [item.name]),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n        });                      \r\n    }\r\n    if(controller.isReservedWords (item.name)){\r\n        logs.push({\r\n            context : context,\r\n            message : i18n(messagePrefix + \".reserved.word\", [item.name]),\r\n            realType : \"Warning\",\r\n            type     : i18n(\"validate.warning.flag\")\r\n        });                       \r\n    }\r\n\t\r\n};\r\n\r\ncontroller.validateSchemaField = function(flowModel, model, logs, context) {\r\n    var fieldNameRegexp = i18n(\"field.name.regexp\");\r\n    var fieldNameRegExpTest = new RegExp('^' + fieldNameRegexp + '$');\r\n    \r\n    var schemaList = model.properties.schema;\r\n    var fieldNameMap = {};\r\n    if(schemaList) {\r\n        array.forEach(schemaList, function(item) {\r\n\t\t\tif (item.excluded != true) {\r\n            if(!item.name){\r\n                logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.schema.name.required\"),\r\n                        realType : \"Error\",\r\n                        type     : i18n(\"validate.error.flag\")\r\n                });\r\n            }\r\n            if(!fieldNameRegExpTest.test(item.name)){\r\n                logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.schema.name.invalid\", [item.name]),\r\n                        realType : \"Error\",\r\n                        type     : i18n(\"validate.error.flag\")\r\n                });                      \r\n            }\r\n            if(controller.isReservedWords (item.clazz)){\r\n                logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.schema.class.name.reserved.word\", [item.clazz]),\r\n                        realType : \"Error\",\r\n                        type     : i18n(\"validate.error.flag\")\r\n                });                       \r\n            }\r\n            if (item.name && fieldNameRegExpTest.test(item.name) && !controller.isReservedWords (item.name)) {\r\n                var clazzName = item.clazz ? item.clazz : \"*\";\r\n                var key = item.name + \"@\" + clazzName;\r\n                if (fieldNameMap.hasOwnProperty(key)) {\r\n                    if(clazzName == \"*\"){\r\n                        logs.push({\r\n                            context : context,\r\n                            message  : i18n(\"validate.schema.name.duplicate.in.top.level\",[item.name]),\r\n                            realType : \"Error\",\r\n                            type     : i18n(\"validate.error.flag\")\r\n                        });                                                                                               \r\n                    }else{\r\n                        logs.push({\r\n                            context : context,\r\n                            message  : i18n(\"validate.schema.name.duplicate.in.case.class\",[item.name, clazzName]),\r\n                            realType : \"Error\",\r\n                            type     : i18n(\"validate.error.flag\")\r\n                        });                                                                                                                       \r\n                    }\r\n                }else{\r\n                    fieldNameMap[key] = 1;\r\n                }\r\n            }}\r\n        });\r\n    }\r\n};\r\n\r\ncontroller.getUpStreamSample = function(flow, parseId) {\r\n\t// find the up stream node from link area\r\n\tvar upStreamId = null, portId = \"\";\r\n\tfor(var i=0;i<flow.links.length;i++) {\r\n\t\tvar link = flow.links[i];\r\n\t\tif(link.tgtId == parseId) {\r\n\t\t\tupStreamId = link.srcId;\r\n\t\t\tportId = link.srcPort;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(upStreamId) {\r\n\t\tfor(var j=0;j< flow.nodes.length;j++) {\r\n\t\t\tvar node = flow.nodes[j];\r\n\t\t\tif(node.uuid == upStreamId) {\r\n\t\t\t\tvar result = [];\r\n\t\t\t\tif(node.model.sample) {\r\n\t\t\t\t\tvar sample = node.model.sample;\r\n\t\t\t\t\tif (sample.charCodeAt(0) == 65279) {//remove unexpected invisible char\r\n\t\t\t\t\t\tsample = sample.substring(1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar lines = sample.split(\"\\n\");\r\n\t\t\t\t\tarray.forEach(lines, function (line) {\r\n\t\t\t\t\t\tif (line) {\r\n\t\t\t\t\t\t\tresult.push({data: line});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}else  if(node.model.properties && node.model.properties.sample) {\r\n\t\t\t\t\tvar sample = node.model.properties.sample;\r\n\t\t\t\t\tif (sample.charCodeAt(0) == 65279) {//remove unexpected invisible char\r\n\t\t\t\t\t\tsample = sample.substring(1);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar lines = sample.split(\"\\n\");\r\n\t\t\t\t\tarray.forEach(lines, function (line) {\r\n\t\t\t\t\t\tif (line) {\r\n\t\t\t\t\t\t\tresult.push({data: line});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else { // no sample, from interactive result\r\n\t\t\t\t\tvar uid = portId.split(\":\")[1];\r\n\t\t\t\t\tvar source = controller.getSourceByUid(node.model.sources, uid);\r\n\t\t\t\t\tif(source && source.sourceData) {\r\n\t\t\t\t\t\tresult = source.sourceData.result;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\ncontroller.getSourceByUid = function(sources, uid) {\r\n\treturn controller.getItemByUid(uid, sources);\r\n};\r\n\r\ncontroller.getItemByUid = function (uid, items) {\r\n\tuid = uid + \"\";\r\n\tvar item = null;\r\n\tif(items instanceof Array){\r\n\t\tarray.some(items, function(i){\r\n\t\t\tif(i.uid == uid){\r\n\t\t\t\titem = i;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\titem = items;\r\n\t}\r\n\treturn item;        \r\n};\r\n  \r\ncontroller.validateSource = function(flowModel, model, logs, context) {\r\n    if (model.sources[0].sourceData == null ||  model.sources[0].sourceData.uuid == \"\" ||  model.sources[0].sourceData.uuid == null) {\r\n        /*logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.input.port.not.wired\"),\r\n                    realType : \"Error\",\r\n                    type     : \"Error\"\r\n        });*/ //already done in framework level\r\n    } else {\r\n        var id = model.sources[0].sourceData.uuid;\r\n        var nodes = flowModel.nodes;\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].uuid == id) {\r\n\t\t\t\tvar outputType = \"\";\r\n\t\t\t\tvar dataType = \"\";\r\n\t\t\t\tif (nodes[i].model.output != null) {\r\n\t\t\t\t\toutputType = nodes[i].model.output.outputType;\r\n\t\t\t\t\tif (outputType == null) {\r\n\t\t\t\t\t\toutputType = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdataType = nodes[i].model.output.dataType;\r\n\t\t\t\t\tif (dataType == null) {\r\n\t\t\t\t\t\tdataType = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n                if (!((outputType == \"RDD\" || outputType == \"DStream\" || outputType == \"\") && (dataType == \"String\" || dataType == \"\")))  {\r\n                    logs.push({\r\n                        context : context,\r\n                        message  : i18n(\"validate.source.type.mismatch\"),\r\n                        realType : \"Error\",\r\n                        type     : i18n(\"validate.error.flag\")\r\n                    });                    \r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }    \r\n};\r\n\r\ncontroller.validateLIBSVMInputFormat = function(flowModel, model, logs, context) {\r\n    if (model.sources != null && \r\n        model.sources.length > 0 && \r\n        model.sources[0].sourceData != null && \r\n        model.sources[0].sourceData.result != null && \r\n        model.sources[0].sourceData.result.length > 0 && \r\n        model.sources[0].sourceData.result[0].data != null) {\r\n\r\n        var line = model.sources[0].sourceData.result[0].data;\r\n        var parts = line.split(\" \");\r\n        if (parts.length < 2) {\r\n            logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.libsvm.input.invalid\"),\r\n                    realType : \"Error\",\r\n                    type     : i18n(\"validate.error.flag\")\r\n            });\r\n            return;\r\n        }\r\n        for (var i = 1; i < parts.length; i++) {\r\n            var p = parts[i];\r\n            if (p == \"\") continue;\r\n            var iv = p.split(\":\");\r\n            if (iv.length != 2) {\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.libsvm.input.invalid\"),\r\n                    realType : \"Error\",\r\n                    type     : i18n(\"validate.error.flag\")\r\n                });\r\n                return;\r\n            }\r\n        }\r\n    }\r\n};\r\n  \r\ncontroller.validateDelimiter = function(flowModel, model, logs, context) {\r\n\t// delimiter is null when initialized, the framework will do validation at this time.\r\n\t// if user delete the value, delimiter will be \"\", framework will not do the validation.\r\n    if (model.properties.delimiter == \"\") {\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.no.delimiter\"),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        });\r\n    } else {\r\n\t\tif (model.properties.delimiter.length != 1) {\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.delimiter.single\"),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n            });\t\t\t\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\ncontroller.validateFieldIndexesFormat = function(flowModel, model, logs, context) {\r\n    \r\n    if (model.properties.fieldIndexes == null || model.properties.fieldIndexes == \"\") {\r\n/*        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.fieldIndexes.required\"),\r\n            realType : \"Error\",\r\n            type     : \"Error\"\r\n        });*/\r\n    } else {\r\n        var index = model.properties.fieldIndexes;\r\n        var parts = index.split(\",\");\r\n        var message = \"\";\r\n        for (var i = 0; i < parts.length; i++) {\r\n            var part = parts[i];\r\n            if (part.indexOf(\"-\") == -1) {\r\n                // singel number\r\n                try {\r\n                    part = part.trim();\r\n                    var p = parseInt(part);\r\n                    if (isNaN(p)) {\r\n                        message = message + part + \",\";\r\n                    }\r\n                } catch (e) {\r\n                    message = message + part + \",\";\r\n                }\r\n            } else {\r\n                var boundary = part.split(\"-\");\r\n                if (boundary.length != 2) {\r\n                    message = message + part + \",\";\r\n                } else {\r\n                    var min = boundary[0];\r\n                    var max = boundary[1];\r\n                    try {\r\n                        min = min.trim();\r\n                        min = parseInt(min);\r\n                        max = max.trim();\r\n                        max = parseInt(max);\r\n                        if (isNaN(min) || isNaN(max) || min > max) {\r\n                            message = message + part + \",\";\r\n                        }\r\n                    } catch (e1) {\r\n                        message = message + part + \",\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (message.length > 0) {\r\n            message = message.substring(0, message.length - 1);\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.fieldIndexes.format\", [message]),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n            });                                    \r\n        }\r\n    }\r\n    \r\n};\r\n\r\ncontroller.validateFieldIndexesType =  function(flowModel, model, logs, context) {\r\n    \r\n    if (model.properties.schema == null)\r\n        return;\r\n    var ranges = controller.getRanges(model.properties.fieldIndexes);\r\n    var message = \"\";\r\n    var scope = \"\";\r\n    for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        for (var j = range.min; j <= range.max; j++) {\r\n            \r\n            if (j >= model.properties.schema.length - 1) {\r\n                // skip the feature field.\r\n                scope = scope + j + \",\";\r\n            } else {\r\n                var type = model.properties.schema[j].type;\r\n                if (type != \"double\" && type != \"float\" && type != \"integer\" && type != \"long\" && type != \"number\") {\r\n                    message = message + j + \",\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (message.length > 0) {\r\n        message = message.substring(0, message.length - 1);\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.fieldIndexes.type\", [message]),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        });                                            \r\n    }\r\n    if (scope.length > 0) {\r\n        scope = scope.substring(0, scope.length - 1);\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.fieldIndexes.scope\", [scope]),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        });                                            \r\n    }\r\n    \r\n};\r\n\r\ncontroller.validateNumberOfFeatures =  function(flowModel, model, logs, context) {\r\n\t\r\n\tif (isNaN(model.properties.featureNumber)) {\r\n\t\tvar field = i18n(\"property.featureNumber.label\");\r\n\t\tlogs.push({\r\n\t\t\t\tcontext : context,\r\n\t\t\t\tmessage  : i18n(\"validate.featureNumber.invalid\", [field]),\r\n\t\t\t\trealType : \"Error\",\r\n\t\t\t\ttype     : i18n(\"validate.error.flag\")\r\n\t\t});\r\n\t\treturn;\r\n\t}\r\n\t\r\n    if (model.properties.featureNumber === 0 || model.properties.featureNumber === \"0\" ) {    \r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.featureNumber.value\"),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        });                                            \r\n    }\r\n    if (model.properties.featureNumber === \"\") {    \r\n/*        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.featureNumber.required\"),\r\n            realType : \"Error\",\r\n            type     : i18n(\"validate.error.flag\")\r\n        });                                            \r\n*/    }    \r\n};\r\n\r\ncontroller.validateFeatureColumn =  function(flowModel, model, logs, context) {\r\n    if (model.properties.schema == null)\r\n        return;\r\n    var feature = model.properties.featureCol;\r\n    for (var i = 0; i < model.properties.schema.length; i++) {\r\n        var item = model.properties.schema[i];\r\n        if (item.initName == feature && (item._excluded == true || item._excluded == \"true\")) {\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.featureCol.exclude\", [feature]),\r\n                realType : \"Error\",\r\n                type     : i18n(\"validate.error.flag\")\r\n            });                                                        \r\n        }\r\n    }\r\n};\r\n\r\n\r\ncontroller.schemaChanged = function(newValue, oldValue) {\r\n    if (newValue == null && oldValue == null)\r\n        return false;\r\n    if ((newValue != null && oldValue == null) || (newValue == null && oldValue != null) || (newValue.length != oldValue.length))\r\n        return true;\r\n    for (var i = 0; i < newValue.length; i++) {\r\n        var newItem = newValue[i];\r\n        var oldItem = oldValue[i];\r\n        if (newItem._excluded != oldItem._excluded ||\r\n            newItem.type != oldItem.type ||\r\n            newItem._isOptional != oldItem._isOptional ||\r\n            newItem.format != oldItem.format ||\r\n            newItem.name != oldItem.name) {\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n  \n/*** End ***/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n    //debugger;\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n    //debugger;\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    if (model.properties.format === \"libsvm\") {\n        status.push({name: \"featureCol\", visible: true});\n        status.push({name: \"labelCol\", visible: true});\n        status.push({name: \"featureNumber\", visible:true});\n        status.push({name: \"hasHeader\", visible: false});\n        status.push({name: \"delimiterType\", visible: false});\n        status.push({name: \"delimiter\", visible: false});\n        status.push({name: \"fieldIndexes\", visible: false});\n        status.push({name: \"schema\", visible: false});        \n    } else {\n        status.push({name: \"featureCol\", visible: true});\n        status.push({name: \"labelCol\", visible: false});\n        status.push({name: \"featureNumber\", visible:false});\n        status.push({name: \"hasHeader\", visible: true});\n        status.push({name: \"delimiterType\", visible: true});\n        if (model.properties.delimiterType === \"other\") {\n            status.push({name: \"delimiter\", visible: true});            \n        } else {\n            status.push({name: \"delimiter\", visible: false});            \n        }\n        status.push({name: \"fieldIndexes\", visible: true});\n        status.push({name: \"schema\", visible: true});        \n    }\n    \r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n    //debugger\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event, flow) {\r\n    //debugger;\n    var impacts = [];\n    if (model.properties.format == \"csv\") {\r\n        if (event.name == \"fieldIndexes\"  || event.name == \"hasHeader\" || \n            event.name == \"featureCol\"    || event.name == \"delimiter\" || \r\n            event.name == \"delimiterType\" || event.name == \"format\") {\r\n                \n            controller.regenerateSchemaDef(flow, model, model.properties.schema);\n            impacts.push({ \"name\": \"schema\",\n                           \"value\": model.properties.schema\r\n            });\n        } else if (event.name == \"schema\") {\r\n            var b = controller.schemaChanged(event.newValue, event.oldValue);\r\n            if (b) {\r\n                // do not reset schemaChangeByUI back to false, if the schema is unchanged.            \r\n                model.properties.schemaChangeByUI = true;\r\n                impacts.push({ \"name\": \"schemaChangeByUI\",\r\n                           \"value\": true\r\n                });\r\n                \r\n            }\r\n        }\r\n    } else if (model.properties.format == \"libsvm\") {\r\n        model.properties.schemaChangeByUI = false;\r\n        impacts.push({ \"name\": \"schemaChangeByUI\",\r\n                       \"value\": false\r\n        });        \r\n    }\n    return impacts;\n    \r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    //debugger;\n    if (model.properties.format === \"libsvm\") {\n        schema.push({name: model.properties.labelCol, type: \"double\"});\n        schema.push({name: model.properties.featureCol, type:\"org.apache.spark.ml.linalg.Vector\"});\n    } else {\n        // not entry point to initialize the schema editor model.\n        // below method keep user action and initialize the model schema editor content.\n        controller.regenerateSchemaDef(flowModel, model, model.properties.schema);\n        schema = controller.generateCSVOutputSchema(model.properties.schema);\n    }\n    \r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n\r\n//__CODING_START__:evaluateModelProperty\r\ncontroller.evaluateModelProperty = function(controller, flowModel, item, callback) {\r\n    //debugger;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    //debugger;\n    controller.validateSource(flowModel, model, logs, context);\n    if (model.properties.format == \"csv\") {\r\n        //controller.validateSchemaField(flowModel, model, logs, context);\r\n        if (model.properties.delimiterType == \"other\") {\r\n            controller.validateDelimiter(flowModel, model, logs, context);\r\n        }\r\n        var item = {name: model.properties.featureCol};\r\n        controller.validateFieldName(item, \"validate.featureCol\", flowModel, model, logs, context);\r\n        controller.validateFieldIndexesFormat(flowModel, model, logs, context);\r\n        controller.validateFieldIndexesType(flowModel, model, logs, context);\r\n        controller.validateFeatureColumn(flowModel, model, logs, context);\r\n    } else {\r\n        var item = {name: model.properties.featureCol};\r\n        controller.validateFieldName(item, \"validate.featureCol\", flowModel, model, logs, context);\r\n        item = {name: model.properties.labelCol};\r\n        controller.validateFieldName(item, \"validate.labelCol\", flowModel, model, logs, context);\r\n        controller.validateNumberOfFeatures(flowModel, model, logs, context);\r\n        controller.validateLIBSVMInputFormat(flowModel, model, logs, context);\r\n    }\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "PrepareBlock",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"outPort": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/outPort/icon_outport.png",
					"inputMaxCount": 1,
					"outputMaxCount": 0,
					"ui.controller": "controller.js",
					"code": false,
					"displayName": "Output Port",
					"acceptedSourceTypes": [
						"RDD",
						"DStream",
						"DataFrame"
					],
					"displayOrder": "10",
					"outputType": "*",
					"label": "Output Port",
					"groupImage": "",
					"outputMinCount": 0,
					"isBuilt": true,
					"hidePortLabel": true,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"name": "outPort",
					"fixedSize": true,
					"model": [
						{
							"editorType": "typePicker",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "type",
							"label": "Type",
							"type": "object",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": true,
							"constraints": {
								"type": "typePicker",
								"args": {
									"kind": "all"
								}
							},
							"generateSchema": true
						}
					],
					"toCustom": false,
					"dependent": false,
					"group": "Subflow",
					"desc": "Define output port properties"
				},
				"initialConfig": {},
				"outputMinCount": 0,
				"outputMaxCount": 0,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=outPort_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, category) {\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "outPort",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"RunSQL": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_run_JDBC.png",
					"helper": "spark/flow/helpers/RunSQL",
					"displayName": "RunSQL",
					"name": "RunSQL",
					"displayOrder": "100",
					"dependent": false,
					"group": "Transform",
					"desc": "Perform SQL computation on data source table"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 10,
				"dataTypeEditable": false,
				"_index": 0,
				"isDynamicSchema": true
			},
			"stateMachine": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/StateMachine.png",
					"widget": "spark/stateMachine/widgets/StateMachineFunctionWidget",
					"helper": "spark/stateMachine/helpers/StateMachineFunctionHelper",
					"displayName": "State Machine",
					"name": "stateMachine",
					"displayOrder": "150",
					"style": "app/spark/html/themes/hybrid/default/css/function-sm.css",
					"dependent": false,
					"key": "ADF_State_Machine",
					"group": "Transform",
					"desc": "State machine building block"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 20,
				"sourceMinCount": 1,
				"sourceMaxCount": 20,
				"dataTypeEditable": false,
				"_index": 0
			},
			"Filter": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_filter.png",
					"helper": "spark/flow/helpers/Filter",
					"displayName": "Filter",
					"name": "Filter",
					"displayOrder": "20",
					"dependent": false,
					"properties": {
						"schema": false,
						"script": true,
						"scriptLabel": "Filter Expression"
					},
					"group": "Transform",
					"desc": "Filter data based on filtering expressions"
				},
				"initialConfig": {
					"properties": {
						"schema": false,
						"script": true,
						"scriptLabel": "Filter Expression"
					}
				},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"JDBCTarget": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_target_JDBC.png",
					"helper": "spark/flow/helpers/JDBCTarget",
					"displayName": "JDBC",
					"name": "JDBCTarget",
					"displayOrder": "40",
					"groupLabel": "Targets",
					"dependent": false,
					"group": "Target",
					"desc": "Output data to JDBC resource"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"outputCount": 1,
				"oracleMap": {
					"default": "VARCHAR2",
					"string": "VARCHAR2",
					"boolean": "NUMBER",
					"datetime": "TIMESTAMP",
					"date": "DATE",
					"time": "DATE",
					"double": "DOUBLE PRECISION",
					"float": "FLOAT",
					"integer": "NUMBER",
					"long": "NUMBER",
					"number": "DOUBLE PRECISION"
				},
				"mySqlMap": {
					"default": "VARCHAR",
					"string": "VARCHAR",
					"boolean": "TINYINT",
					"datetime": "DATETIME",
					"date": "DATE",
					"time": "TIME",
					"double": "DOUBLE",
					"float": "FLOAT",
					"integer": "INTEGER",
					"long": "BIGINT",
					"number": "DOUBLE"
				},
				"msSqlMap": {
					"default": "VARCHAR",
					"string": "VARCHAR",
					"boolean": "BIT",
					"datetime": "DATETIME",
					"date": "DATETIME",
					"time": "DATETIME",
					"double": "DOUBLE PRECISION",
					"float": "FLOAT",
					"integer": "INT",
					"long": "BIGINT",
					"number": "DOUBLE PRECISION"
				},
				"hanaMap": {
					"default": "VARCHAR",
					"string": "VARCHAR",
					"integer": "INTEGER",
					"long": "BIGINT",
					"float": "FLOAT",
					"double": "DOUBLE",
					"number": "DOUBLE",
					"boolean": "BOOLEAN",
					"date": "DATE",
					"datetime": "TIMESTAMP",
					"time": "TIME"
				}
			},
			"Compute": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_compute.png",
					"helper": "spark/flow/helpers/Compute",
					"displayName": "Derived Fields",
					"name": "Compute",
					"displayOrder": "50",
					"dependent": false,
					"group": "Transform",
					"desc": "Compute additional data fields using calculation expressions"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"PMML": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_predictive_pmml.png",
					"group.backgroundColor": "66,193,80",
					"widget": "spark/predictive/widgets/PMMLFunctionWidget",
					"displayName": "PMML",
					"groupLabel": "Predictive",
					"helper": "spark/predictive/helpers/PMMLFunctionHelper",
					"name": "PMML",
					"style": "app/spark/html/themes/hybrid/default/css/function-predictive.css",
					"group.labelColor": "68,68,68",
					"toCustom": "false",
					"dependent": true,
					"key": "ADF_PMML_Module",
					"group": "Predictive",
					"desc": "Make a prediction on input data according to PMML model"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"Alert": {
				"funcDef": {
					"group.backgroundColor": "180,70,70",
					"image": "/vitria-oi/app/spark/block/Alert/alert-block.png",
					"inputMaxCount": 1,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "Alert",
					"acceptedSourceTypes": [
						"DStream"
					],
					"displayOrder": "10",
					"groupLabel": "Alerts & Notifications",
					"outputType": "*",
					"label": "Alert",
					"groupImage": "/vitria-oi/app/spark/block/Alert/AlertNotification_group_icon.png",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "Alert",
					"model": [
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"name": "compute",
							"label": "Alert Mapping",
							"type": "object",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": false,
							"sourceSchemaSensitive": true,
							"value": [
								{
									"name": "Id",
									"label": "Id *",
									"type": "string",
									"sleText": {
										"text": "uuid()",
										"type": "string",
										"option": false
									},
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "EntityId",
									"label": "EntityId *",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "AssociatedEntityId",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "FirstOccurred",
									"label": "FirstOccurred *",
									"type": "datetime",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "LastOccurred",
									"type": "datetime",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Created",
									"label": "Created *",
									"type": "datetime",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Timebin",
									"label": "Timebin *",
									"type": "long",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Measure",
									"label": "Measure *",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "ThresholdSetting",
									"label": "ThresholdSetting *",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "HighThreshold",
									"label": "HighThreshold *",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": false,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "LowThreshold",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Judgement",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "TriggerDuration",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Lat",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Lon",
									"type": "double",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "ContextURL",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								},
								{
									"name": "Detail",
									"type": "string",
									"sleText": "",
									"skip": false,
									"skipable": true,
									"_deletable": false,
									"buildin": true
								}
							],
							"constraints": {
								"type": "grid",
								"args": {
									"popup": false,
									"addable": true,
									"title": "Map alert fields from input fields",
									"columns": [
										{
											"_id": "6d3f30fc-560f-44f2-8bf3-83ac3249419d",
											"*": {
												"label": "label"
											},
											"name": "name",
											"showLabel": true,
											"labelField": "label",
											"label": "Alert Field Name",
											"editorType": "textInput",
											"$$extra": "",
											"type": "string",
											"editable": "false",
											"controlName": "buildin",
											"controlValue": false,
											"initProperty": {
												"buildin": false
											}
										},
										{
											"_id": "a3cf9bee-3511-4761-8c5a-4a27aadb186c",
											"*": {
												"label": "label"
											},
											"name": "type",
											"label": "Data Type",
											"editorType": "sparkSelect",
											"$$extra": "",
											"type": "string",
											"editable": "false",
											"width": 100,
											"controlName": "buildin",
											"controlValue": false,
											"defaultValue": "string",
											"constraints": {
												"type": "sparkSelect",
												"args": {
													"optionsReference": "$global.primitiveTypes"
												}
											}
										},
										{
											"_id": "aeff15b5-2ee5-4173-89e3-fecdfa49b00c",
											"*": {
												"label": "label"
											},
											"name": "sleText",
											"label": "Input Field Expression",
											"editorType": "sle",
											"$$extra": "",
											"type": "object",
											"editable": "false",
											"controlName": "name",
											"controlValue": "Id",
											"controlPolicy": "disable",
											"constraints": {
												"type": "sle",
												"args": {
													"validateProperty": "true",
													"sourcePrefix": "false",
													"nodeType": "primitive",
													"expandArray": false,
													"types": [
														"string",
														"boolean",
														"integer",
														"long",
														"double",
														"float",
														"date",
														"time",
														"datetime",
														"array"
													],
													"refs": [
														{
															"name": "targetType",
															"ref": "$.type"
														},
														{
															"name": "novalidate",
															"ref": "$.skip"
														}
													]
												}
											},
											"sourceSchemaSensitive": true
										},
										{
											"_id": "7c08e97c-12aa-4143-8dfd-3df4cac97816",
											"*": {
												"label": "label"
											},
											"name": "skip",
											"label": "Skip",
											"editorType": "boolean",
											"$$extra": "",
											"type": "checkbox",
											"editable": "false",
											"width": 30,
											"display": "skipable",
											"defaultValue": false,
											"initProperty": {
												"skipable": false
											}
										}
									],
									"heightAdaption": "true"
								}
							}
						},
						{
							"editorType": "caseClass",
							"*": {
								"label": "label"
							},
							"name": "case",
							"label": "Case Class",
							"type": "object",
							"disabled": false,
							"escapeValue": true,
							"value": {
								"ref": false
							},
							"optional": "true",
							"constraints": {
								"type": "caseClass",
								"args": {
									"editOnly": true
								}
							},
							"impactSchema": true
						}
					],
					"dependent": false,
					"key": "ADF_Notification",
					"group": "AlertsNotifications",
					"desc": "Alert"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=Alert_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n        //var caseClass = model.properties[\"case\"].name;\r\n    var properties = model.properties.compute;\r\n    if (properties != null) {\r\n        for (var i=0; i < properties.length; i++) {\r\n            var prop = properties[i];\r\n            if (prop.skip != true) {\r\n                var propOptional = prop.skipable;\r\n                if (!prop.buildin) {\r\n                    var sleTxt = prop.sleText;\r\n                    if (sleTxt != null) {\r\n                        propOptional = sleTxt.hasOwnProperty(\"option\") ? sleTxt.option == true : true;\r\n                    } else {\r\n                        propOptional = true;\r\n                    }\r\n                }\r\n                var schemaNode = PipeUtil.createSchemaField(prop.name, prop.name, prop.type, false, false, null, false, propOptional);\r\n                schema.push(schemaNode);\r\n            }\r\n        }\r\n    }\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    if (model.func != \"Alert\")\r\n        return;\r\n    var properties = model.properties.compute;\r\n    if (properties == null)\r\n        return;\r\n    \r\n    if ((properties.length > 22) && ((curClass.name == null) || (curClass.name == \"\"))) {\r\n        logs.push({\r\n            context : context,\r\n            message  : i18n(\"validate.alert.caseclass.required\"),\r\n            realType : \"Error\",\r\n            type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n        });\r\n    }\r\n    \r\n    var custFields = [\"Id\",\"EntityId\",\"AssociatedEntityId\",\"FirstOccurred\",\"LastOccurred\",\"Created\",\"Timebin\",\"Measure\",\r\n                      \"ThresholdSetting\",\"HighThreshold\",\"LowThreshold\",\"Judgement\",\"TriggerDuration\",\"Lat\", \"Lon\", \"ContextURL\", \"Detail\"];\r\n    for (var i=0; i < properties.length; i++) {\r\n        var prop = properties[i];\r\n        var propName = prop.name;\r\n        var type = prop.type;\r\n        var skip = prop.skip;\r\n        var buildin = prop.buildin;\r\n        if (skip)\r\n            continue;\r\n        \r\n        if ((propName == null) || (propName == \"\")) {\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.alert.field.mapping.name.empty\"),\r\n                realType : \"Error\",\r\n                type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n            });\r\n            continue;\r\n        }\r\n        \r\n        var sleText = prop.sleText;\r\n        if ((sleText == null) || (sleText.text == null) || (sleText.text == \"\")) {\r\n            logs.push({\r\n                context : context,\r\n                message  : i18n(\"validate.alert.field.mapping.empty\", [propName]),\r\n                realType : \"Error\",\r\n                type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n            });\r\n        } else {\r\n            var sourceSchema = [];\r\n            if (model.sources[0].sourceData != null) {\r\n                var inputSourceSchema = model.sources[0].sourceData.schema;\r\n                sourceSchema = PipeUtil.getSLESchemaList(inputSourceSchema);\r\n            }\r\n            /*var validResult = SleValidation.validateSLEText(sleText.text, sourceSchema, FunctionUtil.getFunctionList(), type, \"DStream\", null, true);\r\n            for (var j = 0; j < validResult.length; j++) {\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.alert.field.sle.validate.error\", [propName, validResult[j]]),\r\n                    realType : \"Error\",\r\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n                });\r\n            }*/\r\n            var opt = SleValidation.isOptional(sleText.text, sourceSchema, flowModel.properties);\r\n            if (buildin && (prop.skipable == false) && (opt == true)) {\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.alert.field.sle.validate.optional\", [propName]),\r\n                    realType : \"Error\",\r\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n                });\r\n            }\r\n        }\r\n        \r\n        if (!buildin) {\r\n            var dupName = \"\";\r\n            for (var j = 0; j < custFields.length; j++) {\r\n                if (custFields[j].toLocaleLowerCase() == propName.toLocaleLowerCase()) {\r\n                    dupName = custFields[j];\r\n                    break;\r\n                }\r\n            }\r\n            if (dupName != \"\") {\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.alert.field.mapping.duplicate.error\", [dupName]),\r\n                    realType : \"Error\",\r\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.error\")\r\n                });\r\n            } else if ((propName != null) && (propName != \"\")) {\r\n                custFields.push(propName);\r\n            }\r\n            /*var regStr = i18n(\"validate.alert.field.java.reserved.words\");\r\n            var regExp = new RegExp(regStr);\r\n            if (regExp.test(propName)) {\r\n                logs.push({\r\n                    context : context,\r\n                    message  : i18n(\"validate.alert.field.java.reserved.words.warn\", [propName]),\r\n                    realType : \"Warning\",\r\n                    type     : I18N.getString(\"spark.pipe\", \"validate.log.warning\")\r\n                });\r\n            }*/\r\n        }\r\n    }\r\n};\r\n\r\nreturn controller;\r\n",
					"_funcName": "Alert",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"StreamTarget": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_streaming_target.png",
					"helper": "spark/flow/helpers/StreamTarget",
					"displayName": "Streaming",
					"name": "StreamTarget",
					"displayOrder": "20",
					"groupLabel": "Targets",
					"dependent": false,
					"group": "Target",
					"desc": "Output data for continuous stream processing"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"outputCount": 1
			},
			"kafkaTarget": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_kafka_target.png",
					"widget": "spark/kafka/widgets/KafkaTargetFunctionWidget",
					"helper": "spark/kafka/helpers/KafkaTargetFunctionHelper",
					"displayName": "Kafka",
					"name": "kafkaTarget",
					"displayOrder": "50",
					"toCustom": "false",
					"dependent": true,
					"key": "ADF_Kafka_Module",
					"group": "Target",
					"desc": "Output data to kafka target"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"outputCount": 1,
				"preDefineConfs": [
					{
						"name": "acks",
						"label": "acks",
						"defaultValue": "1"
					},
					{
						"name": "batch.size",
						"label": "batch.size",
						"defaultValue": "16384"
					},
					{
						"name": "block.on.buffer.full",
						"label": "block.on.buffer.full",
						"defaultValue": "false"
					},
					{
						"name": "buffer.memory",
						"label": "buffer.memory",
						"defaultValue": "33554432"
					},
					{
						"name": "client.id",
						"label": "client.id",
						"defaultValue": ""
					},
					{
						"name": "compression.type",
						"label": "compression.type",
						"defaultValue": "none"
					},
					{
						"name": "connections.max.idle.ms",
						"label": "connections.max.idle.ms",
						"defaultValue": "54000"
					},
					{
						"name": "linger.ms",
						"label": "linger.ms",
						"defaultValue": "0"
					},
					{
						"name": "max.block.ms",
						"label": "max.block.ms",
						"defaultValue": "60000"
					},
					{
						"name": "max.in.flight.requests.per.connection",
						"label": "max.in.flight.requests.per.connection",
						"defaultValue": "5"
					},
					{
						"name": "max.request.size",
						"label": "max.request.size",
						"defaultValue": "1048576"
					},
					{
						"name": "metadata.fetch.timeout.ms",
						"label": "metadata.fetch.timeout.ms",
						"defaultValue": "60000"
					},
					{
						"name": "metadata.max.age.ms",
						"label": "metadata.max.age.ms",
						"defaultValue": "300000"
					},
					{
						"name": "metrics.num.samples",
						"label": "metrics.num.samples",
						"defaultValue": "2"
					},
					{
						"name": "metrics.sample.window.ms",
						"label": "metrics.sample.window.ms",
						"defaultValue": "30000"
					},
					{
						"name": "partitioner.class",
						"label": "partitioner.class",
						"defaultValue": "org.apache.kafka.clients.producer.internals.DefaultPartitioner"
					},
					{
						"name": "receive.buffer.bytes",
						"label": "receive.buffer.bytes",
						"defaultValue": "32768"
					},
					{
						"name": "reconnect.backoff.ms",
						"label": "reconnect.backoff.ms",
						"defaultValue": "50"
					},
					{
						"name": "request.timeout.ms",
						"label": "request.timeout.ms",
						"defaultValue": "30000"
					},
					{
						"name": "retries",
						"label": "retries",
						"defaultValue": "0"
					},
					{
						"name": "retry.backoff.ms",
						"label": "retry.backoff.ms",
						"defaultValue": "100"
					},
					{
						"name": "sasl.kerberos.kinit.cmd",
						"label": "sasl.kerberos.kinit.cmd",
						"defaultValue": "/usr/bin/kinit"
					},
					{
						"name": "sasl.kerberos.min.time.before.relogin",
						"label": "sasl.kerberos.min.time.before.relogin",
						"defaultValue": "60000"
					},
					{
						"name": "sasl.kerberos.service.name",
						"label": "sasl.kerberos.service.name",
						"defaultValue": ""
					},
					{
						"name": "sasl.kerberos.ticket.renew.jitter",
						"label": "sasl.kerberos.ticket.renew.jitter",
						"defaultValue": "0.05"
					},
					{
						"name": "sasl.kerberos.ticket.renew.window.factor",
						"label": "sasl.kerberos.ticket.renew.window.factor",
						"defaultValue": "0.8"
					},
					{
						"name": "sasl.mechanism",
						"label": "sasl.mechanism",
						"defaultValue": "GSSAPI"
					},
					{
						"name": "security.protocol",
						"label": "security.protocol",
						"defaultValue": "PLAINTEXT"
					},
					{
						"name": "send.buffer.bytes",
						"label": "send.buffer.bytes",
						"defaultValue": "131072"
					},
					{
						"name": "ssl.endpoint.identification.algorithm",
						"label": "ssl.endpoint.identification.algorithm",
						"defaultValue": ""
					},
					{
						"name": "ssl.key.password",
						"label": "ssl.key.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.keymanager.algorithm",
						"label": "ssl.keymanager.algorithm",
						"defaultValue": "SunX509"
					},
					{
						"name": "ssl.keystore.location",
						"label": "ssl.keystore.location",
						"defaultValue": ""
					},
					{
						"name": "ssl.keystore.password",
						"label": "ssl.keystore.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.keystore.type",
						"label": "ssl.keystore.type",
						"defaultValue": "JKS"
					},
					{
						"name": "ssl.protocol",
						"label": "ssl.protocol",
						"defaultValue": "TLS"
					},
					{
						"name": "ssl.provider",
						"label": "ssl.provider",
						"defaultValue": ""
					},
					{
						"name": "ssl.trustmanager.algorithm",
						"label": "ssl.trustmanager.algorithm",
						"defaultValue": "PKIX"
					},
					{
						"name": "ssl.truststore.location",
						"label": "ssl.truststore.location",
						"defaultValue": ""
					},
					{
						"name": "ssl.truststore.password",
						"label": "ssl.truststore.password",
						"defaultValue": ""
					},
					{
						"name": "ssl.truststore.type",
						"label": "ssl.truststore.type",
						"defaultValue": "JKS"
					},
					{
						"name": "timeout.ms",
						"label": "timeout.ms",
						"defaultValue": "30000"
					}
				]
			},
			"Aggregate": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/html/images/functions/icon_aggregate.png",
					"helper": "spark/flow/helpers/Aggregate",
					"displayName": "Aggregate",
					"name": "Aggregate",
					"displayOrder": "60",
					"dependent": false,
					"properties": {
						"schema": false,
						"script": false,
						"scriptLabel": "Aggregation Expression",
						"windowSpec": true,
						"windowShow": false
					},
					"group": "Transform",
					"desc": "Aggregate data values based on dimension grouping"
				},
				"initialConfig": {
					"properties": {
						"schema": false,
						"script": false,
						"scriptLabel": "Aggregation Expression",
						"windowSpec": true,
						"windowShow": false
					}
				},
				"outputMinCount": 1,
				"outputMaxCount": 2,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			},
			"Split": {
				"funcDef": {
					"group.backgroundColor": "66,193,80",
					"image": "/vitria-oi/app/spark/block/Split/icon-22.png",
					"inputMaxCount": 1,
					"outputMaxCount": 22,
					"ui.controller": "controller.js",
					"displayName": "Split",
					"acceptedSourceTypes": [
						"RDD",
						"DataFrame"
					],
					"displayOrder": "1000",
					"outputType": "*",
					"label": "Split",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 1,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "Split",
					"group.labelColor": "68,68,68",
					"model": [
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.randomSplit": "constraints.args.options.0.label",
								"options.sleSplit": "constraints.args.options.1.label",
								"options.stratifiedSampling": "constraints.args.options.2.label"
							},
							"group": "common",
							"name": "type",
							"label": "Type",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"value": "randomSplit",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Random Split",
											"value": "randomSplit"
										},
										{
											"label": "SLE Expression Split",
											"value": "sleSplit"
										},
										{
											"label": "Stratified Sampling",
											"value": "stratifiedSampling"
										}
									],
									"needPlaceholder": true,
									"multiple": false
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "randomSplitSeed",
							"label": "Seed",
							"type": "long",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "randomSplit",
							"value": 10000
						},
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "randomSplitWeights",
							"label": "Weights",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": true,
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "randomSplit",
							"value": [],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": true,
									"title": "Please configure the weights for each split parts. The sum of all weighs should be 1.",
									"columns": [
										{
											"editorType": "number",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "weight",
											"label": "Weight",
											"type": "double",
											"disabled": "false",
											"controlPolicy": "enable",
											"constraints": {
												"min": "0",
												"max": "1",
												"step": "0.1",
												"maxLength": "4"
											}
										}
									],
									"heightAdaption": false
								}
							}
						},
						{
							"editorType": "sle",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "sleExpression",
							"label": "SLE Expression",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "sleSplit",
							"constraints": {
								"type": "sle",
								"args": {
									"validateProperty": "false",
									"targetType": [
										"boolean"
									],
									"sourcePrefix": "false",
									"predefinedPrefixes": [],
									"additionalFields": [],
									"nodeType": "all",
									"expandArray": false,
									"types": [
										"string",
										"boolean",
										"integer",
										"long",
										"double",
										"float",
										"date",
										"time",
										"datetime",
										"array"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.sampleByKey": "constraints.args.options.0.label",
								"options.sampleByKeyExact": "constraints.args.options.1.label"
							},
							"group": "common",
							"name": "ssSampleAPI",
							"label": "Sample Type",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "stratifiedSampling",
							"value": "sampleByKey",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "Approximate",
											"value": "sampleByKey"
										},
										{
											"label": "Exact",
											"value": "sampleByKeyExact"
										}
									],
									"needPlaceholder": true,
									"multiple": false
								}
							}
						},
						{
							"editorType": "fieldSelect",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "ssKeyField",
							"label": "Key Field",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "stratifiedSampling",
							"constraints": {
								"type": "fieldSelect",
								"args": {
									"nodeType": "primitive",
									"sourcePrefix": "false",
									"sourceName": "",
									"expandArray": false,
									"types": [
										"string",
										"boolean",
										"integer",
										"long",
										"double",
										"float",
										"date",
										"time",
										"datetime",
										"array"
									]
								}
							},
							"sourceSchemaSensitive": true
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "ssFraction",
							"label": "Fraction",
							"type": "double",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "stratifiedSampling"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "ssSeed",
							"label": "Seed",
							"type": "long",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "type",
							"controlValue": "stratifiedSampling",
							"value": 10000
						}
					],
					"dependent": false,
					"group": "Predictive",
					"desc": ""
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 22,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=Split_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model, propertyDef) {\r\n    var status = [];\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    \n    var str = \"\";\n    if (model.properties.type == \"randomSplit\") {\n        for (var i = 0; i < model.properties.randomSplitWeights.length; i++) {\n            str += (model.properties.randomSplitWeights[i].weight + \",\");\n        }\n        if (str.lastIndexOf(\",\") == str.length - 1) {\n            str = str.substring(0, str.length - 1);\n        }\n    } else if (model.properties.type == \"sleSplit\") {\n        str += \"true,\";\n        str += \"false\";\n    } else if (model.properties.type == \"stratifiedSampling\") {\n        str += \"sampled,\";\n        str += \"other\";\n    }\n    names = str.split(\",\");\n    \r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    \n    if (model.sources[0].sourceData != null)\n        schema = model.sources[0].sourceData.schema;\n    \r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    \n    if (model.sources[0].sourceData != null)\n        dataType = model.sources[0].sourceData.dataType;\n    \r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:validate\r\n/**\r\n * Validate properties of the building block, and collect warning or error into logs\r\n * @param flowModel flow model definition,\r\n * @param model model definition of building block (contains \"sources\", \"outputs\", \"properties\")\r\n * @param logs validation logs\r\n * @param context {category: \"\", nodeId: \"\"}\r\n * Append validation entry into logs with keys (context, message, type and realType)\r\n *     logs.push({\r\n *          context : context,\r\n *          message  : \"\",\r\n *          realType : \"Error\",\r\n *          type     : \"Error\"\r\n *      });\r\n **/\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    if (model.properties.type == \"randomSplit\") {\n        var sum = parseFloat(\"0\");\n        for (var i = 0; i < model.properties.randomSplitWeights.length; i++) {\n            sum += (parseFloat(model.properties.randomSplitWeights[i].weight));\n        }\n        if (sum != 1) {\n            logs.push({\n                context : context,\n                message  : \"The sum of all weighs should be 1.\",\n                realType : \"Error\",\n                type     : \"Error\"\n            });\n        }\n    } else if (model.properties.type == \"stratifiedSampling\") {\n        var fraction = parseFloat(model.properties.ssFraction);\n        if (fraction >= 1 || fraction <= 0) {\n            logs.push({\n                context : context,\n                message  : \"The fraction should be: 0 < fraction <1.\",\n                realType : \"Error\",\n                type     : \"Error\"\n            });\n        }\n    }\r\n};\r\n//__CODING_END__\r\n\r\nreturn controller;\r\n",
					"_funcName": "Split",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"MQTTSource": {
				"funcDef": {
					"image": "/vitria-oi/app/spark/block/MQTTSource/MQTTSource.png",
					"inputMaxCount": 0,
					"outputMaxCount": 1,
					"ui.controller": "controller.js",
					"displayName": "MQTT",
					"acceptedSourceTypes": [
						"DStream"
					],
					"displayOrder": "70",
					"libraries": [
						"${VTBA_HOME}/applications/home/work/spark.app/spark/lib/com.vitria.spark.mqtt.jar",
						"${VTBA_HOME}/applications/home/work/spark.app/spark/lib/org.eclipse.paho.client.mqttv3-1.0.2.jar",
						"${VTBA_HOME}/wildfly/modules/com/vitria/vtlibs/main/vtfc.jar"
					],
					"outputType": "DStream",
					"label": "MQTT",
					"code.variables": "code.variables.json",
					"outputMinCount": 1,
					"inputMinCount": 0,
					"code.template": "code.stg",
					"code.enrichment": "code.enrichment.js",
					"name": "MQTTSource",
					"model": [
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "serverURI",
							"label": "Server URI",
							"desc": "The mqtt server which this component will connect to.",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": [
								{
									"_id": "a65e18ee-5890-4de3-862e-31768f6c1307",
									"protocol": "tcp",
									"host": "",
									"port": "",
									"_deletable": false
								}
							],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": false,
									"title": " ",
									"columns": [
										{
											"editorType": "sparkSelect",
											"*": {
												"label": "label",
												"desc": "desc",
												"options.tcp": "constraints.args.options.0.label",
												"options.ssl": "constraints.args.options.1.label"
											},
											"name": "protocol",
											"label": "Protocol",
											"type": "string",
											"disabled": "false",
											"width": 100,
											"controlPolicy": "enable",
											"constraints": {
												"type": "sparkSelect",
												"args": {
													"options": [
														{
															"label": "TCP",
															"value": "tcp"
														},
														{
															"label": "SSL",
															"value": "ssl"
														}
													],
													"needPlaceholder": false,
													"multiple": false
												}
											}
										},
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "host",
											"label": "Host",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "disable"
										},
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "port",
											"label": "Port",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "disable"
										}
									],
									"heightAdaption": true
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "trustStore",
							"label": "Trust Store",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						},
						{
							"editorType": "password",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "trustStorePassword",
							"label": "Trust Store Password",
							"desc": "Password of TrustStore.",
							"type": "string",
							"optional": true,
							"hidden": false,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "",
							"value": "",
							"constraints": "password"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"group": "common",
							"name": "keyStore",
							"label": "Key Store",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						},
						{
							"editorType": "password",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "keyStorePassword",
							"label": "Key Store Password",
							"desc": "Password of Key Store.",
							"type": "string",
							"optional": true,
							"hidden": false,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "",
							"value": "",
							"constraints": "password"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "keyAlias",
							"label": "Key Alias",
							"desc": "Specify which certification in Key Store will be used for SSL.",
							"type": "string",
							"optional": true,
							"hidden": false,
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": ""
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "clientID",
							"label": "Client ID",
							"desc": "Client ID.",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						},
						{
							"editorType": "grid",
							"*": {
								"label": "label",
								"desc": "desc",
								"title": "constraints.args.title",
								"columns": "constraints.args.columns"
							},
							"group": "common",
							"name": "topics",
							"label": " ",
							"desc": "Identify the topics that mqttSource subscribe to.",
							"type": "object",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"value": [
								{
									"_id": "9e49b5bb-e4a1-4f55-84cb-b2a33de73aea",
									"topicValue": "",
									"_deletable": false
								}
							],
							"constraints": {
								"type": "grid",
								"args": {
									"reorder": "false",
									"popup": false,
									"addable": true,
									"title": " Topics",
									"columns": [
										{
											"editorType": "textInput",
											"*": {
												"label": "label",
												"desc": "desc"
											},
											"name": "topicValue",
											"label": " ",
											"type": "string",
											"disabled": "false",
											"controlPolicy": "enable"
										}
									],
									"heightAdaption": true
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "userName",
							"label": "User Name",
							"desc": "The user name to use for the connection.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true
						},
						{
							"editorType": "password",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "password",
							"label": "Password",
							"desc": "The password to use for the connection.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"value": "",
							"constraints": "password"
						},
						{
							"editorType": "radio",
							"*": {
								"label": "label",
								"desc": "desc",
								"data.default": "constraints.args.data.0.label",
								"data.custom": "constraints.args.data.1.label"
							},
							"group": "common",
							"name": "messageConverterControl",
							"label": "Message Converter",
							"desc": "Customized message converter, the message converter will convert a message from byte array to string.",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": "default",
							"constraints": {
								"type": "input",
								"args": {
									"inputType": "radio",
									"data": [
										{
											"value": "default",
											"label": "Default"
										},
										{
											"value": "custom",
											"label": "Custom"
										}
									],
									"itemStyle": "width:300px;"
								}
							}
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.UTF-8": "constraints.args.options.0.label",
								"options.GB2312": "constraints.args.options.1.label",
								"options.GBK": "constraints.args.options.2.label",
								"options.UTF-16": "constraints.args.options.3.label",
								"options.UTF-16BE": "constraints.args.options.4.label",
								"options.UTF-16LE": "constraints.args.options.5.label",
								"options.UTF-32": "constraints.args.options.6.label",
								"options.UTF-32BE": "constraints.args.options.7.label",
								"options.UTF-32LE": "constraints.args.options.8.label"
							},
							"group": "common",
							"name": "encoding",
							"label": "Encoding",
							"desc": "Encoding used the transform message playload to String.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "messageConverterControl",
							"controlValue": "default",
							"value": "UTF-8",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "UTF-8",
											"value": "UTF-8"
										},
										{
											"label": "GB2312",
											"value": "GB2312"
										},
										{
											"label": "GBK",
											"value": "GBK"
										},
										{
											"label": "UTF-16",
											"value": "UTF-16"
										},
										{
											"label": "UTF-16BE",
											"value": "UTF-16BE"
										},
										{
											"label": "UTF-16LE",
											"value": "UTF-16LE"
										},
										{
											"label": "UTF-32",
											"value": "UTF-32"
										},
										{
											"label": "UTF-32BE",
											"value": "UTF-32BE"
										},
										{
											"label": "UTF-32LE",
											"value": "UTF-32LE"
										}
									],
									"needPlaceholder": false,
									"multiple": false,
									"enumDyn": true,
									"url": "http://10.111.3.139:8080/vitria-oi/rest/app/sparksdk/user/vtbaadmin/sparkmodule/MQTT_CONNECTOR",
									"context": {
										"i18n": {
											"default": {
												"property.sample.label": "Sample Data",
												"property.cleanSession.label": "Clean Session",
												"property.cleanSession.desc": "Specify whether mqtt broker will remember state across reconnects of client.",
												"block.group.group": "Server URI",
												"property.topicLabel.label": "",
												"property.a.label": "a",
												"property.a.options.a": "a",
												"property.a.options.b": "b",
												"property.topicValue.label": "",
												"property.trustStorePassword.label": "Trust Store Password",
												"property.trustStorePassword.desc": "Password of TrustStore.",
												"property.keyStorePassword.label": "Key Store Password",
												"property.keyStorePassword.desc": "Password of Key Store.",
												"property.keyAlias.label": "Key Alias",
												"property.keyAlias.desc": "Specify which certification in Key Store will be used for SSL.",
												"property.filePath.label": "File Path",
												"property.protocol.label": "Protocol",
												"property.protocol.options.tcp": "TCP",
												"property.protocol.options.ssl": "SSL",
												"property.clientID.label": "Client ID",
												"property.clientID.desc": "Client ID.",
												"property.topics.label": " ",
												"property.topics.desc": "Identify the topics that mqttSource subscribe to.",
												"property.topics.title": " Topics",
												"property.topics.columns.topicValue.label": " ",
												"property.messageConverterControl.label": "Message Converter",
												"property.messageConverterControl.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
												"property.messageConverterControl.data.default": "Default",
												"property.messageConverterControl.data.custom": "Custom",
												"property.lwtMessage.label": "LWT Message",
												"property.lwtMessage.desc": "The content of LWT Message.",
												"property.trustStore.label": "Trust Store",
												"property.trustStore.desc": "Trust Store File.",
												"property.trustStore.title": " ",
												"property.trustStore.columns.type.label": " Type",
												"property.trustStore.columns.type.options.hdfs": "HDFS",
												"property.trustStore.columns.type.options.localFile": "Local File",
												"property.trustStore.columns.type.options.sparkFile": "Spark File",
												"property.trustStore.columns.filePath.label": "File Path",
												"property.type.label": "Type",
												"property.type.options.hdfs": "HDFS",
												"property.type.options.localFile": "Local File",
												"property.type.options.sparkFile": "Spark File",
												"property.keyStore.label": "Key Store",
												"property.keyStore.desc": "Key Store file.",
												"property.keyStore.title": " ",
												"property.keyStore.columns.type.label": "Type",
												"property.keyStore.columns.type.options.hdfs": "HDFS",
												"property.keyStore.columns.type.options.localFile": "Local File",
												"property.keyStore.columns.type.options.sparkFile": "Spark File",
												"property.keyStore.columns.filePath.label": "File Path",
												"property.encoding.label": "Encoding",
												"property.encoding.desc": "Encoding used the transform message playload to String.",
												"property.encoding.options.UTF-8": "UTF-8",
												"property.encoding.options.GB2312": "GB2312",
												"property.encoding.options.GBK": "GBK",
												"property.encoding.options.UTF-16": "UTF-16",
												"property.encoding.options.UTF-16BE": "UTF-16BE",
												"property.encoding.options.UTF-16LE": "UTF-16LE",
												"property.encoding.options.UTF-32": "UTF-32",
												"property.encoding.options.UTF-32BE": "UTF-32BE",
												"property.encoding.options.UTF-32LE": "UTF-32LE",
												"property.lwtMessageEncoding.label": "LWT Message Encoding",
												"property.lwtMessageEncoding.desc": "Encoding used the transform LWT message String to payload.",
												"property.lwtMessageEncoding.options.UTF-8": "UTF-8",
												"property.lwtMessageEncoding.options.GB2312": "GB2312",
												"property.lwtMessageEncoding.options.GBK": "GBK",
												"property.lwtMessageEncoding.options.UTF-16": "UTF-16",
												"property.lwtMessageEncoding.options.UTF-16BE": "UTF-16BE",
												"property.lwtMessageEncoding.options.UTF-16LE": "UTF-16LE",
												"property.lwtMessageEncoding.options.UTF-32": "UTF-32",
												"property.lwtMessageEncoding.options.UTF-32BE": "UTF-32BE",
												"property.lwtMessageEncoding.options.UTF-32LE": "UTF-32LE",
												"property.lwtMessageControl.label": "LWT Message Converter",
												"property.lwtMessageControl.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
												"property.lwtMessageControl.data.default": "Default",
												"property.lwtMessageControl.data.custom": "Custom",
												"property.lwtMessageControl.data.none": "None",
												"property.lwtTopic.label": "LWT Topic",
												"property.lwtTopic.desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
												"property.lwtMessageRetained.label": "LWT Message Retained",
												"property.lwtMessageRetained.desc": "Specified whether retained flag will be set for LWT Message.",
												"property.messageConverterScript.label": "Message Converter Script",
												"property.messageConverterScript.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
												"property.lwtMessageConverterScript.label": "LWT Message Converter Script",
												"property.lwtMessageConverterScript.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
												"property.host.label": "Host",
												"property.password.label": "Password",
												"property.password.desc": "The password to use for the connection.",
												"property.userName.label": "User Name",
												"property.userName.desc": "The user name to use for the connection.",
												"property.port.label": "Port",
												"property.serverURI.label": "Server URI",
												"property.serverURI.desc": "The mqtt server which this component will connect to.",
												"property.serverURI.title": " ",
												"property.serverURI.columns.protocol.label": "Protocol",
												"property.serverURI.columns.protocol.options.tcp": "TCP",
												"property.serverURI.columns.protocol.options.ssl": "SSL",
												"property.serverURI.columns.host.label": "Host",
												"property.serverURI.columns.port.label": "Port"
											}
										},
										"_pid": "d16711d9-352a-482b-8402-433f6e25203f"
									},
									"_cid": "70986fc3-d566-4b93-8982-304559e6a667",
									"name": "value"
								}
							}
						},
						{
							"editorType": "script",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "messageConverterScript",
							"label": "Message Converter Script",
							"desc": "Customized message converter, the message converter will convert a message from byte array to string.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "messageConverterControl",
							"controlValue": "custom",
							"value": "",
							"constraints": {
								"type": "script",
								"args": {
									"scriptMode": "scala",
									"scriptSection": "true",
									"helpContent": "spark/block/MQTTSource/help/messageconverter.json",
									"bodyTemplate": "spark/block/MQTTSource/help/messageconverter.js",
									"header": "false"
								}
							}
						},
						{
							"editorType": "boolean",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "cleanSession",
							"label": "Clean Session",
							"desc": "Specify whether mqtt broker will remember state across reconnects of client.",
							"type": "boolean",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"value": "true"
						},
						{
							"editorType": "radio",
							"*": {
								"label": "label",
								"desc": "desc",
								"data.default": "constraints.args.data.0.label",
								"data.custom": "constraints.args.data.1.label",
								"data.none": "constraints.args.data.2.label"
							},
							"group": "common",
							"name": "lwtMessageControl",
							"label": "LWT Message Converter",
							"desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "",
							"value": "none",
							"constraints": {
								"type": "input",
								"args": {
									"inputType": "radio",
									"data": [
										{
											"value": "default",
											"label": "Default"
										},
										{
											"value": "custom",
											"label": "Custom"
										},
										{
											"value": "none",
											"label": "None"
										}
									],
									"itemStyle": "width:300px;"
								}
							}
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "lwtTopic",
							"label": "LWT Topic",
							"desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "lwtMessageControl",
							"controlValue": "default,custom"
						},
						{
							"editorType": "textInput",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "lwtMessage",
							"label": "LWT Message",
							"desc": "The content of LWT Message.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "lwtMessageControl",
							"controlValue": "default"
						},
						{
							"editorType": "sparkSelect",
							"*": {
								"label": "label",
								"desc": "desc",
								"options.UTF-8": "constraints.args.options.0.label",
								"options.GB2312": "constraints.args.options.1.label",
								"options.GBK": "constraints.args.options.2.label",
								"options.UTF-16": "constraints.args.options.3.label",
								"options.UTF-16BE": "constraints.args.options.4.label",
								"options.UTF-16LE": "constraints.args.options.5.label",
								"options.UTF-32": "constraints.args.options.6.label",
								"options.UTF-32BE": "constraints.args.options.7.label",
								"options.UTF-32LE": "constraints.args.options.8.label"
							},
							"group": "common",
							"name": "lwtMessageEncoding",
							"label": "LWT Message Encoding",
							"desc": "Encoding used the transform LWT message String to payload.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": true,
							"controlName": "lwtMessageControl",
							"controlValue": "default",
							"value": "UTF-8",
							"constraints": {
								"type": "sparkSelect",
								"args": {
									"options": [
										{
											"label": "UTF-8",
											"value": "UTF-8"
										},
										{
											"label": "GB2312",
											"value": "GB2312"
										},
										{
											"label": "GBK",
											"value": "GBK"
										},
										{
											"label": "UTF-16",
											"value": "UTF-16"
										},
										{
											"label": "UTF-16BE",
											"value": "UTF-16BE"
										},
										{
											"label": "UTF-16LE",
											"value": "UTF-16LE"
										},
										{
											"label": "UTF-32",
											"value": "UTF-32"
										},
										{
											"label": "UTF-32BE",
											"value": "UTF-32BE"
										},
										{
											"label": "UTF-32LE",
											"value": "UTF-32LE"
										}
									],
									"needPlaceholder": false,
									"multiple": false,
									"enumDyn": true,
									"context": {
										"i18n": {
											"default": {
												"property.sample.label": "Sample Data",
												"property.cleanSession.label": "Clean Session",
												"property.cleanSession.desc": "Specify whether mqtt broker will remember state across reconnects of client.",
												"block.group.group": "Server URI",
												"property.topicLabel.label": "",
												"property.a.label": "a",
												"property.a.options.a": "a",
												"property.a.options.b": "b",
												"property.topicValue.label": "",
												"property.trustStorePassword.label": "Trust Store Password",
												"property.trustStorePassword.desc": "Password of TrustStore.",
												"property.keyStorePassword.label": "Key Store Password",
												"property.keyStorePassword.desc": "Password of Key Store.",
												"property.keyAlias.label": "Key Alias",
												"property.keyAlias.desc": "Specify which certification in Key Store will be used for SSL.",
												"property.filePath.label": "File Path",
												"property.protocol.label": "Protocol",
												"property.protocol.options.tcp": "TCP",
												"property.protocol.options.ssl": "SSL",
												"property.clientID.label": "Client ID",
												"property.clientID.desc": "Client ID.",
												"property.topics.label": " ",
												"property.topics.desc": "Identify the topics that mqttSource subscribe to.",
												"property.topics.title": " Topics",
												"property.topics.columns.topicValue.label": " ",
												"property.messageConverterControl.label": "Message Converter",
												"property.messageConverterControl.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
												"property.messageConverterControl.data.default": "Default",
												"property.messageConverterControl.data.custom": "Custom",
												"property.lwtMessage.label": "LWT Message",
												"property.lwtMessage.desc": "The content of LWT Message.",
												"property.trustStore.label": "Trust Store",
												"property.trustStore.desc": "Trust Store File.",
												"property.trustStore.title": " ",
												"property.trustStore.columns.type.label": " Type",
												"property.trustStore.columns.type.options.hdfs": "HDFS",
												"property.trustStore.columns.type.options.localFile": "Local File",
												"property.trustStore.columns.type.options.sparkFile": "Spark File",
												"property.trustStore.columns.filePath.label": "File Path",
												"property.type.label": "Type",
												"property.type.options.hdfs": "HDFS",
												"property.type.options.localFile": "Local File",
												"property.type.options.sparkFile": "Spark File",
												"property.keyStore.label": "Key Store",
												"property.keyStore.desc": "Key Store file.",
												"property.keyStore.title": " ",
												"property.keyStore.columns.type.label": "Type",
												"property.keyStore.columns.type.options.hdfs": "HDFS",
												"property.keyStore.columns.type.options.localFile": "Local File",
												"property.keyStore.columns.type.options.sparkFile": "Spark File",
												"property.keyStore.columns.filePath.label": "File Path",
												"property.encoding.label": "Encoding",
												"property.encoding.desc": "Encoding used the transform message playload to String.",
												"property.encoding.options.UTF-8": "UTF-8",
												"property.encoding.options.GB2312": "GB2312",
												"property.encoding.options.GBK": "GBK",
												"property.encoding.options.UTF-16": "UTF-16",
												"property.encoding.options.UTF-16BE": "UTF-16BE",
												"property.encoding.options.UTF-16LE": "UTF-16LE",
												"property.encoding.options.UTF-32": "UTF-32",
												"property.encoding.options.UTF-32BE": "UTF-32BE",
												"property.encoding.options.UTF-32LE": "UTF-32LE",
												"property.lwtMessageEncoding.label": "LWT Message Encoding",
												"property.lwtMessageEncoding.desc": "Encoding used the transform LWT message String to payload.",
												"property.lwtMessageEncoding.options.UTF-8": "UTF-8",
												"property.lwtMessageEncoding.options.GB2312": "GB2312",
												"property.lwtMessageEncoding.options.GBK": "GBK",
												"property.lwtMessageEncoding.options.UTF-16": "UTF-16",
												"property.lwtMessageEncoding.options.UTF-16BE": "UTF-16BE",
												"property.lwtMessageEncoding.options.UTF-16LE": "UTF-16LE",
												"property.lwtMessageEncoding.options.UTF-32": "UTF-32",
												"property.lwtMessageEncoding.options.UTF-32BE": "UTF-32BE",
												"property.lwtMessageEncoding.options.UTF-32LE": "UTF-32LE",
												"property.lwtMessageControl.label": "LWT Message Converter",
												"property.lwtMessageControl.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
												"property.lwtMessageControl.data.default": "Default",
												"property.lwtMessageControl.data.custom": "Custom",
												"property.lwtMessageControl.data.none": "None",
												"property.lwtTopic.label": "LWT Topic",
												"property.lwtTopic.desc": "If specified willtopic, when the client disconnected unexpectedly, MQTT server will publish a mess to the specified topic.",
												"property.lwtMessageRetained.label": "LWT Message Retained",
												"property.lwtMessageRetained.desc": "Specified whether retained flag will be set for LWT Message.",
												"property.messageConverterScript.label": "Message Converter Script",
												"property.messageConverterScript.desc": "Customized message converter, the message converter will convert a message from byte array to string.",
												"property.lwtMessageConverterScript.label": "LWT Message Converter Script",
												"property.lwtMessageConverterScript.desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
												"property.host.label": "Host",
												"property.password.label": "Password",
												"property.password.desc": "The password to use for the connection.",
												"property.userName.label": "User Name",
												"property.userName.desc": "The user name to use for the connection.",
												"property.port.label": "Port",
												"property.serverURI.label": "Server URI",
												"property.serverURI.desc": "The mqtt server which this component will connect to.",
												"property.serverURI.title": " ",
												"property.serverURI.columns.protocol.label": "Protocol",
												"property.serverURI.columns.protocol.options.tcp": "TCP",
												"property.serverURI.columns.protocol.options.ssl": "SSL",
												"property.serverURI.columns.host.label": "Host",
												"property.serverURI.columns.port.label": "Port"
											}
										},
										"_pid": "d16711d9-352a-482b-8402-433f6e25203f"
									},
									"_cid": "c8e2ff80-e15f-4f9e-862f-6e3c7c60f7b3",
									"name": "value"
								}
							}
						},
						{
							"editorType": "script",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "lwtMessageConverterScript",
							"label": "LWT Message Converter Script",
							"desc": "Customized message converter, the message converter will convert LWT message from a string to a byte array.",
							"type": "string",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "lwtMessageControl",
							"controlValue": "custom",
							"value": "",
							"constraints": {
								"type": "script",
								"args": {
									"scriptMode": "scala",
									"scriptSection": "true",
									"helpContent": "spark/block/MQTTSource/help/lwtMessageconverter.json",
									"bodyTemplate": "spark/block/MQTTSource/help/lwtMessageconverter.js",
									"header": "false"
								}
							}
						},
						{
							"editorType": "boolean",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "lwtMessageRetained",
							"label": "LWT Message Retained",
							"desc": "Specified whether retained flag will be set for LWT Message.",
							"type": "boolean",
							"optional": true,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "false",
							"escapeValue": false,
							"controlName": "lwtMessageControl",
							"controlValue": "default,custom",
							"value": "false"
						},
						{
							"editorType": "sourceSample",
							"*": {
								"label": "label",
								"desc": "desc"
							},
							"name": "sample",
							"label": "Sample Data",
							"type": "string",
							"optional": false,
							"hidden": "false",
							"disabled": false,
							"impactSchema": "true",
							"escapeValue": false,
							"constraints": {
								"type": "sourceSample",
								"args": {
									"rows": "4",
									"itemStyle": "height: auto;width: calc(100% - 54px);"
								},
								"impactSchema": true
							},
							"excluded": true
						}
					],
					"dependent": true,
					"key": "ADF_MQTT",
					"group": "Source",
					"desc": "block.desc"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 0,
				"sourceMaxCount": 0,
				"dataTypeEditable": false,
				"_index": 0,
				"legacyFunction": false,
				"uiController": {
					"_scriptText": "//# sourceURL=MQTTSource_Controller.js\n\r\nvar controller = {};\r\n\r\n/*** Add shared javaScript functions here **/\r\n/*** End ***/\r\n\r\n/** Set default value for model properties if needed **/\r\ncontroller.onInitialized = function(flowModel, model) {\r\n    // \"model.properties\" contain all properties\r\n};\r\n\r\n/** When the building block is copied, we hope some internal ID should be different from the original value \r\n *  Override this API to update model.properties if needed\r\n **/\r\ncontroller.updateOnPasted = function(flowModel, model) {\r\n};\r\n\r\n/**\r\n * Check property status per source schema or model definition.\r\n * In some case, some property should be hidden with some condition.\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n * @return a list of names like [{name: \"property\", visible: true}, {name: \"property2\", visible: false}]\r\n *\r\n */\r\ncontroller.checkPropertyStatus = function(flowModel, model, propertyDef) {\r\n    var status = [];\r\n    var pro = model.properties.serverURI[0].protocol;\r\n    if (pro == \"ssl\") {\r\n        status.push({name: \"trustStore\", visible: true});\r\n        status.push({name: \"trustStorePassword\", visible: true});\r\n        status.push({name: \"keyStore\", visible: true});\r\n        status.push({name: \"keyStorePassword\", visible: true});\r\n        status.push({name: \"keyAlias\", visible: true});\r\n    } else {\r\n        status.push({name: \"trustStore\", visible: false});\r\n        status.push({name: \"trustStorePassword\", visible: false});\r\n        status.push({name: \"keyStore\", visible: false});\r\n        status.push({name: \"keyStorePassword\", visible: false});\r\n        status.push({name: \"keyAlias\", visible: false});\r\n    }\r\n    return status;\r\n};\r\n\r\n/**\r\n * Enrich property meta data per source schema or model definition\r\n * @param model {sources:[], properties: {}, outputs: []}\r\n * @param propertyDef {name: \"\", label: \"\", type: \"\", constraints: { type: \"\", args: { }}}\r\n *  For example, the property is data grid to edit some mappings, one column in the grid will select a field from source schema;\r\n *  In building block property sheet definition, there is no option for this column. You need to enrich options here\r\n *  for that column, namely propertyDef.constraints.args.columns[i].options.\r\n */\r\ncontroller.enrichProperty = function(model, propertyDef) {\r\n};\r\n\r\n/**\r\n *  Overide this API to handle property change event. You can show/hide other properties here\r\n * @param model\r\n * @param propertyDef\r\n * @param event {name: \"property1\", oldValue: \"v1\", newValue: \"v2\"}\r\n */\r\ncontroller.propertyChanged = function(model, propertyDef, event) {\r\n};\r\n\r\n//__CODING_START__:getOutputNames\r\n/** When you have multiple output ports, you may want to customize port name \r\n *  Override this method to return multiple output names\r\n * @return a list of names like [\"baseCurrent\", \"baseSnapshot\"]\r\n **/\r\ncontroller.getOutputNames = function(flowModel, model) {\r\n    var names = [];\r\n    return names;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputSchema\r\n/** The framework will invoke this API to generate new schema when some properties are changed \r\n *  Only the property marked \"true\" on \"impactSchema\" attribute will trigger it.\r\n * @return a list of field {name: \"\", type: \"\", isArray: false, isOptional: false, clazz: \"\", generateType: true}\r\n **/\r\ncontroller.getOutputSchema = function(flowModel, model, outputName) {\r\n    var schema = []; // [{name:\"field1\", type:\"string\", isOptional:false, isArray:false}]\r\n    schema.push({name:\"data\", type:\"string\", isOptional:false, isArray:false});\r\n    return schema;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:getOutputDataType\r\n/** \r\n * @return Scala signature of output result. Override it if you will generate case class internally for output schema\r\n *   If it is tuple please use format like (String, Long, String),\r\n *   If it is case class use format like class:OrderClass\r\n * \r\n **/\r\ncontroller.getOutputDataType = function(flowModel, model, outputName) {\r\n    var dataType = \"\"; // \"class:CaseName\" or tuple like \"(String, Long)\"\r\n    dataType = \"String\";\r\n    return dataType;\r\n};\r\n//__CODING_END__\r\n\r\n//__CODING_START__:validate\r\n/**\r\n * Validate properties of the building block, and collect warning or error into logs\r\n * @param flowModel flow model definition,\r\n * @param model model definition of building block (contains \"sources\", \"outputs\", \"properties\")\r\n * @param logs validation logs\r\n * @param context {category: \"\", nodeId: \"\"}\r\n * Append validation entry into logs with keys (context, message, type and realType)\r\n *     logs.push({\r\n *          context : context,\r\n *          message  : \"\",\r\n *          realType : \"Error\",\r\n *          type     : \"Error\"\r\n *      });\r\n **/\r\ncontroller.validate = function(flowModel, model, logs, context) {\r\n    var host = model.properties.serverURI[0].host;\r\n    if (host === null || host.trim().length == 0) {\r\n        logs.push({\r\n            context : context,\r\n            message  : \"Property \\\"Host\\\" is required, please configure it.\", \r\n            realType : \"Error\", \r\n            type : \"Error\"});\r\n    }\r\n    var port = model.properties.serverURI[0].port;\r\n    if (port === null || port.trim().length == 0) {\r\n        logs.push({\r\n            context : context,\r\n            message  : \"Property \\\"Port\\\" is required, please configure it.\", \r\n            realType : \"Error\", \r\n            type     : \"Error\"});\r\n    }\r\n    var topic = model.properties.topics[0].topicValue;\r\n    if (topic === null || topic.trim().length == 0) {\r\n        logs.push({\r\n            context : context,\r\n            message  : \"Property \\\"Topics\\\" is required, please configure it.\", \r\n            realType : \"Error\", \r\n            type     : \"Error\"});\r\n    }\r\n};\r\n//__CODING_END__\r\n\r\nreturn controller;\r\n",
					"_funcName": "MQTTSource",
					"_args": "\"_args\"",
					"uiController": {}
				}
			},
			"Unknown": {
				"funcDef": {
					"name": "Unknown",
					"helper": "spark/flow/helpers/Unknown",
					"widget": "spark/pipe/widgets/ScalaFunctionWidget",
					"displayName": "Unknown",
					"desc": "Unknown building block",
					"group": "Unknown",
					"image": "/vitria-oi/app/spark/html/images/functions/icon_source_batch.png"
				},
				"initialConfig": {},
				"outputMinCount": 1,
				"outputMaxCount": 1,
				"sourceMinCount": 1,
				"sourceMaxCount": 1,
				"dataTypeEditable": false,
				"_index": 0
			}
		}
	},
	"spark.debug": {
		"list": [
			{
				"name": "InspectOutput",
				"type": [
					"Inspect"
				],
				"helper": "spark/debug/helpers/InspectOutputHelper",
				"editor": "spark/debug/editors/InspectOutputEditor",
				"viewer": "spark/debug/viewers/InspectOutputViewer",
				"displayName": "Inspect Output",
				"desc": "debug.inspect.desc",
				"group": "Inspect",
				"groupLabel": "Inspect",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_inspect.png",
				"group.backgroundColor": "95,111,161",
				"group.labelColor": "95,111,161"
			},
			{
				"name": "InspectHive",
				"type": [
					"Inspect"
				],
				"helper": "spark/debug/helpers/InspectHiveHelper",
				"editor": "spark/debug/editors/InspectHiveEditor",
				"viewer": "spark/debug/viewers/InspectHiveViewer",
				"displayName": "Inspect Hive",
				"desc": "debug.inspect.desc",
				"group": "Inspect",
				"groupLabel": "Inspect",
				"image": "/vitria-oi/app/spark/html/images/functions/icon_inspect.png",
				"group.backgroundColor": "95,111,161",
				"group.labelColor": "95,111,161"
			}
		],
		"maps": {}
	}
};

]]>
        </CodeText>
      </Function>
      <Function name="nameConstraints" args="" private="false">
        <CodeText>
          <![CDATA[const patternContent = '[_a-zA-Z]([- _a-zA-Z0-9]{0,31})'
return {
    svc : {
        pattern : '^' + patternContent + '$',
        patternContent : patternContent,
        patternMismatch  : "Service can start with a letter or underscores, only contains \"a-z A-Z 0-9 _-\" and have a limit of 32 characters.",
    },
    
    comp : {
        pattern : '^' + patternContent + '$',
        patternContent : patternContent,
        patternMismatch  : "Sub Service can start with a letter or underscores, only contains \"a-z A-Z 0-9 _-\" and have a limit of 32 characters.",
    },
    
    app : {
        pattern : '^' + patternContent + '$',
        patternContent : patternContent,
        patternMismatch  : "Component can start with a letter or underscores, only contains \"a-z A-Z 0-9 _-\" and have a limit of 32 characters.",
    }
};

//Bugs : SOB-146]]>
        </CodeText>
      </Function>
      <Function name="openBatchProcessDialog" args="okCallback" private="false">
        <CodeText>
          <![CDATA[var self = this;
require(["af/controls/MaximizableAppDialog",
         "af/controls/ButtonMode",
         "af/utils/I18N",
         "ax/flow/utils/FormUtil",
         "dojo/dom-geometry",
         "dojo/dom-style",
         "dojo/dom-class",
         "dojo/dom-attr",
         "dojo/dom-construct",
         "dojo/on",
         "dojo/domReady!"],
function(MaximizableAppDialog, ButtonMode, I18N, FormUtil, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    var dialog = new MaximizableAppDialog({
        title    : "Batch Process",
        vtWidth  : 300,
        vtHeight : 150,
    });
    dialog.showTitle = true;
    dialog.set("okLabel", "OK");
    dialog.okHandler = function() {
        this.hide();
        okCallback(this.value);
    };
    dialog.show();
    domStyle.set(dialog.containerNode, {
        "width"    : "100%",
        "height"   : "100%",
        "overflow" : "hidden"
    });
    // hide maximize button
    domStyle.set(dialog.resizeBtn, "display", "none");
    
    var table = domConstruct.create("table", {
        style       : "width:100%;height:100%;border:none;",
        cellspacing : "5",
    });
    dialog.containerNode.appendChild(table);

    var tr = domConstruct.create("tr");
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:12pt;padding-right:5px;",
    });
    td.innerHTML = "From Date:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;",
    });
    dialog.fromDate = FormUtil.createDateTextBox("fromDate", td, null, "width:100%;height:auto;font-size:12pt;", null, null);
    tr.appendChild(td);

    var tr = domConstruct.create("tr");
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:12pt;padding-right:5px;",
    });
    td.innerHTML = "To Date:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;",
    });
    dialog.toDate = FormUtil.createDateTextBox("toDate", td, null, "width:100%;height:auto;font-size:12pt;", null, null);
    tr.appendChild(td);
});
]]>
        </CodeText>
      </Function>
      <Function name="openCountMetricDialog" args="item,schema,okCallback" private="false">
        <CodeText>
          <![CDATA[var metricName  = "";
var metricLabel = "";
var fieldName   = "";
var matchValues = "";

if (item != null) {
    metricName  = item.metricName;
    metricLabel = item.metricLabel || "";
    fieldName   = item.fieldName;
    matchValues = item.matchValues;
}

var useAttrType = false;
for (var i=0; i<schema.length; i++) {
    var field = schema[i];
    if (field.attr_type != null) {
        useAttrType = true;
        break;
    }
}

var fieldList = [];
for (var i=0; i<schema.length; i++) {
    var field = schema[i];
    if (!field.ignore && (useAttrType && field.attr_type == "dimension") || (!useAttrType && field.data_type == "string")) {
        fieldList.push({
            value : field.name,
            label : field.label,
        });
    }
}

var self = this;
require(["af/controls/MaximizableAppDialog",
         "af/controls/ButtonMode",
         "af/utils/AppUtil",
         "af/utils/I18N",
         "ax/flow/utils/FormUtil",
         "af/viewers/ViewerUtil",
         "dijit/form/MultiSelect",
         "dojo/dom-geometry",
         "dojo/dom-style",
         "dojo/dom-class",
         "dojo/dom-attr",
         "dojo/dom-construct",
         "dojo/on",
         "dojo/domReady!"],
function(MaximizableAppDialog, ButtonMode, AppUtil, I18N, FormUtil, ViewerUtil, MultiSelect, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    
    function createMultiSelect(dialog, selectedFieldName, selectedFieldValues)
    {
        if (dialog.matchValuesWidget != null) {
            dialog.matchValuesWidget.destroy();
            dialog.matchValuesWidget = null;
        }
        AppUtil.removeAllChildrenOf(dialog.matchValuesTD);

        var select = domConstruct.create("select", {
            style : "height:100%;font-size:12pt;"
        });
        dialog.matchValuesTD.appendChild(select);
        if (selectedFieldName != "") {
            for (var i=0; i<schema.length; i++) {
                var field = schema[i];
                if (field.name == selectedFieldName) {
                    if (field.data_type == "long" || field.data_type == "float" || field.data_type == "double") {
                        field.meta_data.enums.sort(function (A, B) {
                            return Number(A) - Number(B);
                        });
                    } else {
                        field.meta_data.enums.sort();
                    }
                    for (var j=0; j<field.meta_data.enums.length; j++) {
                        var option = domConstruct.create("option", {
                            style : "padding:5px 3px;"
                        });
                        option.innerHTML = field.meta_data.enums[j];
                        option.value = field.meta_data.enums[j];
                        select.appendChild(option);
                    }
                    break;
                }
            }
        }
        dialog.matchValues = new MultiSelect({ name: "matchValues" }, select);
        dialog.matchValues.startup();
        domClass.add(dialog.matchValues.domNode, "via-scroller");
        domStyle.set(dialog.matchValues.domNode, {
            "height" : "120px",
            "font-size" : "12pt",
        });
        dialog.matchValues.set("value", selectedFieldValues);
    }
    
    function setSelectStyle(select)
    {
        var span = select.domNode;
        while (span != null) {
            if (span.nodeName == "SPAN") {
                domStyle.set(span, {
                    "font-size" : "12pt",
                });
                break;
            }
            span = span.firstElementChild;
        }
    }

    var dialog = new MaximizableAppDialog({
        title    : "Count Metric",
        vtWidth  : 400,
        vtHeight : 280,
    });
    dialog.showTitle = true;
    dialog.set("okLabel", "OK");
    dialog.okHandler = function() {
        this.domNode.classList.toggle('okRejectDialog', !this.metricName.isValid());
        if(this.metricName.isValid() == false){
            this.metricName.focus();
            return;
        }
        
        this.value.metricName = this.metricName.value;
        this.value.metricLabel = this.metricLabel.value;
        try{
            this.hide();
            okCallback(this.value);
        }finally{
            document.head.removeChild(dialogStyle);
        }
    };
    dialog.cancelHandler = function(){
        document.head.removeChild(dialogStyle);
    };
    
    dialog.domNode.classList.add('countMetricDialog');
    var dialogStyle = document.createElement('style');
    dialogStyle.type = 'text/css';
    dialogStyle.textContent = ".app .countMetricDialog .dijitValidationContainer{ display : none } \n"
    + ".app .countMetricDialog.okRejectDialog .saveButton{  opacity : 0.3; cursor : default; }";
    document.head.append(dialogStyle);
    
    dialog.show();
    domStyle.set(dialog.containerNode, {
        "width"    : "100%",
        "height"   : "100%",
        "overflow" : "hidden"
    });
    // hide maximize button
    domStyle.set(dialog.resizeBtn, "display", "none");
    
    var table = domConstruct.create("table", {
        style       : "width:100%;border:none;",
        cellspacing : "5",
    });
    dialog.containerNode.appendChild(table);


    var tr = domConstruct.create("tr");
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:10pt;padding-right:5px;",
    });
    td.innerHTML = "Metric Name:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;padding:0px 2px 0px 1px;",
    });

    dialog.metricName = ViewerUtil.createControlValidationTextBox("metricName", "[a-zA-Z0-9_\\- ]+", metricName, null, null, "width:100%;height:auto;font-size:12pt;", true);
    td.appendChild(dialog.metricName.domNode);
    tr.appendChild(td);
    
    var tr = domConstruct.create("tr");
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:10pt;padding-right:5px;",
    });
    td.innerHTML = "Metric Label:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;padding:0px 2px 0px 1px;",
    });

    dialog.metricLabel = ViewerUtil.createControlValidationTextBox("metricName", "[a-zA-Z0-9_\\- ]+", metricLabel, null, null, "width:100%;height:auto;font-size:12pt;", true);
    td.appendChild(dialog.metricLabel.domNode);
    tr.appendChild(td);

    var tr = domConstruct.create("tr");
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:10pt;padding-right:5px;",
    });
    td.innerHTML = "Field Name:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;",
    });
    dialog.fieldName = FormUtil.createSingleSelect("fieldName", td, fieldList, fieldName,
                                                   "width:100%;height:auto;font-size:12pt;border:thin solid lightgray;padding:2px 0px 2px 0px !important;",
                                                   null, lang.partial(function(dialog, schema, prop) {
        setSelectStyle(dialog.fieldName);
        createMultiSelect(dialog, prop.value, "");
    }, dialog, schema));
    tr.appendChild(td);
    setSelectStyle(dialog.fieldName);


    var tr = domConstruct.create("tr", {
        style : "vertical-align:top;"
    });
    table.appendChild(tr);
    
    var td = domConstruct.create("td", {
        style : "white-space:nowrap;font-size:10pt;padding-right:5px;height:120px;",
    });
    td.innerHTML = "Match Values:";
    tr.appendChild(td);
    
    var td = domConstruct.create("td", {
        style : "width:100%;height:120px;",
    });
    dialog.matchValuesTD = td;
    tr.appendChild(td);

    createMultiSelect(dialog, fieldName, matchValues);
    if (fieldName != "") {
    }
});


]]>
        </CodeText>
      </Function>
      <Function name="openProjectDialog" args="controller,StatusService,CommonPlugin,title,callback" private="false">
        <CodeText>
          <![CDATA[var self = this;
var projects = [];

CommonPlugin.popupDialog(title, 700, 400, false, function(dialog, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    
    function onSelect(evt) {
        if (evt.type == "dgrid-select") {
            dialog.value = evt.rows[0].data;
        }
        else if (evt.type == "dgrid-deselect") {
            dialog.value = null;
        }
        dialog.setOkButtonEnable(dialog.value != null);
    }
    
    require(["af/utils/GridUtil"], function(GridUtil) {
        var div = domConstruct.create("div", {
            "class" : "via-scroller",
            "style" : 'display : flex; flex-direction : column; height : 100%'
        });
        dialog.containerNode.appendChild(div);
        
        var dgridDiv = domConstruct.create("div", {
            "style" : "flex : 1 1 auto" 
        });
        div.append(dgridDiv);
        
        CommonPlugin.pbShowProgressBar("listProjects", "Retrieving list of projects...");
        self.listProjectPickerList(function(response) {
            if (response.status == "OK") {
                projects = response.value;
                var columns = [{
                    field : "prjName",
                    label : "Project Name",
                    style : "font-family:monospace;cursor:pointer;",
                    sortable : true,
                },  {
                    field : "uuid",
                    label : "UUID",
                    style : "",
                    renderCell: function (object, value, node) {
                        StatusService.showNotificationToElement(controller, {uuid: value}, node);
                    }
                }];
                var store = GridUtil.createGridStore("prjName", projects);
                var grid = GridUtil.createGridWidget("Projects", dgridDiv, false, null, columns, store,
                                                     onSelect, null, "single", onSelect, null);
                grid.set('sort', 'prjName');
                div.insertBefore(self.createProjectFilterBar( grid, store), dgridDiv);
            }
            CommonPlugin.pbHideProgressBar("listProjects");
        })
    });

    dialog.setOkButtonEnable(false);

}, invokeCallback, "OK");

function invokeCallback(project){
    project.referenceProjects = projects.filter(p => p.anomalyReference === project.prjName);
    callback(project);
}]]>
        </CodeText>
      </Function>
      <Function name="openResetOptionDialog" args="CommonPlugin,title,message,callback" private="false">
        <CodeText>
          <![CDATA[var resetOption = {
    resetParserModel: true,
    resetParserSource: true,
    resetParserTarget: true,
    resetAnomalyModel: true,
    resetDataResourceModel: true,
    resetSystemModel: true,
};
CommonPlugin.popupDialog(title, 400, 300, false, function(dialog, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    require(["dojo/_base/lang", "ax/flow/utils/FormUtil"], function(lang, FormUtil) {
        var messageDiv = domConstruct.create("div", {
            "style" : "padding:10px;font-size: 16px; padding-bottom:20px",
            innerHTML : message
        });
        
        dialog.containerNode.appendChild(messageDiv);

        function onValueChanged (evt) {
            resetOption.resetParserModel = dialog.resetParserCheckBox.get("checked");
            resetOption.resetParserSource = dialog.resetParserSourceCheckBox.get("checked");
            resetOption.resetParserTarget = dialog.resetParserTargetCheckBox.get("checked");
            resetOption.resetAnomalyModel = dialog.resetAnomalyCheckBox.get("checked");
            resetOption.resetDataResourceModel = dialog.resetDataResourceCheckBox.get("checked");
            resetOption.resetSystemModel = dialog.resetSystemCheckBox.get("checked");
        };
        
        dialog.resetParserCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetParserCheckBox", 
                                                    "Reset Parser Model", onValueChanged, 0);

        dialog.resetParserSourceCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetParserSourceCheckBox", 
                                                    "Reset Source Folder", onValueChanged, 20);
        
        dialog.resetParserTargetCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "onResetParserTargetChanged", 
                                                    "Reset Target Folder", onValueChanged, 20);                                            

        dialog.resetAnomalyCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetAnomalyCheckBox", 
                                                    "Reset Anomaly Model", onValueChanged, 0);
                                                    
        dialog.resetDataResourceCheckBox =  createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetDataResourceCheckBox", 
                                                    "Reset Data Resource Model", onValueChanged, 0);                                                    
                                                    
        dialog.resetSystemCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetSystemCheckBox", 
                                                    "Reset System Model", onValueChanged, 0);                                          
                                                    
        
    });
}, invokeCallback, "OK");

function createCheckBox(FormUtil, domConstruct, parent, id, label, onChange, indent) {
    var padding = 10 + indent;
    var div = domConstruct.create("div", {
       "style" : "width: calc(100% - " + padding +"px);line-height:22px;" + "padding-left:" + padding +"px;"
    });
    
    var checkBox = FormUtil.createCheckBox(id, div, true, label, onChange);
    checkBox.domNode.setAttribute("id", id);
    
    var label = domConstruct.create("label", {
        "for" : id,
        "style" : "padding-left:5px;",
        "innerHTML" : label
    });
    
    div.appendChild(label);
    parent.appendChild(div);
    
    return checkBox;
}

function invokeCallback(){
    callback(resetOption);
}]]>
        </CodeText>
      </Function>
      <Function name="openUpdateOptionDialog" args="CommonPlugin,title,message,callback" private="false">
        <CodeText>
          <![CDATA[var updateOptions = {
    updateParserModel: true,
    resetParserSource: false,
    resetParserTarget: false,
    purgeParserModel: false,
    updateAnomalyModel: true,
    purgeAnomalyModel: false,
    updateDataResourceModel: true,
    updateSystemModel: true,
    preRelease: true,
}

CommonPlugin.popupDialog(title, 400, 320, false, function(dialog, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    require(["dojo/_base/lang", "ax/flow/utils/FormUtil"], function(lang, FormUtil) {
        var messageDiv = domConstruct.create("div", {
            "style" : "padding:10px;font-size: 16px; padding-bottom:20px",
            innerHTML : message
        });
        
        dialog.containerNode.appendChild(messageDiv);
       
        function onValueChanged (evt) {
            updateOptions.updateParserModel = dialog.updateParserModelCheckBox.get("checked");
            updateOptions.resetParserSource = dialog.resetParserSourceCheckBox.get("checked");
            updateOptions.resetParserTarget = dialog.resetParserTargetCheckBox.get("checked");
            updateOptions.purgeParserModel = dialog.purgeParserModelCheckBox.get("checked");
            updateOptions.updateAnomalyModel = dialog.updateAnomalyModelCheckBox.get("checked");
            updateOptions.purgeAnomalyModel = dialog.purgeAnomalyModelCheckBox.get("checked");
            updateOptions.updateDataResourceModel = dialog.updateDataResourceModelCheckBox.get("checked");
            updateOptions.updateSystemModel = dialog.updateSystemModelCheckBox.get("checked");
            updateOptions.preRelease = dialog.preReleaseCheckBox.get("checked");
        }
        
        dialog.updateParserModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "updateParserModelCheckBox", 
                                                    "Update Parser Model", updateOptions.updateParserModel, onValueChanged, 0);
        dialog.resetParserSourceCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetParserSourceCheckBox", 
                                                    "Reset Parser Source Folder", updateOptions.resetParserSource, onValueChanged, 20);    
        dialog.resetParserTargetCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "resetParserTargetCheckBox", 
                                                    "Reset Parser Target Folder", updateOptions.resetParserTarget, onValueChanged, 20);
        dialog.purgeParserModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "purgeParserModelCheckBox", 
                                                    "Purge Parser Model", updateOptions.purgeParserModel, onValueChanged, 20); 
        dialog.updateAnomalyModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "updateAnomalyModelCheckBox", 
                                                    "Update Anomaly Model", updateOptions.updateAnomalyModel, onValueChanged, 0);
        dialog.purgeAnomalyModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "purgeAnomalyModelCheckBox", 
                                                    "Purge Anomaly Model", updateOptions.purgeAnomalyModel, onValueChanged, 20);
        dialog.updateDataResourceModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "updateDataResourceModelCheckBox", 
                                                    "Update Data Resource Model", updateOptions.updateDataResourceModel, onValueChanged, 0);                                                     
        dialog.updateSystemModelCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "updateSystemModelCheckBox", 
                                                    "Update System Model", updateOptions.updateSystemModel, onValueChanged, 0); 
        dialog.preReleaseCheckBox = createCheckBox(FormUtil, domConstruct, dialog.containerNode, "preReleaseCheckBox", 
                                                    "Pre-Release", updateOptions.preRelease, onValueChanged, 20);                                                      
        
    });
}, invokeCallback, "OK");

function createCheckBox(FormUtil, domConstruct, parent, id, label, value, onChange, indent) {
    var padding = 10 + indent;
    var div = domConstruct.create("div", {
       "style" : "width: calc(100% - " + padding +"px);line-height:22px;" + "padding-left:" + padding +"px;"
    });
    
    var checkBox = FormUtil.createCheckBox(id, div, value, label, onChange);
    checkBox.domNode.setAttribute("id", id);
    
    var label = domConstruct.create("label", {
        "for" : id,
        "style" : "padding-left:5px;",
        "innerHTML" : label
    });
    
    div.appendChild(label);
    parent.appendChild(div);
    
    return checkBox;
}

function invokeCallback(){
    callback(updateOptions);
}]]>
        </CodeText>
      </Function>
    </Functions>
    <Services>
      <Service name="___generatePivotCode" args="schema,pivot,count" private="true">
        <CodeText>
          <![CDATA[//print("___generatePivotCode: pivot="+__prettyPrintJSON(pivot));
//print("___generatePivotCode: schema="+__prettyPrintJSON(schema));

if (pivot.measures && pivot.measures.length != 1) {
    pivot.metric = null;
    delete pivot.metric;
}

var pivotCode = [];

//support covert date to timestamp type
pivotCode.push("implicit def date2timestamp(date: java.util.Date) = ");
pivotCode.push("    new java.sql.Timestamp(date.getTime)")

var duplicateMetric = 1;
if (pivot.metric != null && pivot.pivot != null) {
    var metricMap = {};
    pivot.pivot.forEach(function(item) {
        if (!metricMap[item.__source_metric_name__]) {
            metricMap[item.__source_metric_name__] = [item.__target_metric_name__];
        } else if (metricMap[item.__source_metric_name__].indexOf(item.__target_metric_name__) == -1) {
            metricMap[item.__source_metric_name__].push(item.__target_metric_name__);
            duplicateMetric = Math.max(duplicateMetric, metricMap[item.__source_metric_name__].length);
        }
    });
    for (var d = 0;  d < duplicateMetric; d++) {
        var dMap = {};
        pivotCode.push("val metricNameMap" + d + " = new java.util.HashMap[String, String]()");
        for (var j=0, jN=pivot.pivot.length; j<jN; j++) {
            var item = pivot.pivot[j];
            if (d < metricMap[item.__source_metric_name__].length && !dMap[item.__source_metric_name__]) {
                pivotCode.push("metricNameMap" + d + ".put(\""+item.__source_metric_name__+"\",\""+metricMap[item.__source_metric_name__][d]+"\")");
                dMap[item.__source_metric_name__] = true;
            }
        }
    }
}

pivotCode.push("val retval = source1.flatMap(e => {");
pivotCode.push("    val r = scala.collection.mutable.ArrayBuffer.empty[Pivot]");
var timestmapIncident = "";
switch (pivot.timestamp.data_type) {
    case "datetime":
    case "date":
        // if datetime, we don't need to check as the parse will drop if null or invalid
        break;
    case "long":
    case "double":
        // for long and double, make sure value is > 0... parse will drop null or invalid
        timestmapIncident = "    ";
        pivotCode.push("    if (e."+pivot.timestamp.name+" > 0) {");
        break;
}

var jN = pivot.pivot.length;
if (pivot.metric != null && pivot.pivot != null) {
    jN = duplicateMetric;
}
for (var j=0; j<jN; j++) {
    var record = pivot.pivot[j];
    if (record.__include__ == false) continue;
    
    var columns = [];
    var prefixIncident = "";
    switch (pivot.timestamp.data_type) {
        case "datetime":
        case "date":
            columns.push("e."+pivot.timestamp.name);
            break;
        case "long":
            switch (pivot.unitOfTime) {
                case "second":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"*1000)");
                    break;
                case "millisecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+")");
                    break;
                case "microsecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"/1000)");
                    break;
                case "nanosecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"/1000000)");
                    break;
            }
            break;
        case "double":
            switch (pivot.unitOfTime) {
                case "second":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"*1000).toLong)");
                    break;
                case "millisecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+").toLong)");
                    break;
                case "microsecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"/1000).toLong)");
                    break;
                case "nanosecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"/1000000).toLong)");
                    break;
            }
            break;
    }
    for (var k=0, kN=pivot.dimensions.length; k<kN; k++) {
        var field = pivot.dimensions[k];
        columns.push("e."+field.name);
    }
    if (pivot.metric != null) {
        prefixIncident = "    ";
        if (pivot.metric.optional == true) {
            pivotCode.push(timestmapIncident + "    if (metricNameMap" + j + ".get(e."+record["__metric_column__"]+".getOrElse(\"\")) == null) {");
        } else {
            pivotCode.push(timestmapIncident + "    if (metricNameMap" + j + ".get(e."+record["__metric_column__"]+") == null) {");
        }
        pivotCode.push(timestmapIncident + "        logger.warn(\"Source metric %s is not defined\".format(e." + record["__metric_column__"] + "))");
        pivotCode.push(timestmapIncident + "    } else {");
        // metric-based
        if (pivot.metric.optional == true) {
            columns.push("metricNameMap" + j + ".get(e."+record["__metric_column__"]+'.getOrElse(""))');
        } else {
            columns.push("metricNameMap" + j + ".get(e."+record["__metric_column__"]+")");
        }
        columns.push("e."+record["__metric_value__"]+".getOrElse(0)");
    }
    else if (pivot.measures.length == 0) {
        // event-based
        columns.push("\""+record["__metric_name__"]+"\"");
        columns.push("1");
    }
    else {
        // measure columns
        var scalaTypeMap = {
            "boolean": "Boolean", 
            "integer": "Int", 
            "long": "Long", 
            "float": "Float", 
            "double": "Double"
        };
        columns.push("\""+record["__metric_name__"]+"\"");
        if (record["__data_type__"]) {
            columns.push("e."+record["__metric_value__"]+".getOrElse[" + scalaTypeMap[record["__data_type__"]] + "](0)");
        } else {
            columns.push("e."+record["__metric_value__"]+".getOrElse(0)");
        }
    }
    switch (pivot.timestamp.data_type) {
        case "datetime":
        case "date":
            // if datetime, we don't need to check as the parse will drop if null or invalid
            pivotCode.push(prefixIncident + "    r += Pivot(" + columns.join(",") + ")");
            break;
        case "long":
        case "double":
            // for long and double, make sure value is > 0... parse will drop null or invalid
            pivotCode.push(prefixIncident + "        r += Pivot(" + columns.join(",") + ")");
            break;
    }
    
    if (pivot.metric != null) {
        pivotCode.push(timestmapIncident + "    }");
    }
}
switch (pivot.timestamp.data_type) {
    case "datetime":
    case "date":
        // if datetime, we don't need to check as the parse will drop if null or invalid
        break;
    case "long":
    case "double":
        // for long and double, make sure value is > 0... parse will drop null or invalid
        pivotCode.push("    }");
        break;
}

for (var j=0, jN=count.length; j<jN; j++) {
    var record = count[j];
    var columns = [];
    switch (pivot.timestamp.data_type) {
        case "datetime":
        case "date":
            columns.push("e."+pivot.timestamp.name);
            break;
        case "long":
            switch (pivot.unitOfTime) {
                case "second":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"*1000)");
                    break;
                case "millisecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"*1)");
                    break;
                case "microsecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"/1000)");
                    break;
                case "nanosecond":
                    columns.push("new java.sql.Timestamp(e."+pivot.timestamp.name+"/1000000)");
                    break;
            }
            break;
        case "double":
            switch (pivot.unitOfTime) {
                case "second":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"*1000).toLong)");
                    break;
                case "millisecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"*1).toLong)");
                    break;
                case "microsecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"/1000).toLong)");
                    break;
                case "nanosecond":
                    columns.push("new java.sql.Timestamp((e."+pivot.timestamp.name+"/1000000).toLong)");
                    break;
            }
            break;
    }
    for (var k=0, kN=pivot.dimensions.length; k<kN; k++) {
        var field = pivot.dimensions[k];
        columns.push("e."+field.name);
    }
    columns.push("\""+ (record.encodeMetricName || record.metricName) +"\"");
    columns.push("1");
    var field = this.___getSchemaField(schema, record.fieldName);
    if (field.type == 'boolean') {
        if (field.isOptional) {
            pivotCode.push("    if (Array("+record.matchValues.join(",")+") contains e."+record.fieldName+".getOrElse(\"\"))");
        }
        else {
            pivotCode.push("    if (Array("+record.matchValues.join(",")+") contains e."+record.fieldName+")");
        }
    } else {
        if (field.isOptional) {
            pivotCode.push("    if (Array(\""+record.matchValues.join("\",\"")+"\") contains e."+record.fieldName+".getOrElse(\"\"))");
        }
        else {
            pivotCode.push("    if (Array(\""+record.matchValues.join("\",\"")+"\") contains e."+record.fieldName+")");
        }
    }
    pivotCode.push("        r += Pivot(" + columns.join(",") + ")");
}
pivotCode.push("    r");
pivotCode.push("})");
return pivotCode.join("\n");
]]>
        </CodeText>
      </Service>
      <Service name="___getEnrichmentOutputSchema" args="enrich" private="true">
        <CodeText>
          <![CDATA[var schema = [];
for (var i=0; i<enrich.joinClause.length; i++) {
    var clause = enrich.joinClause[i];
    if (!clause.include && (clause.leftField == null || clause.leftField == "")) continue;
    
    for (var j=0; j<enrich.rightFields.length; j++) {
        var field = enrich.rightFields[j];
        if (field.name == clause.rightColumn) {
            schema.push({
                name        : clause.rightField,
                label       : clause.rightField,
                type        : field.type,
                isArray     : false,
                isOptional  : false,
                clazz       : "",
                isDimension : true,
                isMeasure   : false,
                column      : clause.rightColumn || clause.rightField
            });
            break;
        }
    }
}
return schema;
]]>
        </CodeText>
      </Service>
      <Service name="___getEnrichOutputSchema" args="pivot,enrich" private="true">
        <CodeText>
          <![CDATA[var schema = this.___getLookupOutputSchema(pivot);
for (var i=0; i<enrich.joinClause.length; i++) {
    var clause = enrich.joinClause[i];
    if (clause.include == true) {
        for (var j=0; j<enrich.rightFields.length; j++) {
            var field = enrich.rightFields[j];
            if (field.name == clause.rightColumn) {
                schema.push({
                    name        : clause.rightField,
                    label       : clause.rightField,
                    type        : field.type,
                    isArray     : false,
                    isOptional  : true,
                    clazz       : "",
                    isDimension : true,
                    isMeasure   : false,
                    column      : clause.rightColumn
                });
                break;
            }
        }
    }
}
return schema;
]]>
        </CodeText>
      </Service>
      <Service name="___getEnrichPredicates" args="enrich" private="true">
        <CodeText>
          <![CDATA[var expr = [];
for (var i=0; i<enrich.joinClause.length; i++) {
    var clause = enrich.joinClause[i];
    if (clause.leftField != null && clause.leftField != "") {
        expr.push("source1." + clause.leftField + " = " + "source2." + clause.rightField);
    }
}
return expr.join(" and ");
]]>
        </CodeText>
      </Service>
      <Service name="___getEnrichProjections" args="pivot,enrich" private="true">
        <CodeText>
          <![CDATA[var excludes = {};
for (var i=0; i<enrich.joinClause.length; i++) {
    var clause = enrich.joinClause[i];
    if (clause.include == false) {
        excludes[clause.rightField] = true;
    }
}
var lookupProjections = [];
var lookupOutputSchema = this.___getLookupOutputSchema(pivot);
lookupOutputSchema.forEach(function(field) {
    lookupProjections.push({
        source  : "source1."+field.name,
        name    : field.name,
        level   : 1,
        exclude : false,
    });
});

enrich.joinClause.forEach(function(field) {
    if (excludes[field.rightField] != true) {
        lookupProjections.push({
            source  : "source2."+field.rightField,
            name    : field.rightField,
            level   : 1,
            exclude : false,
        });
    }
});
return lookupProjections;
]]>
        </CodeText>
      </Service>
      <Service name="___getLookupOutputSchema" args="pivot" private="true">
        <CodeText>
          <![CDATA[var lookupOutput = this.___getPivotOutputSchema(pivot);
lookupOutput.push({
    name        : "aggr_func",
    label       : "aggr_func",
    type        : "string",
    isArray     : false,
    isOptional  : false,
    clazz       : "",
    isDimension : true,
    isMeasure   : false,
});
lookupOutput.push({
    name        : "parse_target_app",
    label       : "parse_target_app",
    type        : "string",
    isArray     : false,
    isOptional  : false,
    clazz       : "",
    isDimension : true,
    isMeasure   : false,
});
lookupOutput.push({
    name        : "parse_target_metric",
    label       : "parse_target_metric",
    type        : "string",
    isArray     : false,
    isOptional  : false,
    clazz       : "",
    isDimension : true,
    isMeasure   : false,
});
return lookupOutput;
]]>
        </CodeText>
      </Service>
      <Service name="___getLookupProjections" args="sourceSchema" private="true">
        <CodeText>
          <![CDATA[var lookupProjections = [];
sourceSchema.forEach(function(field) {
    lookupProjections.push({
        source  : "source1."+field.name,
        name    : field.name,
        level   : 1,
        exclude : false,
    });
});
lookupProjections.push({
    source  : "source2.aggr_func",
    name    : "aggr_func",
    level   : 1,
    exclude : false,
});
lookupProjections.push({
    source  : "source2.parse_source_group",
    name    : "parse_source_group",
    level   : 1,
    exclude : true,
});
lookupProjections.push({
    source  : "source2.parse_source_name",
    name    : "parse_source_name",
    level   : 1,
    exclude : true,
});
lookupProjections.push({
    source  : "source2.parse_target_app",
    name    : "parse_target_app",
    level   : 1,
    exclude : false,
});
lookupProjections.push({
    source  : "source2.parse_target_metric",
    name    : "parse_target_metric",
    level   : 1,
    exclude : false,
});
return lookupProjections;
]]>
        </CodeText>
      </Service>
      <Service name="___getMetricList" args="pivot,count" private="true">
        <CodeText>
          <![CDATA[var metricList = [];
var metricMap = {};

function getMetricLabel (metricLabel, metricName) {
    if (metricLabel == null || metricLabel == "") {
        return metricName;
    } else {
        return metricLabel;
    }
}

if (pivot.metric != null) {
    // metric-based
    for (var i=0; i<(pivot.pivot || []).length; i++) {
        var item = pivot.pivot[i];
        if (!metricMap[item.__target_metric_name__]) {
            metricList.push({
                name          : item.__target_metric_name__,
                sourceName    : item.__source_metric_name__,
                label         : getMetricLabel(item.__metric_label__, item.__target_metric_name__),
                value         : item["__metric_value__"],
                uom           : item["__metric_uom__"],
                aggr          : item["__metric_aggr__"],
                ingestionAggr : item["__ingestion_metric_aggr__"],
                include       : item["__include__"]
            });
            metricMap[item.__target_metric_name__] = true;
        }
    }
}
else if (pivot.measures.length == 0) {
    // event-based
    var item = pivot.pivot[0];
    if (item) {
        if (!metricMap[item["__metric_name__"]]) {
            metricList.push({
                name          : item["__metric_name__"],
                sourceName    : item["__metric_name__"],
                label         : getMetricLabel(item["__metric_label__"], item["__metric_name__"]),
                value         : item["__metric_name__"],
                uom           : item["__metric_uom__"],
                aggr          : item["__metric_aggr__"],
                ingestionAggr : item["__ingestion_metric_aggr__"],
                include       : item["__include__"]
            });
            metricMap[item["__metric_name__"]] = true;
        }
    }
}
else {
    // measure columns
    pivot.pivot.forEach(function(item) {
        if (item["__include__"] == true) {
            if (!metricMap[item["__metric_name__"]]) {
                metricList.push({
                    name          : item["__metric_name__"],
                    sourceName    : item["__metric_value__"],
                    label         : getMetricLabel(item["__metric_label__"], item["__metric_name__"]),
                    value         : item["__metric_value__"],
                    uom           : item["__metric_uom__"],
                    aggr          : item["__metric_aggr__"],
                    ingestionAggr : item["__ingestion_metric_aggr__"],
                    include       : item["__include__"]                    
                });
                metricMap[item["__metric_name__"]] = true;
            }
        }
    });
}

for (var i=0; i<count.length; i++) {
    var item = count[i];
    if (!metricMap[item.encodeMetricName || item.metricName]) {
        metricList.push({
            name       : item.encodeMetricName || item.metricName,
            sourceName : item.encodeMetricName || item.metricName,
            label      : getMetricLabel(item.metricLabel, item.metricName),
            value      : item.encodeMetricName || item.metricName,
            uom        : "Count",
            aggr       : "sum",            
        });
        metricMap[item.encodeMetricName || item.metricName] = true;
    }
}

return metricList;
]]>
        </CodeText>
      </Service>
      <Service name="___getNormalizeComputeModel" args="output" private="true">
        <CodeText>
          <![CDATA[var computeModel = [];
for (var i=0, n=output.length; i<n; i++) {
    var item = output[i];
    computeModel.push({
        op         : "sleText",
        field      : "*",
        arg        : "",
        value      : item.expr,
        outputType : item.type,
        alias      : item.name,
        wordWarp   : true,
    });
}
return computeModel;
]]>
        </CodeText>
      </Service>
      <Service name="___getNormalizeOutputSchema" args="output" private="true">
        <CodeText>
          <![CDATA[var outputSchema = [];
for (var i=0, n=output.length; i<n; i++) {
    var item = output[i];
    outputSchema.push({
        name        : item.name,
        label       : item.label || item.name,
        type        : item.type,
        isArray     : false,
        isOptional  : false,
        clazz       : "",
        isDimension : this._isDimension(item.type),
        isMeasure   : this._isMeasure(item.type),
    });
}
return outputSchema;
]]>
        </CodeText>
      </Service>
      <Service name="___getParseSchema" args="schema,pivot,excludeIgnoredField" private="true">
        <CodeText>
          <![CDATA[var nameValueMetric = false;
if (pivot.pivot[0]["__target_metric_name__"]) {
    nameValueMetric = true;
}

var parseSchema = [];
for (var i=0, n=schema.length; i<n; i++) {
    var field = schema[i];
    if (!excludeIgnoredField || field.ignore != true) {
        var record = {
            name        : field.name,
            label       : field.label || field.name,
            type        : (nameValueMetric && field.attr_type == "measure") ? "double" : field.data_type,
            isArray     : false,
            isOptional  : field.ignore == true || field.optional || field.attr_type == "measure",
            initName    : field.name,
            isDimension : field.attr_type == "dimension" || this._isDimension(field.data_type),
            isMeasure   : field.attr_type == "measure" || this._isMeasure(field.data_type),
            excluded    : field.ignore,
        };
        if (field.format != null) {
            record.format = field.format;
        }
        if (field.attr_type == "timestamp") {
            record.isOptional = false;
        }
        parseSchema.push(record);
    }
}
return parseSchema;
]]>
        </CodeText>
      </Service>
      <Service name="___getPivotOutputSchema" args="pivot" private="true">
        <CodeText>
          <![CDATA[var pivotSchema = [];
pivotSchema.push({
    name        : "ts",
    label       : "ts",
    type        : "datetime",
    isArray     : false,
    isOptional  : false,
    clazz       : "",
    isDimension : false,
    isMeasure   : false,
});
for (var i=0, n=pivot.dimensions.length; i<n; i++) {
    var field = pivot.dimensions[i];
    pivotSchema.push({
        name        : field.name,
        label       : field.name,
        type        : field.data_type,
        isArray     : false,
        isOptional  : field.optional,
        clazz       : "",
        isDimension : true,
        isMeasure   : false,
    });
}
pivotSchema.push({
    name        : "metric_name",
    label       : "metric_name",
    type        : "string",
    isArray     : false,
    isOptional  : false,
    clazz       : "",
    isDimension : true,
    isMeasure   : false,
});

if ((!pivot.pivo || pivot.pivo.length == 0) || pivot.pivot[0]["__target_metric_name__"]) {
    pivotSchema.push({
        name        : "metric_value",
        label       : "metric_value",
        type        : "double",
        isArray     : false,
        isOptional  : false,
        clazz       : "",
        isDimension : false,
        isMeasure   : true,
    });
} else {
    pivotSchema.push({
        name        : "metric_value",
        label       : "metric_value",
        type        : pivot.pivot[0]["__metric_type__"],
        isArray     : false,
        isOptional  : false,
        clazz       : "",
        isDimension : false,
        isMeasure   : true,
    });
}

return pivotSchema;
]]>
        </CodeText>
      </Service>
      <Service name="___getPreResultText" args="project,maxLineCount" private="true">
        <CodeText>
          <![CDATA[function toCsvLine(arr) {
    var buf = [];
    for (var j=0, jN=arr.length; j<jN; j++) {
        var val = arr[j];
        if (typeof val == "string") {
            buf.push('"'+val+'"');
        }
        else {
            buf.push(String(val));
        }
    }
    return buf.join(",");
}

var result = this._loadProjectFile(project, "preprocess.json", true);
// print("___getPreResultText: result="+JSON.stringify(result, null, "    "));
if (result != null) {
    var csv = [];
    csv.push(toCsvLine(result.cols));
    for (var j=0, jN=result.data.length; j<jN && j<maxLineCount; j++) {
        csv.push(toCsvLine(result.data[j]));
    }
    return csv.join("\n");
}
return "";
]]>
        </CodeText>
      </Service>
      <Service name="___getSampleText" args="project,maxLineCount" private="true">
        <CodeText>
          <![CDATA[/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var JavaString = java.lang.String;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/sample.txt");
var text = Context.getFileAsString(path);
*/

var JavaString = java.lang.String;
var text = this._loadProjectFile(project, "sample.txt", false);
if (text != null && text != "") {
    text = new JavaString(text);
    text = text.replace("\r", "\n").replace("\n\n", "\n");
    var nl = -1;
    for (var i=0; i<maxLineCount; i++) {
        nl = text.indexOf("\n", nl+1);
        if (nl == -1) break;
    }
    return nl != -1 ? text.substring(0, nl) : text;
}
return "";
]]>
        </CodeText>
      </Service>
      <Service name="___getSchemaField" args="schema,fieldName" private="true">
        <CodeText>
          <![CDATA[for (var i=0, n=schema.length; i<n; i++) {
    var field = schema[i];
    if (field.name == fieldName) {
        var schemaField = {
            name        : field.name,
            label       : field.label || field.name,
            type        : field.data_type,
            isArray     : false,
            isOptional  : field.ignore == true || field.optional || field.attr_type == "measure",
            initName    : field.name,
            isDimension : field.attr_type == "dimension" || this._isDimension(field.data_type),
            isMeasure   : field.attr_type == "measure" || this._isMeasure(field.data_type),
            excluded    : false,
        };
        if (field.format != null) {
            schemaField.format = field.format;
        }
        if (field.attr_type == "timestamp") {
            schemaField.isOptional = false;
        }
        return schemaField;
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="___removeAllChildrenOf" args="node" private="true">
        <CodeText>
          <![CDATA[var exploreConfig = null;
while (node.hasChildNodes()) {
    var child = node.getFirstChild();
    if (child.getNodeName() == "ExploreConfig") {
        exploreConfig = child;
    }
    node.removeChild(child);
}
if (exploreConfig != null) {
    node.appendChild(exploreConfig);
}
]]>
        </CodeText>
      </Service>
      <Service name="___updateSchemaNode" args="document,schemaNode,fields,extraMetaData" private="true">
        <CodeText>
          <![CDATA[this.___removeAllChildrenOf(schemaNode);
for (var j=0, jN=fields.length; j<jN; j++) {
    var field = fields[j];
    var fieldNode = document.createElement("Field");
    fieldNode.setAttribute("name", field.name);
    fieldNode.setAttribute("label", field.label || field.name);
    fieldNode.setAttribute("type", field.type);
    fieldNode.setAttribute("isArray", field.isArray ? "true" : "false");
    fieldNode.setAttribute("isOptional", field.isOptional ? "true" : "false");
    if (field.isDimension != null) fieldNode.setAttribute("isDimension", field.isDimension ? "true" : "false");
    if (field.isMeasure != null) fieldNode.setAttribute("isMeasure", field.isMeasure ? "true" : "false");
    if (field.clazz != null) fieldNode.setAttribute("clazz", field.clazz);
    if (extraMetaData) {
        fieldNode.setAttribute("initName", field.name);
        fieldNode.setAttribute("excluded", field.excluded ? "true" : "false");
    }
    if (field.format != null) {
        fieldNode.setAttribute("format", field.format);
    }
    schemaNode.appendChild(fieldNode);
}
]]>
        </CodeText>
      </Service>
      <Service name="___updateSourceSchema" args="document,schemaNode,fields,column,clazz" private="true">
        <CodeText>
          <![CDATA[this.___removeAllChildrenOf(schemaNode);
for (var j=0, jN=fields.length; j<jN; j++) {
    var field = fields[j];
    var fieldNode = document.createElement("Field");
    fieldNode.setAttribute("name", field.name);
    fieldNode.setAttribute("label", field.label || field.name);
    fieldNode.setAttribute("wrapName", field.name);
    fieldNode.setAttribute("type", field.type);
    fieldNode.setAttribute("isArray", field.isArray ? "true" : "false");
    fieldNode.setAttribute("isOptional", field.isOptional ? "true" : "false");
    if (column) fieldNode.setAttribute("column", field.name);
    if (clazz) fieldNode.setAttribute("clazz", "");
    schemaNode.appendChild(fieldNode);
}
]]>
        </CodeText>
      </Service>
      <Service name="___updateTableColumns" args="document,columnsNode,fields" private="true">
        <CodeText>
          <![CDATA[this.___removeAllChildrenOf(columnsNode);
for (var j=0, jN=fields.length; j<jN; j++) {
    var field = fields[j];
    var column = document.createElement("column");
    column.appendChild(document.createTextNode(field.name));
    columnsNode.appendChild(column);
}
]]>
        </CodeText>
      </Service>
      <Service name="__csvParseSampleData" args="text,delimiter" private="true">
        <CodeText>
          <![CDATA[//print("__csvParseSampleData: delimiter="+delimiter);

var System = java.lang.System;
var JavaString = java.lang.String;

var self = this;

function enrichParsedSchema(schema, result)
{
    for (var j=0, jN=schema.length; j<jN; j++) {
        var field = schema[j];

        field.ignore    = false,
        field.data_type = field.type;
        field.attr_type = "N/A";
        field.meta_data = null;
        field.optional  = false;
        delete field.type;

        if (field.data_type.startsWith("dateTime:")) {
            field.format = field.data_type.substring(9);
            field.data_type = "datetime";
        }

        for (var i=0, iN=result.length; i<iN; i++) {
            var record = result[i];
            var value = record[field.name];
            if (value == null || value == "") {
                field.optional = true;
                break;
            }
        }
    }
}

// work-around as the version of DB SDK does not support returning schema
// only work for simple CSV header... not quotes
function parseSchemaFromHeader(text, result, delimiter)
{
    text = new JavaString(text);
	text = text.replace("\r", "\n").replace("\n\n", "\n");
    var header = text.substring(0, text.indexOf("\n")).trim();
    var fields = header.split(delimiter);
    for (var i=0, n=fields.length; i<n; i++) {
        var name = (fields[i]).trim();
        if (name.charAt(0) == '"' && name.charAt(name.length-1) == '"') {
            name = name.substring(1, name.length-1);
        }
        fields[i] = {
            name      : name,
            label     : name,
            optional  : false,
            ignore    : false,
            data_type : null,
            attr_type : "N/A",
            meta_data : null,
        };
    }
    for (var j=0, jN=fields.length; j<jN; j++) {
        var field = fields[j];
        var type = null;
        var format = null;
        var interval = null;
        var optional = false;
        for (var i=0, iN=result.length; i<iN; i++) {
            var record = result[i];
            var value = record[field.name];
            if (value == null || value == "") {
                optional = true;
            }
            else {
                var num = Number(value);
                if (!isNaN(num)) {
                    if (type == null) {
                        type = "long";
                    }
                    if (type == "long" && typeof value == "string" && value.indexOf(".") != -1) {
                        type = "double";
                    }
                    optional = true;
                }
                else if (value == "true" || value == "false") {
                    // is boolean
                    type = "boolean";
                }
                else {
                    var dt = self._isDateTime(value);
                    if (dt != null) {
                        type = "datetime";
                        format = dt.format;
                    }
                    else {
                        // is string
                        type = "string";
                    }
                }
            }
            if (type == "string") break;
        }
        if (type == null) {
            type = "string";
        }
        field.data_type = type;
        if (format != null) {
            field.format = format;
        }
        if (interval != null) {
            field.interval = interval;
        }
        field.optional = optional;
    }
    return fields;
}

function dropEmptyLines(str)
{
    var lines = str.replace("\r", "\n").split("\n");
    //print("dropEmptyLines: before=" + lines.length);
    var buf = [];
    for (var i=0, iN=lines.length; i<iN; i++) {
        var line = (lines[i]).trim();
        if (line != "") {
            buf.push(line);
        }
    }
    //print("dropEmptyLines: after=" + buf.length);
    return buf.join("\n");
}

var start = Date.now();
text = dropEmptyLines(text);
var data = null;

var defaultValues = this._getDefaultValues();
if (defaultValues["use-parser-library"] == true) {
    // flip this switch if we need to use parser implementation in VIA - Parser Library
    // for example, to work-around bug or because env not updated
    //print("__csvParseSampleData: using VIA Parser Library");
    data = this.parseCSVtoJSON(text, {
        schema    : false,
        convert   : true,
        delimiter : delimiter,
    });
}
else {
    //print("__csvParseSampleData: using builtin CSV parser");
    data = JSON.parse(Context.parseCSVtoJSON(text, false, true, delimiter));
}
//print("__csvParseSampleData: parseCSVtoJSON="+__prettyPrintJSON(data));
//print("__csvParseSampleData: parseCSVtoJSON=" + (Date.now()-start) + "ms");
start = Date.now();

var schema = null;
var result = null;

if (data.schema != null && data.result != null) {
    //print("__csvParseSampleData: data=" + __prettyPrintJSON(data));
    result = data.result;
    schema = data.schema;
    enrichParsedSchema(schema, result);
    //print("__csvParseSampleData: enrichParsedSchema=" + (Date.now()-start) + "ms");
    start = Date.now();
}
else {
    result = data;
    schema = parseSchemaFromHeader(text, result, delimiter);
    //print("__csvParseSampleData: parseSchemaFromHeader=" + (Date.now()-start) + "ms");
    start = Date.now();
}
//print("__csvParseSampleData: schema.length=" + schema.length);
//print("__csvParseSampleData: result.length=" + result.length);

// convert column names to eliminate invalid characters when mapping to table
var NAMES = {};
var MAXLENGTH = 32;
var REGEX1 = /\./gi;
var REGEX2 = /[^a-z0-9+]/gi;
for (var i=0, n=schema.length; i<n; i++) {
    var field = schema[i];
    var oldName = field.name;
    var newName = oldName.trim().replace(REGEX1, "_dot_").replace(REGEX2, "_");
    if (newName != oldName) {
        if (newName.length > MAXLENGTH) {
            newName = "_" + newName.substring(newName.length-32) + "_" + i;
        }
        NAMES[oldName] = newName;
        field.name = newName;
    }
}

//print("__csvParseSampleData: fixColumnNames=" + (Date.now()-start) + "ms");
start = Date.now();

// existing parseCSVtoJSON() does not trim field names
// so leading/trailing whitespace gets left in
for (var i=0, n=result.length; i<n; i++) {
    var record = result[i];
    var valueCount = 0;
    for (var name in record) {
        valueCount++;
    }
    for (var name in record) {
        var value = record[name];
        delete record[name];
        name = NAMES[name] || name;
        // name = name.trim();

        if (value != null && typeof value == "string" && valueCount < schema.length) {
            // to work-around problem in CSV where double-quote is _not_ properly escape with another double-quote
            // we check for "comma" and trim to it
            // YES, it is _not_ technically correct and can lose legit comma but can't think of another way because
            // by the time the parse data is returned, we have LOST the offending double-quote
            // for the purpose of sampling to determine type and to use for test generation, this is OK
            // major downside is this extra processing takes time
            // -engkee
            var comma = value.indexOf(",");
            if (comma != -1) {
                value = value.substring(0, comma);
            }
        }

        record[name] = value;
    }
}

//print("__csvParseSampleData: fixDataRecords=" + (Date.now()-start) + "ms");
start = Date.now();

return {
    schema : schema,
    result : result,
};

]]>
        </CodeText>
      </Service>
      <Service name="__generateResourceModel" args="template,project,deployment,output" private="true">
        <CodeText>
          <![CDATA[//print("generateResourceModel: template="+JSON.stringify(template, null, "    "));
//print("generateResourceModel: deployment="+__prettyPrintJSON(deployment));

if (!deployment) return;

var self = this;
var defaultODAQS = this._getDefaultODAQS();

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

var modelName = this.getResourceModelName(project, deployment);
var space = this.getResourceModelSpace(project, deployment);
var tableName = deploymentGlobalMap["spark_sql_table"].value || deploymentGlobalMap["spark_sql_table"].defaultValue;
var tableUrl = deploymentGlobalMap["spark_sql_table_url"].value || deploymentGlobalMap["spark_sql_table_url"].defaultValue;

var model = JSON.parse(JSON.stringify(template));

delete model["content"];

model["name"] = modelName;
model["_name_"] = modelName;
model["labelWithModelName"] = modelName;
model["label"] = modelName;
model["space"] = space;
model["_space_"] = space;
model["uri"] = "/app/drd/space/" +space + "/drm/" + modelName;
model["lastCreatedTableName"] = tableName;
model["tableName"] = JSON.stringify({
    "catalog" : "default",
    "name"    : tableName,
    "type"    : "TABLE"
});

if (defaultODAQS) {
    model["dataSource"] = defaultODAQS["jndiName"];
    model["jdbcURL"] = defaultODAQS["connectionUrl"];
    model["jdbcUsername"] = defaultODAQS["user"];
    model["jdbcPassword"] = defaultODAQS["password"];
}

model["hdfsURL"] = tableUrl;
model["parquetSchema"] = [];
model["schema"] = [];
var parquetGroupField = [];
var index = 1;
output.forEach(function(field) {
    (model["parquetSchema"]).push({
		"name"         : field.name,
		"path"         : field.name,
		"label"        : field.label || field.name,
		"type"         : field.type,
		"constraint"   : "",
		"_index_"      : String(index),
		"_type"        : "field",
		"_isDimension" : self._isDimension(field.type),
		"_isMeasure"   : self._isMeasure(field.type),
	});
    (model["schema"]).push({
		"name"         : field.name,
		"_name_"       : field.name,
		"path"         : field.name,
		"label"        : field.label || field.name,
		"type"         : field.type,
		"constraint"   : "",
		"_index_"      : String(index),
		"_type"        : "field",
		"_isDimension" : self._isDimension(field.type),
		"_isMeasure"   : self._isMeasure(field.type),
		"_isTimestamp" : self._isTimestamp(field.type),
		"_isNullable"  : true,
	});
	parquetGroupField.push("<field path=\"" + field.name + "\" name=\"" + field.name + "\" type=\"" + field.type + "\"></field>");
	index++;
});
model["parquetGroupField"] = parquetGroupField.join("");
model["createdBy"] = Context.getCurrentUserId();
model["content"] = JSON.stringify(model);
return {
    edits : [],
    model : model,
};
]]>
        </CodeText>
      </Service>
      <Service name="_addTestDataSuffix" args="project,options" private="true">
        <CodeText>
          <![CDATA[var suffix = project.filenameFilter;
if (suffix == null || suffix.trim() == "") {
    suffix = "_test";
}
else {
    suffix = "_test_" + suffix;
}

if(options && options.ignoreExtensionName) return suffix;

return  suffix + "." + (project.filenameExtension || "csv");
]]>
        </CodeText>
      </Service>
      <Service name="_cleanupIncidentSummary" args="queryConfig,metrics" private="true">
        <CodeText>
          <![CDATA[var DATASOURCE = queryConfig["data-source"]["incident-summary"];

if (metrics.length > 0) {
    var DELETE_SQL = Context.getLocalResource("INCIDENT_SUMMARY_DELETE_SQL");
    this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Incident Summary", "Delete"], DATASOURCE, DELETE_SQL, metrics);
}
]]>
        </CodeText>
      </Service>
      <Service name="_createNamePrefix" args="project" private="true">
        <CodeText>
          <![CDATA[if (project.prefix == null || project.prefix == undefined || project.prefix == "" || project.prefix.indexOf("-") >= 0) {
    project.prefix = (project.svc + "_" + project.comp + "_" + project.app).replace(/\s|-/g, "_");
}
]]>
        </CodeText>
      </Service>
      <Service name="_createTempFileForDownload" args="content" private="true">
        <CodeText>
          <![CDATA[var File = java.io.File;
var System = java.lang.System;
var FileUtils = org.apache.commons.io.FileUtils;
var UUID = java.util.UUID;

var tempDirectory = System.getProperty("java.io.tmpdir");
var tgtFile = new File(tempDirectory + "/" + UUID.randomUUID().toString());
FileUtils.writeStringToFile(tgtFile, content, "UTF-8");

TimerTask.setTimeout("DeleteTempDownloadFile", 10, function(path) {
    var file = new java.io.File(path);
    //print("Deleting download file: "+ file.getPath());
    if (file.delete()) {
        //print("Download file: " + file.getPath() + " deleted");
    }
    else {
        print("Download file: " + file.getPath() + " delete exception");
    }
}, tgtFile.getPath());

return tgtFile.getName();
]]>
        </CodeText>
      </Service>
      <Service name="_deleteProjectFile" args="project,filename" private="true">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    
    var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/" + filename);
    var file = new File(path);
    if (file.exists() && file.isFile()) {
        // if we upload new sample, delete old schema
        file.delete();
        print("_deleteProjectFile: deleted="+path);
    }
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_ITEM_TABLE_DELETE_SQL");
    this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project Item", "Delete"], DS, sql, [[project.uuid, filename]]);
    print("_deleteProjectFile: deleted="+project.uuid + "/" + filename);
}
return true;]]>
        </CodeText>
      </Service>
      <Service name="_doPurge" args="modelPath,instance,purgeRuntime,purgeCheckpoint" private="true">
        <CodeText>
          <![CDATA[if (purgeRuntime == null) purgeRuntime = true;
if (purgeCheckpoint == null) purgeCheckpoint = true;

var XML = org.json.XML;
var HashMap = java.util.HashMap;
var Thread = java.lang.Thread;

print("Purging model '" + modelPath + "'");
var value = Context.GET("/rest"+modelPath+"?op=getrunningstatus" + ((instance != null) ? ("&instance=" + instance) : ""));
if (value == "STOPPED") {
    var url = "/rest"+modelPath+"?op=purge";
    if (purgeRuntime) {
        url += "&purgeRuntime=true";
    } else {
        url += "&purgeRuntime=false";
    }
    
    if (purgeCheckpoint) {
        url += "&purgeCheckpoint=true";
    } else {
        url += "&purgeCheckpoint-false";
    }
    
    if (instance != null) {
        url += "&instance=" + instance;
    }
    value = Context.GET(url);
    value = XML.toJSONObject(value).toString();
    //print(value);
    if (value.result != null && value.result.value == "Error") {
        print("Error purging model '" + modelPath + "'" + value.result.message);
        value = "ERROR:"+value.result.message;
    }
}
return value;
]]>
        </CodeText>
      </Service>
      <Service name="_doStart" args="modelPath,profile" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;
var HashMap = java.util.HashMap;
var Thread = java.lang.Thread;

if (profile != null) {
    print("Starting model '" + modelPath + "' with profile: " + JSON.stringify(profile));
}
else {
    print("Starting model '" + modelPath + "'");
}

var url = "/rest"+modelPath+"?op=getrunningstatus";
if (profile != null && profile["instance.identifier"] != null && profile["instance.identifier"] != "") {
    url = "/rest"+modelPath+"?op=getrunningstatus" + "&instance=" + profile["instance.identifier"];
}
var value = Context.GET(url);
if (value == "UNDEPLOYED" || value == "STOPPED") {
    if (profile != null) {
        var headers = new HashMap();
        headers.put("profile", JSON.stringify(profile));
        value = Context.POST("/rest"+modelPath+"?op=start", headers);
    }
    else {
        value = Context.GET("/rest"+modelPath+"?op=start");
    }
    value = JSON.parse(XML.toJSONObject(value).toString());
    //print(__prettyPrintJSON(value));
    if (value.result != null && value.result.value == "Error") {
        print("Error starting model '" + modelPath + "'" + value.result.message);
        switch (value.result.message) {
            case "current user does not have permission to start the app model.":
                value = "NO_PERMISSION";
                break;
            default:
                value = "ERROR:"+value.result.message;
                break;
        }
        // throw value;
        return this.createFailedResult(value);
    }
    else if (value.result != null && value.result.status == "ERROR") {
        var message = value.result.message;
        if (typeof message != "string" && message.content != null) {
            message = message.content.join(" ").replace("\n", " ");
        }
        print("Error starting model '" + modelPath + "': " + message);
        switch (message) {
            case "Error encountered in compiling/packaging of Spark scala class. Check for details.":
                value = "BUILD_ERROR";
                break;
            default:
                value = "ERROR:"+message;
                break;
        }
        // throw value;
        return this.createFailedResult(value);
    }
    else if (value.result != null && value.result.value == "OK") {
        url = "/rest"+modelPath+"?op=getRuntimeURL";
        if (profile != null && profile["instance.identifier"] != null && profile["instance.identifier"] != "") {
            url = "/rest"+modelPath+"?op=getRuntimeURL" + "&instance=" + profile["instance.identifier"];
        }
        var waitCount = 120;
        value = Context.GET(url);
        // print("model status="+value);
        value = JSON.parse(value);
        while ((value.driverWebUrl == null || value.driverWebUrl == "N/A") && waitCount-- > 0) {
            Thread.sleep(2000);
            value = Context.GET(url);
            // print("model status="+value);
            value = JSON.parse(value);
        }
        if (value.driverWebUrl == null || value.driverWebUrl == "N/A") {
            // status still not showing STOPPED after max wait (60s)
            print("Unable to confirm that model '" + modelPath + "' is started");
            return this.createFailedResult("Unable to confirm that model '" + modelPath + "' is started");
        }
        else {
            print("Started model '" + modelPath + "'");
            url = "/rest"+modelPath+"?op=getrunningstatus";
            if (profile != null && profile["instance.identifier"] != null && profile["instance.identifier"] != "") {
                url = "/rest"+modelPath+"?op=getrunningstatus" + "&instance=" + profile["instance.identifier"];
            }
            value = Context.GET(url);
        }
    }
}
return value;
]]>
        </CodeText>
      </Service>
      <Service name="_doStop" args="modelPath,instance" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;
var Thread = java.lang.Thread;

print("Stopping model '" + modelPath + "'");
var url = "/rest"+modelPath+"?op=getrunningstatus";
if (instance != null) {
    url += "&instance=" + instance;
}
var value = Context.GET(url);
if (value == "STARTED" || value == "PARTIALLYSTARTED") {
    var stopUrl = "/rest/appmodel.mgr"+modelPath.substring(4)+"?op=stop";
    if (instance != null) {
        stopUrl += "&instance=" + instance;
    }
    value = Context.GET(stopUrl);
    value = JSON.parse(XML.toJSONObject(value).toString());
    //print(value);
    if (value.result != null && value.result.value == "Error") {
        print("Error stopping model '" + modelPath + "'" + value.result.message);
        value = "ERROR:"+value.result.message;
    }
    else if (value.result != null && value.result.value == "OK") {
        var waitCount = 30;
        value = Context.GET(url);
        //print("model status="+value);
        while (value != "STOPPED" && waitCount-- > 0) {
            Thread.sleep(1000);
            value = Context.GET(url);
            //print("model status="+value);
        }
        if (value != "STOPPED") {
            // status still not showing STOPPED after max wait (30s)
            print("Unable to confirm that model '" + modelPath + "' is stopped");
        }
        else {
            print("Stopped model '" + modelPath + "'");
        }
    }
}
return value;

]]>
        </CodeText>
      </Service>
      <Service name="_doUndeploy" args="modelPath,instance" private="true">
        <CodeText>
          <![CDATA[print("Undeploying model '" + modelPath + "'");

var url = "/rest"+modelPath+"?op=undeploy&purgeCheckpoint=true";
if (instance != null) {
    url += "&instance=" + instance;
}

return Context.GET(url);]]>
        </CodeText>
      </Service>
      <Service name="_exportProject" args="project" private="true">
        <CodeText>
          <![CDATA[project.detail = this.loadProject(project);
//print("exportProject: " + __prettyPrintJSON(project));

var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;
var System = java.lang.System;
var UUID = java.util.UUID;
var FileOutputStream = java.io.FileOutputStream;
var ZipOutputStream = java.util.zip.ZipOutputStream;
var ZipEntry = java.util.zip.ZipEntry;
var self = this;

/**
var projectPath = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid);
function getProjectContent(filename)
{
    if (queryConfig['storage_type'] == 'local-file') {
        var path = projectPath + "/" + filename;
        var file = new File(path);
        if (file.exists() && file.isFile()) {
            // if exist, load it
            return Context.getFileAsString(path);
        }
    }
    return null;
}
*/

function addProjectContent(zo, filename)
{
    var text = self._loadProjectFile(project, filename);
    if (text != null) {
        var data = text.getBytes("UTF-8");
        var ze = new ZipEntry(filename);
        zo.putNextEntry(ze);
        zo.write(data, 0, data.length);
        zo.closeEntry();
    }
}

var tempDirectory = System.getProperty("java.io.tmpdir");
var tgtFile = new File(tempDirectory + "/" + UUID.randomUUID().toString() + ".zip");

var zo = new ZipOutputStream(new FileOutputStream(tgtFile));
addProjectContent(zo, "project.json");
addProjectContent(zo, "original-sample.txt");
addProjectContent(zo, "original-sample.json");
addProjectContent(zo, "sample.json");
addProjectContent(zo, "sample.txt");
addProjectContent(zo, "preprocess.js");
addProjectContent(zo, "preprocess.json");
addProjectContent(zo, "schema.json");
addProjectContent(zo, "pivot.json");
addProjectContent(zo, "count.json");
addProjectContent(zo, "qdc.json");
addProjectContent(zo, "enrich.json");
addProjectContent(zo, "metric.json");
addProjectContent(zo, "output.json");
addProjectContent(zo, "tests.json");
addProjectContent(zo, "generated-parser.xml");
var deploymentList = this.loadProjectDeploymentList(project);
for (var i = 0; i < deploymentList.length; i++) {
    var deploymentItem = deploymentList[i];
    var deployment = this._loadProjectDeployment(project, deploymentItem.name,false);
    if (deployment != null) {
        var data = deployment.getBytes("UTF-8");
        var ze = new ZipEntry(deploymentItem.name + ".deployment");
        zo.putNextEntry(ze);
        zo.write(data, 0, data.length);
        zo.closeEntry();
    }
}
zo.close();

TimerTask.setTimeout("DeleteTempDownloadFile", 20, function(path) {
    var file = new java.io.File(path);
    //print("Deleting download file: "+ file.getPath());
    if (file.delete()) {
        //print("Download file: " + file.getPath() + " deleted");
    }
    else {
        print("Download file: " + file.getPath() + " delete exception");
    }
}, tgtFile.getPath());

return tgtFile;
]]>
        </CodeText>
      </Service>
      <Service name="_generateTestData" args="project,schema,model,sampleType" private="true">
        <CodeText>
          <![CDATA[//print("_generateTestData: schema="+__prettyPrintJSON(schema));
//print("_generateTestData: model="+__prettyPrintJSON(model));

var JavaDate = java.util.Date;
var SimpleDateFormat = java.text.SimpleDateFormat;

function getMaxDev(range)
{
    var dev = 0.01;
    if (range > 1000) {
        dev = 0.01;
    }
    else if (range > 100) {
        dev = 0.1;
    }
    else {
        dev = 1;
    }
    return dev;
}

function getNextLong(field, lastValue)
{
    var deviation = 0;
    if (lastValue == null) {
        lastValue = (field.value.max + field.value.min)/2;
        lastValue = lastValue + (lastValue * (Math.random() - 0.5));
        lastValue = Math.round(lastValue);
    }
    else {
        var range = field.value.max - field.value.min;
        var maxdev = getMaxDev(range);
        deviation = Math.round(Math.random()*maxdev*range);
        if (Math.random() < 0.5) {
            deviation = 0 - deviation;
        }
    }
   var nextValue = lastValue + deviation;
    // bound it by min/max to keep it sane
    if (nextValue > field.value.max) {
        nextValue = field.value.max;
    }
    if (nextValue < field.value.min) {
        nextValue = field.value.min;
    }
    return nextValue;
}

function getNextDouble(field, lastValue)
{
    var deviation = 0;
    if (lastValue == null) {
        lastValue = (field.value.max + field.value.min)/2;
        lastValue = lastValue + (lastValue * (Math.random() - 0.5));
    }
    else {
        var range = field.value.max - field.value.min;
        var maxdev = getMaxDev(range);
        deviation = Math.random()*maxdev*range;
        if (Math.random() < 0.5) {
            deviation = 0 - deviation;
        }
    }
   var nextValue = lastValue + deviation;
    // bound it by min/max to keep it sane
    if (nextValue > field.value.max) {
        nextValue = field.value.max;
    }
    if (nextValue < field.value.min) {
        nextValue = field.value.min;
    }
    return nextValue;
}

function generateData(testData, dataFields, startTime, endTime, stepSize, iterateField, iterateCount, formatter, assignments)
{
    var values = {};
    for (var epoch=startTime; epoch < endTime; epoch += stepSize) {
        for (var i=0; i<iterateCount; i++) {
            var record = {};
            for (var fieldName in dataFields) {
                var field = dataFields[fieldName];
                if (field == iterateField) {
                    if (formatter != null) {
                        var dt = new JavaDate(epoch*1000);
                        record[fieldName] = formatter.format(dt);
                    }
                    else {
                        record[fieldName] = epoch;
                    }
                }
                else {
                    switch (field.type) {
                        case "long":
                            var value = getNextLong(field, values[fieldName]);
                            values[fieldName] = value;
                            if (field.spike != null && field.spike.multiplier != null && field.spike.threshold != null) {
                                if (Math.random() >= field.spike.threshold) {
                                    value = value * field.spike.multiplier;
                                }
                            }
                            record[fieldName] = value;
                            break;
                        case "double":
                            var value = getNextDouble(field, values[fieldName]);
                            values[fieldName] = value;
                            if (field.spike != null && field.spike.multiplier != null && field.spike.threshold != null) {
                                if (Math.random() >= field.spike.threshold) {
                                    value = value * field.spike.multiplier;
                                }
                            }
                            record[fieldName] = value;
                            break;
                        case "string":
                            var index = Math.floor(field.value.enums.length * Math.random());
                            record[fieldName] = field.value.enums[index];
                            break;
                    }
                }
            }
            if (assignments != null) {
                for (var target in assignments) {
                    var source = assignments[target];
                    record[target] = record[source];
                }
            }
            testData.push(record);
        }
    }
}

var data = [];
if (model.fields != null && model.iterator != null) {
    var iterateField = model.fields[model.iterator.field];
    var iterateCount = model.iterator.count;
    var iterateStep  = model.iterator.step;
    var iterateStart = model.iterator.min || iterateField.value.min;
    var iterateEnd   = model.iterator.max || iterateField.value.max;
    var assignments  = model.assignments;
    switch (iterateField.type) {
        case "datetime":
            var startTime = (new Date(iterateStart)).getTime()/1000;
            var endTime   = (new Date(iterateEnd)).getTime()/1000;
            var formatter = null;
            if (iterateField.format != null) {
                formatter = new SimpleDateFormat(iterateField.format);
            }
            startTime = Math.floor(startTime/iterateStep)*iterateStep;
            endTime = Math.ceil(endTime/iterateStep)*iterateStep;
            generateData(data, model.fields, startTime, endTime, iterateStep, iterateField, iterateCount, formatter, assignments);
            break;
        case "long":
            var startTime = Number(iterateStart);
            var endTime   = Number(iterateEnd);
            startTime = Math.floor(startTime/iterateStep)*iterateStep;
            endTime = Math.ceil(endTime/iterateStep)*iterateStep;
            generateData(data, model.fields, startTime, endTime, iterateStep, iterateField, iterateCount, null, assignments);
            break;
        case "double":
            var startTime = Number(iterateStart);
            var endTime   = Number(iterateEnd);
            generateData(data, model.fields, startTime, endTime, iterateStep, iterateField, iterateCount, null, assignments);
            break;
    }
}
if (data.length > 0) {
    switch (sampleType) {
        case "text/csv":
        case "application/vnd.ms-excel":
            var lines = [];
            var line = [];
            for (var j=0, m=schema.length; j<m; j++) {
                var field = schema[j];
                line.push(field.name);
            }
            lines.push(line.join(","));
            for (var i=0, n=data.length; i<n; i++) {
                var record = data[i];
                line = [];
                for (var j=0, m=schema.length; j<m; j++) {
                    var field = schema[j];
                    var value = record[field.name];
                    if (value == null) value = "";
                    if (typeof value == "string") {
                        if (value.indexOf('"') != -1) {
                            value = value.replace(/\"/g, '""');
                        }
                        if (value.indexOf(",") != -1 || value.indexOf('"') != -1) {
                            value = '"' + value + '"';
                        }
                    }
                    line.push(value);
                }
                lines.push(line.join(","));
            }
            //print("_generateTestData: count="+lines.length);
            return lines.join("\n");
        case "application/json":
            if (project != null) {
                var script = this.loadProjectTestScript(project);
                if (script != null && script.trim() != "") {
                    var buf = [];
                    buf.push("var formatTestData = function(data) {");
                    buf.push(script);
                    buf.push("}");
                    var scriptText = buf.join("\n");
                    print("evalTestScript: scriptText="+scriptText);
                    eval(scriptText);
                    return formatTestData(data);
                }
                else {
                    return JSON.stringify(data, null, "    ");
                }
            }
            return data;
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="_generateTestDataSuffix" args="project,options" private="true">
        <CodeText>
          <![CDATA[var suffix = project.filenameFilter;
if (suffix == null || suffix.trim() == "") {
    suffix = "_test";
}
else {
    suffix = "_test_" + suffix;
}
switch (project.sample.type) {
    case "text/csv":
    case "application/vnd.ms-excel":
        return  ignoreExtensionName() ? suffix : suffix + ".csv";
    case "application/json":
        return ignoreExtensionName() ? suffix : suffix + ".json";
}

function ignoreExtensionName(){
    return options && options.ignoreExtensionName;
}]]>
        </CodeText>
      </Service>
      <Service name="_getBaseOutputModel" args="" private="true">
        <CodeText>
          <![CDATA[var output = JSON.parse(Context.getLocalResource("BASE_OUTPUT_MODEL"));
for (var i=0; i<output.length; i++) {
    output[i]["__reserved__"] = true;
}
return output;
]]>
        </CodeText>
      </Service>
      <Service name="_getDateTimeFormats" args="" private="true">
        <CodeText>
          <![CDATA[if (this._DateTimeFormats != null) return this._DateTimeFormats;

var queryConfig = this.getQueryConfig();
var queryFormats = queryConfig["datetime-formats"] || [];

var workbenchConfig = this.getWorkbenchConfig();
var workbenchFormats = workbenchConfig["datetime-formats"] || [];

var SELF_TEST = false;

var patterns = [].concat(queryFormats, workbenchFormats);
if (SELF_TEST) {
    print("_getDateTimeFormats: patterns=" + __prettyPrintJSON(patterns));
}
for (var i=0; i<patterns.length; i++) {
    var pattern = patterns[i];
    pattern.regexp = new RegExp(pattern.regexp);
    if (SELF_TEST && pattern["#sample"] != null) {
        print("Sample '" + pattern["#sample"] + "' => " + (pattern.regexp.test(pattern["#sample"]) == true));
    }
}
this._DateTimeFormats = patterns;
return patterns;
]]>
        </CodeText>
      </Service>
      <Service name="_getDefaultODAQS" args="" private="true">
        <CodeText>
          <![CDATA[var odaQS = this._getConnectionInfo();

var XML = org.json.XML;
var xml = Context.GET("/rest/domain?op=listDatasource&all=true");
var dsList = JSON.parse(XML.toJSONObject(xml).toString());
if (dsList["dataSourceList"] && dsList["dataSourceList"]["dataSource"]) {
    dsList = dsList["dataSourceList"]["dataSource"];
    for (var i=0; i<dsList.length; i++) {
        var ds = dsList[i];
        if (ds.jndiName == odaQS.url) {
            return ds;
        }
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="_getDefaultValues" args="" private="true">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
var queryDefaultValues = queryConfig["default-values"] || {};

var workbenchConfig = this.getWorkbenchConfig();
var workbenchDefaultValues = workbenchConfig["default-values"] || {};

for (var key in workbenchDefaultValues) {
    if (queryDefaultValues[key] == undefined) {
        queryDefaultValues[key] = workbenchDefaultValues[key];
    }
}

if (queryDefaultValues["hdfs-server-url"] == null) {
    queryDefaultValues["hdfs-server-url"] = this.getDefaultHDFSServerURL();
}

return queryDefaultValues;
]]>
        </CodeText>
      </Service>
      <Service name="_getFilesFromParserAudits" args="project,deployment" private="true">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var queryConfig = this.getQueryConfig();
var nameDefaults = this.getNameDefaults(project);

var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
var sourceGroup = (project.sourceGroup || nameDefaults.sourceGroup);
var targetGroup = (project.targetGroup || nameDefaults.targetGroup);

var auditParserTable = "viaops_audit_parser";
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    if (item.id == "auditUrl") {
        auditParserTable = item.value || item.defaultValue;
    }
});

var DATASOURCE = queryConfig["data-source"]["parser-audit"];
var sql = Context.getLocalResource("AUDIT_PARSER_SELECT_SQL");
sql = this._doValueSubstitution(sql, {
    sourceGroup : sourceGroup,
    auditParserTable: auditParserTable
});
var result = this.executeSQLQuery(queryConfig, [], [], DATASOURCE, sql, null, false, Date.now());
var processed = {};
if (result != null && result.items != null) {
    result.items.forEach(function(item) {
        var names = item.name.split(",");
        names.forEach(function (name) {
            var splits = name.split("/");
            name = splits[splits.length - 1];
            processed[name] = true;
        });
    });
}
return processed;
]]>
        </CodeText>
      </Service>
      <Service name="_getMappedStatus" args="status" private="true">
        <CodeText>
          <![CDATA[var STATUS_MAP = {
    "NOT_FOUND"        : "NOT_FOUND",
    "UNKNOWN"          : "NOT_FOUND",
    "ACTIVE"           : "ACTIVE",
    "STARTED"          : "ACTIVE",
    "PARTIALLYSTARTED" : "ACTIVE",
    "NOT_ACTIVE"       : "NOT_ACTIVE",
    "STOPPED"          : "NOT_ACTIVE",
    "PARTIALLYSTOPPED" : "NOT_ACTIVE",
    "UNDEPLOYED"       : "NOT_ACTIVE",
};
return STATUS_MAP[status] || "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="_getMetricsInSystemModel" args="systemModel" private="true">
        <CodeText>
          <![CDATA[var metricList = [];
var serviceConfig = systemModel["service-config"] || systemModel["ServiceConfig"];
if (serviceConfig == null) return metricList;

serviceConfig.groups.forEach(function(svc) {
    if (svc.items != null) {
        var rootMetricId = svc.name + "|*|*";
        svc.items.forEach(function(metric) {
            metricList.push(rootMetricId + "|" + metric.name);
        });
    }
    if (svc.groups != null) {
        svc.groups.forEach(function(comp) {
            if (comp.items != null) {
                var rootMetricId = svc.name + "|" + comp.name + "|*";
                comp.items.forEach(function(metric) {
                    metricList.push(rootMetricId + "|" + metric.name);
                });
            }
            if (comp.groups != null) {
                comp.groups.forEach(function(app) {
                    if (app.items != null) {
                        var rootMetricId = svc.name + "|" + comp.name + "|" + app.name;
                        app.items.forEach(function(metric) {
                            metricList.push(rootMetricId + "|" + metric.name);
                        });
                    }
                });
            }
        });
    }
});



return metricList;]]>
        </CodeText>
      </Service>
      <Service name="_getTemplate" args="project,modelType" private="true">
        <CodeText>
          <![CDATA[if (project.sample != null) {
    return this._getTemplateForFileType(project, modelType, project.sample.type);
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="_getTemplateForFileType" args="project,modelType,fileType" private="true">
        <CodeText>
          <![CDATA[var workbenchConfig = this.getWorkbenchConfig();
var templatesConfig = workbenchConfig["templates"] || {};
templates = templatesConfig[fileType];
while (templates != null && typeof templates == "string") {
    templates = templatesConfig[templates];
}
if (templates != null && templates.length > 0) {
    // there may be multiple templates... for now, handle only one
    //print("_getTemplate: modelType="+modelType);
    //print("_getTemplate: template="+__prettyPrintJSON(templates[0]));
    var template = templates[0][modelType];
    if (template == null && fileType != "*") {
        template = this._getTemplateForFileType(project, modelType, "*");
    }
    return template;
}
return null;

]]>
        </CodeText>
      </Service>
      <Service name="_hasEnrichment" args="enrich" private="true">
        <CodeText>
          <![CDATA[if (enrich != null && enrich.joinClause != null && enrich.joinClause.length > 0) {
    for (var i=0; i<enrich.joinClause.length; i++) {
        var clause = enrich.joinClause[i];
        if (clause.leftField != null && clause.leftField != "") return true;
    }
}
return false;
]]>
        </CodeText>
      </Service>
      <Service name="_hasProjectFile" args="project,filename" private="true">
        <CodeText>
          <![CDATA[//print("_hasProjectFile: project="+__prettyPrintJSON(project));
//print("_hasProjectFile: filename="+filename);

var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    
    var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/" + filename);
    //print("_hasProjectFile: path="+path);
    var file = new File(path);
    return file.exists() && file.isFile();
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_ITEM_TABLE_EXIST_SQL");
    sql = this._doValueSubstitution(sql, {
        uuid: project.uuid,
        key: filename
    });
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project Item", "Exist"], DS, sql, null);
    if (result != null && result.items != null && result.items.length > 0) {
        return true;
    } else {
        return false;
    }
}
]]>
        </CodeText>
      </Service>
      <Service name="_hiveCreateTable" args="item" private="true">
        <CodeText>
          <![CDATA[//to fix table not updated issue.
this._hiveDeleteTable(item);

var headers = {
    model : JSON.stringify(item),
};
Context.POST("/app/drd/user/*/*?op=createHiveTable", headers);
Context.POST("/app/drd/user/*/*?op=refreshHiveTable", headers);
]]>
        </CodeText>
      </Service>
      <Service name="_hiveDeleteTable" args="item" private="true">
        <CodeText>
          <![CDATA[var tno = JSON.parse(item.tableName);
var params = [
    "op=deleteHiveTable",
    "tableName="+tno.name,
    "jdbcURL="+item.jdbcURL,
    "jdbcUsername="+item.jdbcUsername,
    "jdbcPassword="+item.jdbcPassword,
    "dataSource="+item.dataSource,
];
var headers = {};
return Context.POST("/app/drd/user/*/*?"+params.join("&"), headers);
]]>
        </CodeText>
      </Service>
      <Service name="_initProject" args="project" private="true">
        <CodeText>
          <![CDATA[var defaultValues = this._getDefaultValues();
var nameDefaults = this.getNameDefaults(project);
var queryConfig = this.getQueryConfig();

if (project.prefix == null || project.prefix == "") this._createNamePrefix(project);
if (project.safePrefix == null || project.safePrefix == "") {
    this._updateSafePrefix(project);
}

if (project.uuid == null)               project.uuid = Context.generateRandomUUID();
if (project.owner == null)              project.owner = Context.getCurrentUserId();
if (project.timezone == null)           project.timezone = defaultValues["timezone"];
if (project.dst == null)                project.dst = defaultValues["dst"];
if (project.space == null)              project.space = defaultValues["space"];
if (project.filenameFilter == null)     project.filenameFilter = defaultValues["filename-filter"];
if (project.sourceGroup == null || project.sourceGroup == "")        project.sourceGroup = nameDefaults.sourceGroup;
if (project.targetGroup == null || project.targetGroup == "")        project.targetGroup =  nameDefaults.targetGroup;
if (project.orginalTargetGroup == null) project.orginalTargetGroup = nameDefaults.targetGroup;
if (project.hdfsServerURL == null)      project.hdfsServerURL = defaultValues["hdfs-server-url"];
if (project.detectionAlgorithm == null) project.detectionAlgorithm = "score";
if (project.thresholdPolicy == null)    project.thresholdPolicy = "above";
if (project.delimiterType == null)      project.delimiterType = "csv";
if (project.delimiter == null)          project.delimiter = "";

if (project.anomalyFilePrefix == null)  project.anomalyFilePrefix = (project.safePrefix || nameDefaults.namePrefix).toLowerCase();
if (project.anomalyFileUrl == null)     project.anomalyFileUrl = project.hdfsServerURL + defaultValues["anomaly-path"] + (project.sourceGroup || nameDefaults.sourceGroup)
if (project.configs != null) {
    for (var i=0, n=project.configs.length; i<n; i++) {
        var config = project.configs[i];
        if (config.incidentAlgorithm == null) config.incidentAlgorithm = project.detectionAlgorithm;
        if (config.incidentThresholdPolicy == null) config.incidentThresholdPolicy = project.thresholdPolicy;
        if (config.incidentWarmupPeriod == null) config.incidentWarmupPeriod = 900;
        if (config.incidentCooldownPeriod == null) config.incidentCooldownPeriod = 900;
        if (config.settings == null) {
            config.settingDescription = "SWAG:" + config.incidentAlgorithm + "/" + config.incidentThresholdPolicy;
            config.settings = {};
            config.settings[Context.generateRandomUUID()] = {
                "description"     : config.settingDescription,
                "algorithm"       : config.incidentAlgorithm,
                "thresholdPolicy" : config.incidentThresholdPolicy,
                "highThreshold"   : config.incidentHighThreshold,
                "mediumThreshold" : config.incidentMediumThreshold,
                "lowThreshold"    : config.incidentLowThreshold,
                "warmupThreshold" : config.incidentWarmupThreshold,
                "warmupPeriod"    : config.incidentWarmupPeriod,
                "cooldownPeriod"  : config.incidentCooldownPeriod,
            };
        }
        else {
            var keyIsUUID = true;
            for (var key in config.settings) {
                // just check ONE key... if key contains "/" and is 2 tokens, we have
                // OLD algorithm/policy key... change to UUID
                var toks = key.split("/");
                if (toks.length == 2) {
                    keyIsUUID = false;
                }
                break;
            }
            if (!keyIsUUID) {
                var settings = {};
                for (var key in config.settings) {
                    var uuid = Context.generateRandomUUID();
                    settings[uuid] = config.settings[key];
                }
                config.settings = settings;
            }
            for (var uuid in config.settings) {
                var setting = config.settings[uuid];
                if (setting.description == null) {
                    setting.description = "(no description)";
                }
            }
        }
    }
}

if (project.subservices == null) {
    project.subservices = [];
}

if (!project.aggregateWindow) {
    project.aggregateWindow = {
        aggregate: false,
        windowSize: 5,
        windowUnit: 'N',
        OOOSize: 0,
        OOOUnit: 'N',
        hbDelaySize: 0,
        hbDelayUnit: 'N',
        stopEmptyWindow: false
    };
}]]>
        </CodeText>
      </Service>
      <Service name="_isDateTime" args="value" private="true">
        <CodeText>
          <![CDATA[var DATE_TIME_PATTERN = this._getDateTimeFormats();
for (var i=0; i<DATE_TIME_PATTERN.length; i++) {
    var pattern = DATE_TIME_PATTERN[i];
    if (pattern.regexp.test(value.trim()) == true) return pattern;
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="_isDimension" args="type" private="true">
        <CodeText>
          <![CDATA[switch (type) {
    case "string":
    case "datetime":
        return true;
    default:
        return false;
}
]]>
        </CodeText>
      </Service>
      <Service name="_isMeasure" args="type" private="true">
        <CodeText>
          <![CDATA[switch (type) {
    case "string":
    case "datetime":
        return false;
    default:
        return true;
}
]]>
        </CodeText>
      </Service>
      <Service name="_isRunnable" args="modelPath" private="true">
        <CodeText>
          <![CDATA[var value = Context.GET("/rest"+modelPath+"?op=getrunningstatus");
// print("isRunnable? " + modelPath + "=" + value);
return value != "UNKNOWN";]]>
        </CodeText>
      </Service>
      <Service name="_isRunning" args="modelPath,instance" private="true">
        <CodeText>
          <![CDATA[var url = "/rest"+modelPath+"?op=getrunningstatus";
if (instance != null) {
    url += "&instance=" + instance;
}
var value = Context.GET(url);
// print("isRunning? " + modelPath + "=" + value);
return value == "STARTED" || value == "PARTIALLYSTARTED";]]>
        </CodeText>
      </Service>
      <Service name="_isTimestamp" args="type" private="true">
        <CodeText>
          <![CDATA[switch (type) {
    case "datetime":
        return true;
    default:
        return false;
}
]]>
        </CodeText>
      </Service>
      <Service name="_loadProjectFile" args="project,filename,decode" private="true">
        <CodeText>
          <![CDATA[//print("_loadProjectFile: project="+__prettyPrintJSON(project));
//print("_loadProjectFile: filename="+filename);

var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    
    var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/" + filename);
    //print("_loadProjectFile: path="+path);
    var file = new File(path);
    if (file.exists() && file.isFile()) {
        // if exist, load it
        var data = Context.getFileAsString(path);
        if (decode) data = JSON.parse(data);
        
        return data;
    }
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_ITEM_TABLE_SELECT_SQL");
    sql = this._doValueSubstitution(sql, {
        uuid: project.uuid,
        name: filename
    });
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project Item", "Select"], DS, sql, null);
    if (result != null && result.items != null && result.items.length > 0) {
        var data = result.items[0].value;
        if (decode) data = JSON.parse(data);
        
        return data;
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="_mrCopyModel" args="modelPath,newName,space" private="true">
        <CodeText>
          <![CDATA[//print("_mrCopyModel: modelPath="+modelPath);
//print("_mrCopyModel: newName="+newName);
//print("_mrCopyModel: space="+space);

var XML = org.json.XML;
var toks = modelPath.split("/");
var appId = toks[2];
var userId = toks[4];
var modelType = toks[5];
var modelName = toks[6];

var url = "/rest/app/"+appId+"/user/"+userId+"/"+modelType+"?op=copy";
url += "&source=" + encodeURIComponent("/users/"+userId+"/_appdata/"+appId+"/"+modelType+"/"+modelName);
url += "&newName=" + encodeURIComponent(newName);
url += "&space=" + encodeURIComponent(space);
var value = Context.GET(url);
value = JSON.parse(XML.toJSONObject(value).toString());
//print("_mrCopyModel: "+url+"="+__prettyPrintJSON(value));
return value;
]]>
        </CodeText>
      </Service>
      <Service name="_mrCreateSpace" args="space" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;

var url = "/rest/spaces/" + space + "?op=createspace";
//print("_mrCreateSpace: url="+url);
var value = Context.POST(url, null);
//print(value);
return JSON.parse(XML.toJSONObject(value).toString());
]]>
        </CodeText>
      </Service>
      <Service name="_mrDeleteModel" args="modelPath" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;
var url = "/rest"+modelPath+"?op=delete";
var value = Context.GET(url);
return JSON.parse(XML.toJSONObject(value).toString());
]]>
        </CodeText>
      </Service>
      <Service name="_mrGetModel" args="modelPath" private="true">
        <CodeText>
          <![CDATA[return Context.GET("/rest"+modelPath);
]]>
        </CodeText>
      </Service>
      <Service name="_mrGetSystemModelProperties" args="payloadUUID" private="true">
        <CodeText>
          <![CDATA[var buf = [];
buf.push("<properties>");
buf.push("    <property name=\"_RESOURCE_Description\" value=\"\"/>");
buf.push("    <property name=\"_RESOURCE_Type\" value=\"dbpm\"/>");
if (payloadUUID != null) {
    buf.push("    <property name=\"__indexed_contents__\" value=\"" + payloadUUID + "\"/>");
    buf.push("    <property name=\"modelStatus\" value=\"valid\"/>");
}
else {
    buf.push("    <property name=\"__indexed_contents__\" value=\"\"/>");
    buf.push("    <property name=\"modelStatus\" value=\"new\"/>");
}
buf.push("</properties>");
return buf.join("\n");
]]>
        </CodeText>
      </Service>
      <Service name="_mrHasModel" args="modelPath" private="true">
        <CodeText>
          <![CDATA[//print("_mrHasModel: modelPath="+modelPath);
if (modelPath == null || modelPath == "") return false;
var info = Context.GET("/rest"+modelPath+"?op=info");
if (info != null && info != "") {
    try {
        info = JSON.parse(info);
        //print("_mrHasModel: info="+__prettyPrintJSON(info));
        return info.status == true;
    } catch (ex) {
        print("_mrHasModel: failed get model info modelPath="+modelPath);
    }
}
return false;

]]>
        </CodeText>
      </Service>
      <Service name="_mrHasSpace" args="space" private="true">
        <CodeText>
          <![CDATA[//print("_mrHasSpace: space="+space);
var info = Context.GET("/rest/spaces?format=json");
if (info != null && info != "") {
    info = JSON.parse(info);
    //print("_mrHasSpace: info="+__prettyPrintJSON(info));
    if (info.status == "OK") {
        var spaces = info.value;
        for (var i=0; i<spaces.length; i++) {
            if (spaces[i]["name"] == space) {
                return true;
            }
        }
    }
}
return false;
]]>
        </CodeText>
      </Service>
      <Service name="_mrSaveResourceModel" args="modelPath,content" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;
var toks = modelPath.split("/");
var appId = toks[2];
var userId = toks[4];
var modelType = toks[5];
var modelName = toks[6];

var headers = {
    model : content,
};
var url = "/rest" + modelPath + "?op=saveDataResource";
//print("_mrSaveResourceModel: url="+url);
var value = Context.POST(url, headers);
value = JSON.parse(XML.toJSONObject(value).toString());
//print(value);
return value;
]]>
        </CodeText>
      </Service>
      <Service name="_mrSaveSystemModel" args="modelPath,space,obj,project,deployment" private="true">
        <CodeText>
          <![CDATA[var XML = org.json.XML;
var toks = modelPath.split("/");
var appId = toks[2];
var userId = toks[4];
var modelType = toks[5];
var modelName = toks[6];

obj.uuid = project.uuid;
var content = JSON.stringify(obj, null, "    ");

function savePayload(uuid)
{
    var headers = {
        uuid : uuid,
        data : content,
    };
    var url = "/rest" + modelPath + "?op=putPayload";
    var value = Context.POST(url, headers);
    //print("_mrSaveSystemModel: putPayload="+url+" value="+value);
    value = JSON.parse(value);
    return value.status == "OK";
}

function saveModel(uuid)
{
    var modelText = null;
    var desc = null;
    if (uuid == null) {
        modelText = Context.getLocalResource("SYSTEM_MODEL_CONTENT_CREATE");
        modelText = modelText.replace("___MODEL_NAME___", modelName);
        desc = "Created " + (new Date()).toString();
    }
    else {
        modelText = Context.getLocalResource("SYSTEM_MODEL_CONTENT_UPDATE");
        modelText = modelText.replace("___MODEL_NAME___", modelName)
                             .replace("___PAYLOAD_UUID___", payloadUUID)
                             .replace("___PAYLOAD_SIZE___", String(content.length));
        desc = "Updated " + (new Date()).toString();
    }
    //print("updateSystemModel: " + modelText);
    
    var headers = {
        desc : desc,
        force : true,
        newname : modelName,
        space : space,
        properties : this._mrGetSystemModelProperties(uuid),
        document : modelText,
    };
    //print("_mrSaveSystemModel: headers="+__prettyPrintJSON(headers));
    var url = "/rest" + modelPath + "?op=save";
    //print("_mrSaveSystemModel: url="+url);
    var value = Context.POST(url, headers);
    //print(value);
    return JSON.parse(XML.toJSONObject(value).toString());
}

var payloadUUID = Context.generateRandomUUID();

if (!this._mrHasSpace(space)) {
    this._mrCreateSpace(space);
}

if (!this._mrHasModel(modelPath)) {
    saveModel(null);
}
if (savePayload(payloadUUID)) {
    return saveModel(payloadUUID);
}
return {
    status : "Error"
};
]]>
        </CodeText>
      </Service>
      <Service name="_notifyStatusChange" args="project,deployment,model" private="true">
        <CodeText>
          <![CDATA[// add custom code
try{
    Context.publishClientEvent('so:' + project.uuid + ':' + deployment.name + ':status', model, {});
}catch(e){
    console.error(e);
}]]>
        </CodeText>
      </Service>
      <Service name="_parseText" args="project,parserFunc,text" private="true">
        <CodeText>
          <![CDATA[//print("_parseText: project="+__prettyPrintJSON(project));
//print("_parseText: text="+text);

var delim = null;
switch (project.delimiterType) {
    case "csv":
        delim = ",";
        break;
    case "tsv":
        delim = "\t";
        break;
    case "userDef":
        delim = project.delimiter;
        break;
}
if (delim == null) delim = ",";

var start = Date.now();
var data = parserFunc.call(this, text, delim);
//print("_parseText: parseSample=" + (Date.now()-start) + "ms");
start = Date.now();
data.schema = this.getSchemaModel(data.schema, data.result);
data.schema.forEach(function(field) {
    if (field.ignore != true) {
        switch (field.data_type) {
            case "string":
            case "boolean":
                field.attr_type = "dimension";
                break;
            case "datetime":
            case "date":
                field.attr_type = "timestamp";
                break;
            default:
                field.attr_type = "measure";
                break;
        }
    }
    else {
        field.attr_type = "N/A";
    }
});
                
//print("_parseText: getSchema=" + (Date.now()-start) + "ms");
start = Date.now();
var pivot = this.getPivotModel(project, data.schema, null);
//print("_parseText: getPivot=" + (Date.now()-start) + "ms");
start = Date.now();
var count = this.getCountModel(project, data.schema, null);
//print("_parseText: getCount=" + (Date.now()-start) + "ms");
start = Date.now();
var output = this.getOutputModel(project, pivot, null);
//print("_parseText: getOutput=" + (Date.now()-start) + "ms");
start = Date.now();
var tests = this.getTestModel(project, data.schema, pivot);
//print("_parseText: getTest=" + (Date.now()-start) + "ms");
start = Date.now();


this.saveProjectSample(project, data.result);
this.saveProjectSchema(project, data.schema);
this.saveProjectPivot(project, pivot);
this.saveProjectCount(project, count);
this.saveProjectOutput(project, output);
this.saveProjectTestModel(project, tests);
]]>
        </CodeText>
      </Service>
      <Service name="_purgeInput" args="project,deployment" private="true">
        <CodeText>
          <![CDATA[var generateDataSuffix = this._generateTestDataSuffix(project);
var addDataSuffix = this._addTestDataSuffix(project);

if (typeof deployment == "string") {      
    deployment = this.loadProjectDeployment(project, deployment);
}

var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null) {
    var subPath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    
    if(!HDFS.exists(fs, subPath)) return;
    
    var files = fs.listStatus(new org.apache.hadoop.fs.Path(subPath), new org.apache.hadoop.fs.PathFilter(accept));

    for(var i = 0; i < files.length; i++) deleteFiles(files[i]);

    HDFS.closeFileSystem(project.hdfsServerURL, fs);
    return true;
}
return false;

function deleteFiles(file){
    fs.delete(file.getPath());
}

function accept(path){
    return isTestFile(path.getName(), generateDataSuffix) || isTestFile(path.getName(), addDataSuffix);
}

function isTestFile(name, suffix){
    print('_purgeInput', name, suffix, name.endsWith(suffix))
    if(name.endsWith(suffix))
        return !!name.substring(0, name.length - suffix.length).match(/^\d+$/);
    return false;
}
]]>
        </CodeText>
      </Service>
      <Service name="_purgeOutput" args="project,deployment" private="true">
        <CodeText>
          <![CDATA[if (!deployment) return;

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var fs = null;
try {
    fs = HDFS.getFileSystem(project.hdfsServerURL);
} catch (ex) {
    ex.printStackTrace();
}
if (fs != null) {
    // delete target data directory on HDFS server
    deleteDirectory(anomaly());
    deleteDirectory(metric());
}

HDFS.closeFileSystem(project.hdfsServerURL, fs);

function getPath(url){
    return (url).substring(project.hdfsServerURL.length);
}

function anomaly(){
    return project.anomalyFileUrl;
}

function metric(){
    return property() ? (property().value || property().defaultValue) : "";
    
    function property(){
        return deployment.parserProfile.common["Parser Properties"].filter(sparkSqlTableUrl)[0] ;
    }
    
    function sparkSqlTableUrl(prop){
         return prop.id === 'spark_sql_table_url';
    }
}

function deleteDirectory(url){
    var path = getPath(url);
    if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
        HDFS.deleteDirectory(fs, path, true);
    }
}

function property(){
    return project.anomalyFileUrl;
    // return deployment.parserProfile.common["Parser Properties"].filter(sparkSqlTableUrl)[0] ;
    
    // function sparkSqlTableUrl(prop){
    //     return prop.id === 'spark_sql_table_url';
    // }
}
]]>
        </CodeText>
      </Service>
      <Service name="_saveProjectFile" args="project,filename,data,encode" private="true">
        <CodeText>
          <![CDATA[//print("_saveProjectFile: project="+__prettyPrintJSON(project));
//print("_saveProjectFile: filename"+filename);
//print("_saveProjectFile: data"+__prettyPrintJSON(data));

if (encode) {
    data = JSON.stringify(data);
}

var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    
    var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/" + filename);
    //print("_saveProjectFile: path="+path);
    Context.writeToFile(path, data);
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_ITEM_TABLE_EXIST_SQL");
    sql = this._doValueSubstitution(sql, {
        uuid: project.uuid,
        name: filename
    });
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project Item", "Exist"], DS, sql, null);
    if (result != null && result.items != null && result.items.length > 0) {
        sql = Context.getLocalResource("PROJECT_ITEM_TABLE_UPDATE_SQL");
        this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project Item", "Update"], DS, sql, [[data, project.uuid, filename]]);
    } else {
        sql = Context.getLocalResource("PROJECT_ITEM_TABLE_INSERT_SQL");
        this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project Item", "Insert"], DS, sql, [[project.uuid, filename, data]]);
    }
}
return true;
]]>
        </CodeText>
      </Service>
      <Service name="_setADFProfileValue" args="properties,propertyId,value" private="true">
        <CodeText>
          <![CDATA[for (var i=0; i<properties.length; i++) {
    if (properties[i]["id"] == propertyId) {
        properties[i]["value"] = value;
    }
}
]]>
        </CodeText>
      </Service>
      <Service name="_stripIndexAttribute" args="arr" private="true">
        <CodeText>
          <![CDATA[if (arr != null) {
    for (var i=0; i<arr.length; i++) {
        delete arr[i]["__index__"];
    }
}
]]>
        </CodeText>
      </Service>
      <Service name="_updateCachedConfig" args="queryConfig" private="true">
        <CodeText>
          <![CDATA[var PLUGIN = queryConfig["dependent-plugins"]["OptionPlugin"];
if (PLUGIN && PLUGIN["url"]) {
    var url = PLUGIN["url"] + "/deleteCache";
    var ret = this._callExternalService(url, {});
    //print(url+"="+__prettyPrintJSON(ret));
    
    var url = PLUGIN["url"] + "/getServiceConfig";
    var ret = this._callExternalService(url, {});
    //print(url+"="+__prettyPrintJSON(ret));
}
]]>
        </CodeText>
      </Service>
      <Service name="_updateProjectOutputHash" args="project,output" private="true">
        <CodeText>
          <![CDATA[function hashCode(str) {
    return str.split('').reduce(function (prevHash, currVal) {
        return (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0
    }, 0);
}

if (!output) return;

var names = output.map(function (item) {
   return item.name + "_" + item.type; 
}).sort();

project.outputHash = hashCode(names.join(':'));
]]>
        </CodeText>
      </Service>
      <Service name="_updateSafePrefix" args="project" private="true">
        <CodeText>
          <![CDATA[var defaultValues = this._getDefaultValues();
project.safePrefix = project.prefix;
if (project.safePrefix.indexOf("*") != -1) {
    project.safePrefix = project.safePrefix.replace(/\*/g, defaultValues["*-substitution"]);
}
]]>
        </CodeText>
      </Service>
      <Service name="addSampleData" args="project,data" private="false">
        <CodeText>
          <![CDATA[//print("addSampleData: project="+__prettyPrintJSON(project));
//print("addSampleData: data="+__prettyPrintJSON(data));

function setFileNameFilterExtension(filename)
{
    // if filename matches the pattern YYYYMMDD_hhmmss_YYYYMMDD_hhmmss_XXXXXXXXX.YYY
    // then we use XXXXXXXXX as the pattern
    var FILENAME_PATTERN = new RegExp("[0-9]{8}_[0-9]{6}_[0-9]{8}_[0-9]{6}_(.*)\\.(.*)");
    var result = filename.match(FILENAME_PATTERN);
    //print("addSampleData: getFileNameFilter="+__prettyPrintJSON(result));
    if (result != null && result.length == 3) {
        project.filenameFilter = result[1];
        project.filenameExtension = result[2];
    }
    else {
        FILENAME_PATTERN = new RegExp("[0-9_]+_([a-zA-Z].*)\\.(.*)");
        result = filename.match(FILENAME_PATTERN);
        //print("addSampleData: getFileNameFilter="+__prettyPrintJSON(result));
        if (result != null && result.length == 3) {
            project.filenameFilter = result[1];
            project.filenameExtension = result[2];
        }
        else {
            // if not, set file pattern to ""
            project.filenameFilter = "";
            var dot = filename.lastIndexOf(".");
            if (dot != -1) {
                project.filenameExtension = filename.substring(dot+1);
            }
            else {
                project.filenameExtension = "";
            }
        }
    }
}

var System = java.lang.System;
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var uuid = project.uuid;
var delimiterType = project.delimiterType;
var delimiter = project.delimiter;
project = this._loadProjectFile({uuid: uuid}, 'project.json', true); 

var fileTypeList = ["application/vnd.ms-excel", "text/csv", "application/json"];
if (project != null) {
    var tempDirectory = System.getProperty("java.io.tmpdir");
    var text = Context.getFileAsString(tempDirectory + "/" + data.uid);
    project.uuid = uuid;
    project.delimiterType = delimiterType;
    project.delimiter = delimiter;
    this._saveProjectFile(project, "sample.txt", text, false);
    this._deleteProjectFile(project, "schema.json");
    this._deleteProjectFile(project, "pivot.json");
    this._deleteProjectFile(project, "output.json");
    this._deleteProjectFile(project, "sample.json");
    project.sample = {
        name   : data.name,
        size   : data.size,
        type   : data.type || "text/csv",
    };
    
    if (fileTypeList.indexOf(project.sample.type) == -1) {
        return {
            error: project.sample.type + " is not supported, please upload csv or json file..."
        };
    }
    
    setFileNameFilterExtension(data.name);
    this.parseSampleData(project);
    this._saveProjectFile(project, "project.json", project, true);
    project.__filter_changed__ = true;
    this.updateProjectAndDeploymentDefaultValues(project);
    return {
        result : project,
    };
} else {
    return {
        error  : "Project not found.",
    };
}

/**
var dirName = "nuova_stella/" + uuid;
if (this._fsHasDirectory(dirName)) {
    var tempDirectory = System.getProperty("java.io.tmpdir");
    if (this._fsMoveFile(tempDirectory + "/" + data.uid, dirName+"/sample.txt")) {
        this._deleteProjectFile(project, "schema.json");
        this._deleteProjectFile(project, "pivot.json");
        this._deleteProjectFile(project, "output.json");
        this._deleteProjectFile(project, "sample.json");
        project = this._fsLoadFromFile(dirName+"/project");
        if (project != null) {
            if (project.uuid == null) project.uuid = uuid;
            project.sample = {
                name   : data.name,
                size   : data.size,
                type   : data.type || "text/csv",
            };
            setFileNameFilterExtension(data.name);
            this.parseSampleData(project);
            this._fsSaveToFile(dirName+"/project", JSON.stringify(project));
        }
        return {
            result : project,
        };
    }
    else {
        return {
            error  : "Move failed. Check server log.",
        };
    }
}
return {
    error  : "Project not found.",
};
*/
]]>
        </CodeText>
      </Service>
      <Service name="addTestData" args="project,deployment,data" private="false">
        <CodeText>
          <![CDATA[//print("addTestData: project="+__prettyPrintJSON(project));
//print("addTestData: data="+__prettyPrintJSON(data));

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var System = java.lang.System;
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;
var Path = org.apache.hadoop.fs.Path;

var tempDirectory = System.getProperty("java.io.tmpdir");
var uploadedPath = tempDirectory + "/" + data.uid;
var uploadedData = Context.getFileAsString(uploadedPath);


var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null) {
    var subPath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    var targetPath = subPath + "/" + Date.now() + this._addTestDataSuffix(project);
    var uploadPath = subPath + "/" + Date.now() + this._addTestDataSuffix(project, { ignoreExtensionName : true }) + "-uploading";
    HDFS.writeFile(fs, uploadPath, uploadedData);
    targetPath = new Path(targetPath);
    fs.rename(new Path(uploadPath), targetPath);
    var now = System.currentTimeMillis();
    fs.setTimes(targetPath, now, now);
    HDFS.closeFileSystem(project.hdfsServerURL, fs);
}
]]>
        </CodeText>
      </Service>
      <Service name="checkInvalidColumns" args="schema" private="false">
        <CodeText>
          <![CDATA[var RESERVED_FIELD_NAME = ["val", "var", "type", "for", "LONG", "abstract", "case", "catch", "class", "def", "do", "else", "extends", 
    "false", "final", "finally", "for", "forSome", "if", "implicit", "import", "lazy", "match", "new", "null", "object", "override", 
    "package", "private", "protected", "return", "sealed", "super", "this", "throw", "trait", "try", "true", "type", "val", "var", 
    "while", "with", "yield",
];
var invalidFields = [];

// check for invalid field name, etc
for (var i=0, n=schema.length; i<n; i++) {
    var field = schema[i];
    if (field.ignore != true) {
        if (RESERVED_FIELD_NAME.indexOf(field.name) != -1) {
            invalidFields.push(field.name);
        }
    }
}
if (invalidFields.length > 0) {
    throw "INVALID_FIELD_NAME: " + invalidFields.join(", ");
}]]>
        </CodeText>
      </Service>
      <Service name="checkTestData" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[//print("checkTestData: project="+__prettyPrintJSON(project));

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

if (deployment == null) {
    return [];
}

var files = [];
var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null) {
    var path = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    files = HDFS.listFiles(fs, path, true, false);
    HDFS.closeFileSystem(project.hdfsServerURL, fs);
}

var result = [];
files.forEach(function(file) {
    result.push({
        name   : file.name,
        size   : Number(file.size),
        status : "Unknown",
    });
});

var processed = this._getFilesFromParserAudits(project, deployment);
result.forEach(function(item) {
    if (processed[item.name] == true) {
        item.status = "Processed";
    }
});

//print("checkTestData: result="+__prettyPrintJSON(result));
return result;
]]>
        </CodeText>
      </Service>
      <Service name="cleanupOldArtifacts" args="project,deployment,options" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

if (!options) {
    options = {
        resetParserSource: false,
        resetParserTarget: false,
    };
}

var queryConfig = this.getQueryConfig();
var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
var sql = Context.getLocalResource("MODEL_INFO_SELECT_SQL");

sql = this._doValueSubstitution(sql, {
    uuid: project.uuid,
    name: deployment.name
});
var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Model Info Item", "Select"], DS, sql, null);
if (result != null && result.items != null && result.items.length > 0) {
    var item = result.items[0];
    //handle hive table and hdfs directory
    var defaultValues = this._getDefaultValues();
    
    var deploymentGlobalMap = {};
    deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
        deploymentGlobalMap[item.id] = item;
    });
    
    var anomalyGlobalMap = {};
    deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
        anomalyGlobalMap[item.id] = item;
    });
    
    var oldHdfsServerURL = item["hdfs_server_url"];
    var oldSourcePath = item["source_path"];
    var oldSparkSqlTablePath = item["spark_sql_table_path"];
    var oldSparkSqlTable = item["spark_sql_table"];
    var oldAnomalyFilePath = item["anomaly_file_path"];
    var oldDroppedMetric = item["dropped_metric"];
    var oldMetrics = item["metric_id_list"];
    var oldADMName = item["adm_name"];
    var newHdfsServerURL = project.hdfsServerURL;
    var newSourcePath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    var newSparkSqlTablePath = (deploymentGlobalMap["spark_sql_table_url"].value || deploymentGlobalMap["spark_sql_table_url"].defaultValue).substring(project.hdfsServerURL.length);
    var newSparkSqlTable = deploymentGlobalMap["spark_sql_table"].value || deploymentGlobalMap["spark_sql_table"].defaultValue;
    var newAnomalyFileUrl = project.anomalyFileUrl || (project.hdfsServerURL + defaultValues["anomaly-path"] + project.sourceGroup);
    var newAnomalyFilePath = newAnomalyFileUrl.substring(project.hdfsServerURL.length);
    var newDroppedMetric = anomalyGlobalMap["dropped_metric"].value || anomalyGlobalMap["dropped_metric"].defaultValue;
    var newADMName = anomalyGlobalMap["adm_name_m"].value || anomalyGlobalMap["adm_name_m"].defaultValue;
    project.detail = this.loadProject(project);
    var systemModel = this.generateSystemModel(project, deployment, "demo", project.detail.schema, project.detail.pivot, project.detail.count, 
                                   project.detail.enrich, project.detail.output, project.detail.qdc, project.detail.metric);
    var newMetrics = this._getMetricsInSystemModel(systemModel);
    var defaultODAQS = this._getDefaultODAQS();
    if (oldHdfsServerURL != newHdfsServerURL || oldSourcePath != newSourcePath) {
        if (options.resetParserSource && oldHdfsServerURL != null && oldSourcePath != null && oldSourcePath.indexOf(defaultValues["source-path"]) != -1) {
            deleteHDFSDirectory(oldHdfsServerURL, oldSourcePath);
        }
    }
    if (options.resetDataResourceModel && oldSparkSqlTable != newSparkSqlTable && oldSparkSqlTable != null) {
        var dsItem = {};
        dsItem["tableName"] = JSON.stringify({"name" : oldSparkSqlTable});;
        dsItem["dataSource"] = "custom";

        if (defaultODAQS) {
            dsItem["jdbcURL"] = defaultODAQS["connectionUrl"];
            dsItem["jdbcUsername"] = defaultODAQS["user"];
            dsItem["jdbcPassword"] = defaultODAQS["password"];
        }
        this._hiveDeleteTable(dsItem);
    }
    if (oldHdfsServerURL != newHdfsServerURL || oldSparkSqlTablePath != newSparkSqlTablePath) {
        if (options.resetParserTarget && oldHdfsServerURL != null && oldSparkSqlTablePath != null) {
            deleteHDFSDirectory(oldHdfsServerURL, oldSparkSqlTablePath);
        }
    }
    if (oldHdfsServerURL != newHdfsServerURL || oldAnomalyFilePath != newAnomalyFilePath) {
        if (options.resetParserTarget && oldHdfsServerURL != null && oldAnomalyFilePath != null) {
            deleteHDFSDirectory(oldHdfsServerURL, oldAnomalyFilePath);
        }
    }
    if (oldDroppedMetric != newDroppedMetric && oldDroppedMetric != null) {
        var dsItem = {};
        dsItem["tableName"] = JSON.stringify({"name" : oldDroppedMetric});;
        dsItem["dataSource"] = "custom";

        if (defaultODAQS) {
            dsItem["jdbcURL"] = defaultODAQS["connectionUrl"];
            dsItem["jdbcUsername"] = defaultODAQS["user"];
            dsItem["jdbcPassword"] = defaultODAQS["password"];
        }
        this._hiveDeleteTable(dsItem);
    }
    if (oldADMName != newADMName && oldADMName != null) {
        this._cleanupAnomalySOL(queryConfig, oldADMName);
    }
    if (oldMetrics != null) {
        oldMetrics = oldMetrics.split(",");
        var deleteMetrics = [];
        for (var i = 0; i < oldMetrics.length; i++) {
            var find = false;
            for (var j = 0; j < newMetrics.length; j++) {
                if (oldMetrics[i] == newMetrics[j]) {
                    find = true;
                    break;
                }
            }
            if (!find) {
                deleteMetrics.push([oldMetrics[i]]);
            }
        }
        if (deleteMetrics.length > 0) {
            this._clenupMetricInfo(queryConfig, deleteMetrics);
            this._cleanupMetricQDC(queryConfig, deleteMetrics);
            this._cleanupIncidentConfig(queryConfig, deleteMetrics);
            this._cleanupParseTable(queryConfig, deleteMetrics);
            this._cleanupIncidentSummary(queryConfig, deleteMetrics);
        }
    }
}

sql = Context.getLocalResource("MODEL_INFO_RESET_SQL");
this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Model Info", "Reset"], DS, sql, [[project.uuid, deployment.name]]);

function deleteHDFSDirectory(hdfsServerURL,path) {
    var fs = null;
    try {
        fs = HDFS.getFileSystem(hdfsServerURL);
    } catch (ex) {
        ex.printStackTrace();
    }
    if (fs != null) {
        if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
            HDFS.deleteDirectory(fs, path, true);
        }

        HDFS.closeFileSystem(hdfsServerURL, fs);
    }
}
]]>
        </CodeText>
      </Service>
      <Service name="createProject" args="project" private="false">
        <CodeText>
          <![CDATA[var prjName = project.svc + "|" + project.comp + "|" + project.app;
var prjList = this.listProjectPickerList();
if (prjList.filter(function (item) {
    return item.prjName == prjName;
}).length > 0) {
    return {
        error  : "Project " + prjName + " already exist.",
    }
}

project.__version__ = 0.8;
this._initProject(project);

var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var dirName = "nuova_stella/" + project.uuid;
    if (!this._fsHasDirectory(dirName)) {
        if (!this._fsCreateDirectory(dirName)) {
            return {
                error  : "Cannot create project directory.",
            };
        }
        this._fsSaveToFile(dirName+"/project", JSON.stringify(project));
        var defaultDeployment = this.generateDeploymentDefaultValues(project, 'Default');
        this.saveProjectDeployment(project, defaultDeployment, 'Default');
        return {
            result : project,
        };
    }
    return {
        error  : "Project already exist.",
    };
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_TABLE_EXIST_SQL");
    sql = this._doValueSubstitution(sql, {
        uuid: project.uuid
    });
    
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project", "Exist"], DS, sql, null);
    if (result != null && result.items != null && result.items.length > 0) {
        return {
            error  : "Project already exist.",
        };
    }
    
    this.saveProjectModel(project);
    var defaultDeployment = this.generateDeploymentDefaultValues(project, 'Default');
    this.saveProjectDeployment(project, defaultDeployment, 'Default');
    
    return {
        result : project,
    };
}
]]>
        </CodeText>
      </Service>
      <Service name="deleteImportProject" args="uuid" private="false">
        <CodeText>
          <![CDATA[this._fsDeleteDirectories("nuova_stella/" + uuid);

return true;]]>
        </CodeText>
      </Service>
      <Service name="deleteProject" args="project,options" private="false">
        <CodeText>
          <![CDATA[//so cli rest
var projectData = this.loadProjectByName(project);
if(projectData == null) throw project + ' does not exsit.'
this.deleteProjects([projectData], options);]]>
        </CodeText>
      </Service>
      <Service name="deleteProjects" args="projects,options" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    var FileUtils = org.apache.commons.io.FileUtils;
    
    var self = this;
    projects.forEach(function(project) {
        var project = self.loadProjectByUUID(project.uuid);
        var deployments = self._loadProjectDeploymentList(project, true);
        deployments.forEach(function (deployment) {
            if (deployment.value) {
                self.resetProject(project, deployment.value, options);
            }
        });
    
        var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid);
        //print("deleteProject: path="+path);
        var file = new File(path);
        if (file.exists() && file.isDirectory()) {
            FileUtils.deleteDirectory(file);
            //print("deleteProject: deleted="+path);
        }
        else {
            throw "File not found: " + path;
        }
    });
    return true;
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var self = this;
    projects.forEach(function(project) {
        var project = self.loadProjectByUUID(project.uuid);
        
        var deployments = self._loadProjectDeploymentList(project, true);
        deployments.forEach(function (deployment) {
            if (deployment.value) {
                self.resetProject(project, deployment.value, options);
            }
        });
    
        var sql = Context.getLocalResource("PROJECT_ITEM_TABLE_DELETE_ALL_SQL");
        self.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project Item", "Delete"], DS, sql, [[project.uuid]]);
        
        sql = Context.getLocalResource("PROJECT_DEPLOYMENT_DELETE_ALL_SQL");
        self.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Deployment Item", "Delete"], DS, sql, [[project.uuid]]);
        
        sql = Context.getLocalResource("PROJECT_TABLE_DELETE_SQL");
        self.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project", "Delete"], DS, sql, [[project.uuid]]);
        
        sql = Context.getLocalResource("MODEL_INFO_DELETE_ALL_SQL");
        self.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project", "Delete"], DS, sql, [[project.uuid]]);
    });
    return true;
}
]]>
        </CodeText>
      </Service>
      <Service name="deleteTestData" args="project,deployment,filenames" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null) {
    var subPath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);

    if (filenames != null && filenames.length > 0) {
        // delete selected
        for (var i=0; i<filenames.length; i++) {
            var path = subPath + "/" + filenames[i];
            HDFS.deleteFile(fs, path);
        }
    }
    else {
        var path = subPath;
        this._purgeInput(project, deployment);
    }
    HDFS.closeFileSystem(project.hdfsServerURL, fs);
    return true;
}
return false;

]]>
        </CodeText>
      </Service>
      <Service name="deployProject" args="project,deployment,mode,autoStart" private="false">
        <CodeText>
          <![CDATA[// so cli rest
var projectData = this.loadProjectByName(project);
if(projectData == null){
    throw "Project " + project + " does not exist.";
}
this.updateProject(projectData, deployment); 
if(mode === 'deploy') this.updateSystemModel(projectData, deployment, "deploy");
if(projectData.configs) this.updateIncidentConfig(projectData, deployment);
if(autoStart == 'true' || autoStart == null || autoStart === true){
    this.startParserModel(projectData, deployment, "RT");
    this.startAnomalyModel(projectData, deployment, "RT");
}]]>
        </CodeText>
      </Service>
      <Service name="doImportProject" args="uuid,overrideuuid" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
var project = this._fsLoadFromFile("nuova_stella/" + uuid + "/project");
if (project == null) {
    this._fsDeleteDirectories("nuova_stella/" + uuid);
    return {
        error : "ProjectNotFoundException",
    };
}

var self = this;
var names = this._fsListFiles("nuova_stella/" + uuid);
var targetuuid = uuid;
if (overrideuuid != null) {
    targetuuid = overrideuuid;
}

project.uuid = targetuuid;
names.forEach(function (filename) {
    var content = self._fsStringFromFile('nuova_stella/' + uuid + '/' + filename);
    if (filename.endsWith(".deployment")) {
        var endsWith = ".deployment";
        var name = filename.substring(0, filename.length - endsWith.length);
        self.importProjectDeployment(project, name, content);
    } else {
        self._saveProjectFile({uuid: targetuuid}, filename, content, false);
    }
});

var defaultValues = this._getDefaultValues();
project.anomalyFileUrl = defaultValues["hdfs-server-url"] +  project.anomalyFileUrl.substring(project.hdfsServerURL.length);
project.hdfsServerURL = defaultValues["hdfs-server-url"];

this.migrateSOproject(project);
self.saveProjectModel(project);
this._fsDeleteDirectories("nuova_stella/" + uuid);

return {
    result : project,
};]]>
        </CodeText>
      </Service>
      <Service name="downloadTestData" args="project,deployment,filename" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var File = java.io.File;
var System = java.lang.System;
var FileUtils = org.apache.commons.io.FileUtils;
var UUID = java.util.UUID;

function createTempFileForDownload(content)
{
    var tempDirectory = System.getProperty("java.io.tmpdir");
    var tgtFile = new File(tempDirectory + "/" + UUID.randomUUID().toString());
    FileUtils.writeStringToFile(tgtFile, content, "UTF-8");
    
    TimerTask.setTimeout("DeleteTempDownloadFile", 10, function(path) {
        var file = new File(path);
        //print("Deleting download file: "+ file.getPath());
        if (file.delete()) {
            //print("Download file: " + file.getPath() + " deleted");
        }
        else {
            print("Download file: " + file.getPath() + " delete exception");
        }
    }, tgtFile.getPath());
    
    return tgtFile.getName();
}


var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null) {
    var subPath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    var path = subPath + "/" + filename;
    var content = HDFS.readFile(fs, path);
    HDFS.closeFileSystem(project.hdfsServerURL, fs);
    if (content != null) {
        return createTempFileForDownload(content);
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="evalPreScript" args="project,script" private="false">
        <CodeText>
          <![CDATA[function toCsvLine(arr) {
    var buf = [];
    for (var j=0, jN=arr.length; j<jN; j++) {
        var val = arr[j];
        if (val != null) {
            if (typeof val == "string") {
                buf.push('"'+val+'"');
            }
            else {
                buf.push(String(val));
            }
        }
        else {
            buf.push("");
        }
    }
    return buf.join(",");
}

var buf = [];
buf.push("var mapJSONtoCSV = function(jsonText, isRuntime) {");
buf.push(script);
buf.push("}");

var scriptText = buf.join("\n");
//print("evalPreScript: scriptText="+scriptText);

var jsonText = this.getPreContent(project);
//print("evalPreScript: jsonText="+jsonText);

var manager = new javax.script.ScriptEngineManager();
var engine = manager.getEngineByName("nashorn");
engine.eval(scriptText);

var retval = null;
var retval = null;
if (project.sample.jsonEncoding == "LINE") {
    var lines = jsonText.split("\n");
    lines.forEach(function (line) {
        if (retval == null) {
            try {
                retval = engine.invokeFunction("mapJSONtoCSV", [line, false]);
            } catch (ex) {
                print("evalPreScript: invalid jsonText="+line);
            }
        } else {
            var tmp = null;
            try {
                tmp = engine.invokeFunction("mapJSONtoCSV", [line, false]);
            } catch (ex) {
                print("evalPreScript: invalid jsonText="+line);
            }
            if (retval != null && retval.cols != null && retval.data != null && retval.type != null && tmp != null && tmp.data != null) {
                retval.data = retval.data.concat(tmp.data);
            } else if (retval != null && retval.concat != null && tmp != null) {
                retval = retval.concat(tmp);
            }
        }
    });
    //print("evalPreScript: jsonText="+jsonText);
} else {
    retval = engine.invokeFunction("mapJSONtoCSV", [jsonText, false]);
}

//eval(scriptText);
//var retval = mapJSONtoCSV(jsonText, false);

//print("evalPreScript: retval="+__prettyPrintJSON(retval));

if (retval != null && retval.cols != null && retval.data != null && retval.type != null) {
    this.updatePreResult(project, retval);
    var parserName = this._getTemplateForFileType(project, "parse-sample", retval.type);
    if (parserName != null) {
        var parserFunc = this[parserName];
        if (parserFunc != null) {
            var csv = [];
            csv.push(toCsvLine(retval.cols));
            for (var j=0, jN=retval.data.length; j<jN; j++) {
                csv.push(toCsvLine(retval.data[j]));
            }
            this._parseText(project, parserFunc, csv.join("\n"));
        }
    }
}

//print(retval);
return retval;
]]>
        </CodeText>
      </Service>
      <Service name="evalTestScript" args="project,script" private="false">
        <CodeText>
          <![CDATA[//print("evalTestScript: project="+__prettyPrintJSON(project));
//print("evalTestScript: script="+script);

var schema = this._loadProjectFile(project, "schema.json", true);
var tests = this.loadProjectTestModel(project);
var data = this._generateTestData(null, schema, tests[0], project.sample.type);
//print("evalTestScript: data="+__prettyPrintJSON(data));
if (data != null) {
    var buf = [];
    buf.push("var formatTestData = function(data) {");
    buf.push(script);
    buf.push("}");

    var scriptText = buf.join("\n");
    //print("evalTestScript: scriptText="+scriptText);
    
    var manager = new javax.script.ScriptEngineManager();
    var engine = manager.getEngineByName("nashorn");
    engine.eval(scriptText);
    data = engine.invokeFunction("formatTestData", [data]);

    //eval(scriptText);
    //data = formatTestData(data);

    //print("evalTestScript: result="+__prettyPrintJSON(data));
}
return data;
]]>
        </CodeText>
      </Service>
      <Service name="exportProject" args="project" private="false">
        <CodeText>
          <![CDATA[
var tgtFile = this._exportProject(loadProject.call(this));
return new org.restlet.representation.FileRepresentation(tgtFile, org.restlet.data.MediaType.APPLICATION_ZIP);

function loadProject(){
    var projectData = this.loadProjectByName(project);  
    if(projectData == null)
        throw "Project " + project + " does not exist."
    return projectData;

}]]>
        </CodeText>
      </Service>
      <Service name="exportProjectFileName" args="project" private="false">
        <CodeText>
          <![CDATA[var tgtFile = this._exportProject(project);
return tgtFile.getName();
]]>
        </CodeText>
      </Service>
      <Service name="exportTestData" args="project" private="false">
        <CodeText>
          <![CDATA[//print("exportTestData: project="+__prettyPrintJSON(project));

var System = java.lang.System;
var File = java.io.File;
var FileUtils = org.apache.commons.io.FileUtils;
var UUID = java.util.UUID;

function padStr(str, len)
{
    while (str.length < len) {
        str = "0" + str;
    }
    return str;
}

function getDateTimeStr()
{
    var dt = new Date();
    return "" + dt.getFullYear() + padStr(dt.getMonth()+1, 2) + padStr(dt.getDate(), 2)
         + "_" + padStr(dt.getHours(), 2) + padStr(dt.getMinutes(), 2) + padStr(dt.getSeconds(), 2);
}

function createTempFileForDownload(content)
{
    var tempDirectory = System.getProperty("java.io.tmpdir");
    var tgtFile = new File(tempDirectory + "/" + UUID.randomUUID().toString());
    FileUtils.writeStringToFile(tgtFile, content, "UTF-8");
    
    TimerTask.setTimeout("DeleteTempDownloadFile", 10, function(path) {
        var file = new File(path);
        //print("Deleting download file: "+ file.getPath());
        if (file.delete()) {
            //print("Download file: " + file.getPath() + " deleted");
        }
        else {
            print("Download file: " + file.getPath() + " delete exception");
        }
    }, tgtFile.getPath());

    var filename = null;
    switch (project.sample.type) {
        case "text/csv":
        case "application/vnd.ms-excel":
            filename = getDateTimeStr() + "_" + project.filenameFilter + ".csv";
            break;
        case "application/json":
            filename = getDateTimeStr() + "_" + project.filenameFilter + ".json";
            //filename = project.filenameFilter + "." + getDateTimeStr() + ".part-0000";
            break;
    }
    
    return {
        uuid : tgtFile.getName(),
        name : filename,
    };
}

var schema = this._loadProjectFile(project, "schema.json", true);
var tests = this.loadProjectTestModel(project);
if (tests.length > 0) {
    // just the first one
    var data = this._generateTestData(project, schema, tests[0], project.sample.type);
    if (data != null) {
        return createTempFileForDownload(data);
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="formatDateTime" args="format,startEpoch,endEpoch" private="false">
        <CodeText>
          <![CDATA[var JavaDate = java.util.Date;
var SimpleDateFormat = java.text.SimpleDateFormat;

var formatter = new SimpleDateFormat(format);
return {
    startDateTime : formatter.format(new JavaDate(startEpoch*1000)),
    endDateTime   : formatter.format(new JavaDate(endEpoch*1000)),
};

]]>
        </CodeText>
      </Service>
      <Service name="generateAnomalyModel" args="project,deployment,output" private="false">
        <CodeText>
          <![CDATA[if (project == null || output == null) return false;

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var template = this._getTemplate(project, "anomaly-model");
if (template != null) {
    var helperName = template.helper.generate;
    if (helperName != null) {
        var helperFunc = this[helperName];
        if (helperFunc != null) {
            return helperFunc.call(this, project, deployment, output, template.uri);
        }
    }
}
return false;
]]>
        </CodeText>
      </Service>
      <Service name="generateParserModel" args="project,deployment,schema,pivot,count,enrich,output" private="false">
        <CodeText>
          <![CDATA[if (project == null || schema == null || pivot == null || count == null || output == null) return null;

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var template = template = this._getTemplate(project, "parser-model");
if (template != null) {
    var helperName = template.helper.generate;
    if (helperName != null) {
        var helperFunc = this[helperName];
        if (helperFunc != null) {
            return helperFunc.call(this, project, deployment, schema, pivot, count, enrich, output, template.uri);
        }
    }
}
return false;
]]>
        </CodeText>
      </Service>
      <Service name="generateResourceModel" args="project,deployment,output" private="false">
        <CodeText>
          <![CDATA[if (project == null || output == null) return null;

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var template = this._getTemplate(project, "resource-model");
if (template != null) {
    var model = this._mrGetModel(template.uri);
    if (model != null && model != "") {
        model = JSON.parse(model);
        var helperName = template.helper.generate;
        if (helperName != null) {
            var helperFunc = this[helperName];
            if (helperFunc != null) {
                var obj = helperFunc.call(this, model, project, deployment, output);
                obj.template = template.uri;
                return obj;
            }
        }
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="generateSystemModel" args="project,deployment,mode,schema,pivot,count,enrich,output,qdc,metric" private="false">
        <CodeText>
          <![CDATA[if (project == null || schema == null || pivot == null || count == null || output == null) return null;

//print("generateSystemModel: mode="+mode);
if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}
var template = this._getTemplate(project, "system-model");
if (template != null) {
    var helperName = template.helper.generate;
    if (helperName != null) {
        var helperFunc = this[helperName];
        if (helperFunc != null) {
            return helperFunc.call(this, project, deployment, mode, schema, pivot, count, enrich, output, qdc, metric);
        }
    }
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="generateTestData" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[//print("generateTestData: project="+__prettyPrintJSON(project));
if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var System = java.lang.System;
var Path = org.apache.hadoop.fs.Path;

var subPath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
function addTestData(content)
{
    var fs = HDFS.getFileSystem(project.hdfsServerURL);
    if (fs != null) {
        var targetPath = null;
        var uploadPath = null;
        var now = Date.now();
        switch (project.sample.type) {
            case "text/csv":
            case "application/vnd.ms-excel":
                targetPath = subPath + "/" + now + this._generateTestDataSuffix(project);
                uploadPath = subPath + "/" + now + this._generateTestDataSuffix(project, { ignoreExtensionName : true }) + "-uploading";
                break;
            case "application/json":
                targetPath = subPath + "/" + now + suffix + ".json";
                uploadPath = subPath + "/" + now + suffix + "-uploading";
                //targetPath = defaultValues["source-path"] + sourceGroup + "/" + project.filenameFilter + "_." + now + ".part-0000";
                //uploadPath = defaultValues["source-path"] + sourceGroup + "/" + project.filenameFilter + "_." + now + ".uploading-0000";
                break;
        }
        if (targetPath != null && uploadPath != null) {
            HDFS.writeFile(fs, uploadPath, content);
            targetPath = new Path(targetPath);
            fs.rename(new Path(uploadPath), targetPath);
            var now = System.currentTimeMillis();
            fs.setTimes(targetPath, now, now);
            HDFS.closeFileSystem(project.hdfsServerURL, fs);
        }
    }
}

var schema = this._loadProjectFile(project, "schema.json", true);
var tests = this.loadProjectTestModel(project);
if (tests.length > 0) {
    var data = this._generateTestData(project, schema, tests[0], project.sample.type);
    if (data != null) {
        addTestData(data);
    }
}
return true;
]]>
        </CodeText>
      </Service>
      <Service name="getAnomalyModelName" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['anomaly_model_name'].value || deploymentGlobalMap['anomaly_model_name'].defaultValue;
]]>
        </CodeText>
      </Service>
      <Service name="getAnomalyModelSpace" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['anomaly_model_space'].value || deploymentGlobalMap['anomaly_model_space'].defaultValue;
]]>
        </CodeText>
      </Service>
      <Service name="getAnomalyModelURL" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var name = this.getAnomalyModelName(project, deployment);
var space = this.getAnomalyModelSpace(project, deployment);
var url = "/app/spark/space/" + space + "/sparkm/" + name;
if (!this._mrHasModel(url)) {
    url = "/app/spark/user/" + Context.getCurrentUserId() + "/sparkm/" + name;
}
return url;
]]>
        </CodeText>
      </Service>
      <Service name="getAnomalyRuntimeStatus" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var anomalyStatus = "NOT_FOUND";
var uri = this.getAnomalyModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    anomalyStatus = Context.GET("/rest"+uri+"?op=getrunningstatus" +  ((instance != null) ? ("&instance=" + instance) : ""));
    //print("getAnomalyRuntimeStatus: " + uri + "=" + anomalyStatus);
    anomalyStatus = this._getMappedStatus(anomalyStatus);
}
//print("getAnomalyRuntimeStatus: " + uri + "=" + anomalyStatus);
return anomalyStatus;
]]>
        </CodeText>
      </Service>
      <Service name="getBaselineScoreModelURL" args="project" private="false">
        <CodeText>
          <![CDATA[//print("getBaselineScoreModelURL: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-baseline-score"];
if (service != null && service["adf-model"] != null && this._mrHasModel(service["adf-model"])) {
    return service["adf-model"];
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="getCountModel" args="project,schema,oldModel" private="false">
        <CodeText>
          <![CDATA[if (oldModel == null) oldModel = [];
var count = [];
if (oldModel.length > 0) {
    var fields = {};
    for (var i=0; i<schema.length; i++) {
        fields[schema[i].name] = true;
    }
    //print("getCountModel: fields="+__prettyPrintJSON(fields));
    //print("getCountModel: oldModel="+__prettyPrintJSON(oldModel));
    for (var i=0; i<oldModel.length; i++) {
        if (fields[oldModel[i].fieldName] == true) {
            var copy = JSON.parse(JSON.stringify(oldModel[i]));
            copy.encodeMetricName = copy.metricName.replace(/[^a-z0-9+]+/gi, '_');
            count.push(copy);
        }
    }
}
this._stripIndexAttribute(count);
return count;
]]>
        </CodeText>
      </Service>
      <Service name="getDeclaredEventModelURL" args="project" private="false">
        <CodeText>
          <![CDATA[//print("getDeclaredEventModelURL: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-declared-event"];
if (service != null && service["adf-model"] != null && this._mrHasModel(service["adf-model"])) {
    return service["adf-model"];
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="getEnrichModel" args="project,pivot,oldModel" private="false">
        <CodeText>
          <![CDATA[if (pivot == null) {
    return {
        leftFields  : [],
        rightFields : [],
        joinClause  : [],
    };
}

var leftFieldNames = {};
var leftFields = [];

if (pivot.dimensions) {
    for (var i=0, n=pivot.dimensions.length; i<n; i++) {
        leftFields.push({
            name  : pivot.dimensions[i]["name"],
            label : pivot.dimensions[i]["label"] || pivot.dimensions[i]["name"],
            //type  : "string",
            type: pivot.dimensions[i]["data_type"]
        });
        leftFieldNames[pivot.dimensions[i]["name"]] = true;
    }
}
leftFields.push({
    name  : "ts",
    label : "Timestamp",
    type  : "datetime",
});
leftFieldNames["ts"] = true;
leftFields.push({
    name  : "metric_name",
    label : "Metric Name",
    type  : "string",
});
leftFieldNames["metric_name"] = true;
leftFields.push({
    name  : "metric_value",
    label : "Metric Value",
    type  : "long",
});
leftFieldNames["metric_value"] = true;
leftFields.push({
    name  : "aggr_func",
    label : "Aggregate Function",
    type  : "string",
});
leftFieldNames["aggr_func"] = true;
leftFields.push({
    name  : "parse_target_app",
    label : "Target App",
    type  : "string",
});
leftFieldNames["parse_target_app"] = true;
leftFields.push({
    name  : "parse_target_metric",
    label : "Target Metric",
    type  : "string",
});
leftFieldNames["parse_target_metric"] = true;

var oldLeftField = {};
var oldLeftIncl  = {};
var oldRightAlias = {};
if (oldModel != null && oldModel.joinClause != null) {
    for (var i=0; i<oldModel.joinClause.length; i++) {
        var record = oldModel.joinClause[i];
        if (leftFieldNames[record.leftField] == true) {
            //oldLeftField[record.rightField] = record.leftField;
            oldLeftField[record.rightColumn] = record.leftField;
        }
        
        //oldLeftIncl[record.rightField]  = record.include;
        oldLeftIncl[record.rightColumn]  = record.include;
        oldRightAlias[record.rightColumn]  = record.rightField; // this is right alias
    }
}

var rightFields = [];
if (oldModel != null && oldModel.rightFields != null) {
    rightFields = oldModel.rightFields;
}

var joinClause = [];
for (var i=0; i<rightFields.length; i++) {
    var rightField = rightFields[i];
    var clause = {
        leftField  : oldLeftField[rightField.name] != null ? oldLeftField[rightField.name] : "",
//        rightField : rightField.name,        
        rightColumn : rightField.name,
        type       : rightField.type,
        include    : oldLeftIncl[rightField.name] != false,
    };
    if (oldRightAlias[rightField.name] == null) {
        clause.rightField = rightField.name;
    } else {
        clause.rightField = oldRightAlias[rightField.name];
    }
    
    joinClause.push(clause);
}

this._stripIndexAttribute(leftFields);
this._stripIndexAttribute(rightFields);
this._stripIndexAttribute(joinClause);

return {
    leftFields  : leftFields,
    rightFields : rightFields,
    joinClause  : joinClause,
};
]]>
        </CodeText>
      </Service>
      <Service name="getMetricModel" args="project,pivot,count,oldModel" private="false">
        <CodeText>
          <![CDATA[//print("getMetricModel: project="+__prettyPrintJSON(project));
if (project.subservices == null || project.subservices.length == 0) return [];

var oldValues = {};
if (oldModel != null) {
    for (var i=0, iN=oldModel.length; i<iN; i++) {
        var model = oldModel[i];
        for (var key in model) {
            if (key != "_metricName_" && key != "_metricLabel_") {
                oldValues[model._metricName_+"["+key+"]"] = model[key];
            }
        }
    }
}

var metricList = this.___getMetricList(pivot || [], count || []);
//print("getMetricModel: metricList="+__prettyPrintJSON(metricList));

var metrics = [];
var key = null;
for (var i=0, iN=metricList.length; i<iN; i++) {
    var metric = {
        _metricName_  : (metricList[i]).name,
        _metricLabel_ : (metricList[i]).label,
    };
    
    key = project.svc + "|" + project.comp + "|" + project.app;
    metric[key] = oldValues[metric._metricName_+"["+key+"]"];
    if (metric[key] == null) metric[key] = true;
    for (var j=0, jN=project.subservices.length; j<jN; j++) {
        var subservice = project.subservices[j];
        key = subservice.svc + "|" + subservice.subSvc + "|" + subservice.comp;
        metric[key] = oldValues[metric._metricName_+"["+key+"]"];
        if (metric[key] == null) metric[key] = false;
    }
    metrics.push(metric);
}
//print("getMetricModel: metrics="+__prettyPrintJSON(metrics));

this._stripIndexAttribute(metrics);
//print("getMetricModel: metrics="+__prettyPrintJSON(metrics));

return metrics;
]]>
        </CodeText>
      </Service>
      <Service name="getNameDefaults" args="project" private="false">
        <CodeText>
          <![CDATA[var defaultValues = this._getDefaultValues();
var namePrefix = (project.svc + "_" + project.comp + "_" + project.app).replace(/\s|-/g, "_");
if (namePrefix.indexOf("*") != -1) {
    namePrefix = namePrefix.replace(/\*/g, defaultValues["*-substitution"]);
}
var sourceGroup = "so_" + namePrefix.toLowerCase() + "_source";
var targetGroup = "so_" + namePrefix.toLowerCase() + "_table";
return {
    namePrefix  : namePrefix,
    sourceGroup : sourceGroup,
    targetGroup : targetGroup
};
]]>
        </CodeText>
      </Service>
      <Service name="getOutputModel" args="project,pivot,enrich,oldModel" private="false">
        <CodeText>
          <![CDATA[var oldOutput = {};
var buildInOutput = {};
var userDefineds = [];
if (oldModel != null) {
    for (var i=0; i<oldModel.length; i++) {
        var record = oldModel[i];
        if (record["__user_defined__"] == true) {
            userDefineds.push(record);
        }
        else if (record["__reserved__"] != true) {
            oldOutput[record["__reserved_name__"]] = {
                "__reserved_name__": record["__reserved_name__"],
                "name"  : record["name"],
                "label" : record["label"],
                "type"  : record["type"],
                "expr"  : record["expr"],
            };
            if (record["isDimension"] != null) {
                oldOutput[record["__reserved_name__"]].isDimension = record["isDimension"];
            }
        }
    }
} 


//apply aggerate window settings
var aggregate = project.aggregateWindow;
var windowSize = aggregate.windowSize;
var windowUnit = aggregate.windowUnit;
var msWindow = null;
var sWindow = null;
var expr = null; 
if (windowUnit == "N") {
    msWindow = windowSize + "*60000";
    sWindow = windowSize + "*60";
} else {
    msWindow = windowSize + "*1000";
    sWindow = windowSize;
}

var model = this._getBaseOutputModel();
model.forEach(function (item) {
    buildInOutput[item.name] = true;
    
    if (aggregate && aggregate.aggregate) {
        if (item.name == "aggr_start_tm") {
            if (windowSize > 0) {
                if (windowUnit == "N") {
                    expr = "(unix_timestamp_millisec(ts)/(" + msWindow + "))*" + sWindow;
                } else {
                    expr = "(unix_timestamp_millisec(ts)/(" + msWindow + "))*" + sWindow;
                }
                item.expr = expr;
            }
        }
        
        if (item.name == "aggr_end_tm") {
            if (windowSize > 0) {
                if (windowUnit == "N") {
                    expr = "(unix_timestamp_millisec(ts)/(" + msWindow + "))*" + sWindow + "+" + sWindow;
                } else {
                    expr = "(unix_timestamp_millisec(ts)/(" + msWindow + "))*" + sWindow + "+" + sWindow;
                }
                item.expr = expr;
            }
        }
    }
});

if (pivot && pivot.dimensions) {
    for (var i=0, n=pivot.dimensions.length; i<n; i++) {
        var nameChangedDimension = null;
        for (var name in oldOutput) {
            var oldConfig = oldOutput[name];
            if ( oldConfig["__reserved_name__"] == pivot.dimensions[i]["name"]) {
                nameChangedDimension = {
                    name  : oldConfig["name"],
                    label : oldConfig["label"],
                    type  : oldConfig["type"],
                    expr  : oldConfig["expr"],
                    __reserved_name__: oldConfig["__reserved_name__"],
                    __buildin_dimension__: true
                };
                if (oldConfig["isDimension"] == null) {
                    nameChangedDimension.isDimension = true;
                } else {
                    nameChangedDimension.isDimension = oldConfig["isDimension"];
                }
                break;
            }
        }
        if (nameChangedDimension != null) {
            model.push(nameChangedDimension);
        } else {
            model.push({
                name  : pivot.dimensions[i]["name"],
                label : pivot.dimensions[i]["label"] || pivot.dimensions[i]["name"],
                type  : pivot.dimensions[i]["data_type"],
                expr  : pivot.dimensions[i]["name"],
                __reserved_name__: pivot.dimensions[i]["name"],
                __buildin_dimension__: true,
                isDimension: true
            });
        }
    }
}

if (this._hasEnrichment(enrich)) {
    var rightFieldMap = {};
    enrich.rightFields.forEach(function(item){
        rightFieldMap[item.name] = item;
    });
    for (var i=0; i<enrich.joinClause.length; i++) {
        var clause = enrich.joinClause[i];
        if (clause.include == true && (clause.leftField == null || clause.leftField == "")) {
            var field = rightFieldMap[clause.rightColumn];
            if (field != null) {
                var enrichItem = null;
                for (var name in oldOutput) {
                    var oldConfig = oldOutput[name];
                    if (oldConfig["__reserved_name__"] == clause.rightField) {
                        enrichItem = {
                            name  : oldConfig["name"],
                            label : oldConfig["label"],
                            type  : oldConfig["type"],
                            expr  : oldConfig["expr"],
                            __reserved_name__: oldConfig["__reserved_name__"],
                            __buildin_enrich__: true,
                            isDimension : false
                        };
                        if (oldConfig["isDimension"] != null) {
                            enrichItem.isDimension = oldConfig["isDimension"];
                        }
                        break;
                    }
                }
                if (enrichItem != null) {
                    model.push(enrichItem);
                } else {
                    model.push({
                        name  : clause.rightField,
                        label : clause.rightField,
                        type  : field.type,
                        expr  : clause.rightField,
                        __reverved_name__: clause.rightField,
                        __buildin_enrich__: true,
                        isDimension: false
                    });
                }
            }
        }
    }
}


var names = {};
for (var i=0, n=model.length; i<n; i++) {
    var record = model[i];
    if (record["name"] == "source_fmt") {
        if (project.sample) {
            switch (project.sample.type) {
                case "text/csv":
                case "application/vnd.ms-excel":
                    record["expr"] = '"csv"';
                    break;
                case "application/json":
                    record["expr"] = '"json"';
                    break;
                default:
                    record["expr"] = '"csv"';
                    break;
            }
        }
    }
    names[record["name"]] = true;
}
for (var i=0, n=userDefineds.length; i<n; i++) {
    var userDefined = userDefineds[i];
    // possible new dimension may conflict of previous user defined
    // drop user defined
    if (names[userDefined.name] == null) {
        model.push(userDefined);
    }
}
this._stripIndexAttribute(model);
//print(__prettyPrintJSON(model));
return model;

]]>
        </CodeText>
      </Service>
      <Service name="getParserModelName" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    
    
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deploymnet ' + deploymentName + ' does not exist.';
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['parser_model_name'].value || deploymentGlobalMap['parser_model_name'].defaultValue;
]]>
        </CodeText>
      </Service>
      <Service name="getParserModelSpace" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['parser_model_space'].value || deploymentGlobalMap['parser_model_space'].defaultValue;]]>
        </CodeText>
      </Service>
      <Service name="getParserModelURL" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var name = this.getParserModelName(project, deployment);
var space = this.getParserModelSpace(project, deployment);
var url = "/app/spark/space/" + space + "/sparkm/" + name;
if (!this._mrHasModel(url)) {
    url = "/app/spark/user/" + Context.getCurrentUserId() + "/sparkm/" + name;
}
return url;
]]>
        </CodeText>
      </Service>
      <Service name="getParserRuntimeStatus" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var parserStatus = "NOT_FOUND";
var uri = this.getParserModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    parserStatus = Context.GET("/rest"+uri+"?op=getrunningstatus" + ((instance != null) ? ("&instance=" + instance) : ""));
    //print("getParserRuntimeStatus: " + uri + "=" + parserStatus);
    parserStatus = this._getMappedStatus(parserStatus);
}
//print("getParserRuntimeStatus: " + uri + "=" + parserStatus);
return parserStatus;
]]>
        </CodeText>
      </Service>
      <Service name="getPivotModel" args="project,schema,oldModel" private="false">
        <CodeText>
          <![CDATA[var oldPivot = {};
if (oldModel != null && oldModel.pivot) {
    if (oldModel.metric != null) {
        for (var i=0; i<oldModel.pivot.length; i++) {
            var record = oldModel.pivot[i];
            if (record["__source_metric_name__"]) {
                oldPivot[record["__source_metric_name__"]] = JSON.parse(JSON.stringify(record));
            } else {
                oldPivot[record["__metric_column__"]] = {
                    "__metric_name__"            : record["__metric_name__"],
                    "__metric_label__"           : record["__metric_label__"],
                    "__metric_value__"           : record["__metric_value__"],
                    "__metric_uom__"             : record["__metric_uom__"],
                    "__metric_aggr__"            : record["__metric_aggr__"],
                    "__ingestion_metric_aggr__"  : record["__ingestion_metric_aggr__"],
                    "__include__"                : record["__include__"],
                };
            }
        }
    }
    else if (!oldModel.measures || oldModel.measures.length == 0) {
        if (oldModel.pivot.length == 1) {
            var record = oldModel.pivot[0];
            oldPivot["EVENT"] = {
                "__metric_name__"           : record["__metric_name__"],
                "__metric_label__"          : record["__metric_label__"],
                "__metric_uom__"            : record["__metric_uom__"],
                "__metric_aggr__"           : record["__metric_aggr__"],
                "__ingestion_metric_aggr__" : record["__ingestion_metric_aggr__"],
                "__include__"               : record["__include__"],
            };
        }
    }
    else {
        for (var i=0; i<oldModel.pivot.length; i++) {
            var record = oldModel.pivot[i];
            oldPivot[record["__metric_name__"]] = {
                 "__metric_name__"           : record["__metric_name__"],
                "__metric_label__"           : record["__metric_label__"],
                "__metric_uom__"             : record["__metric_uom__"],
                "__metric_aggr__"            : record["__metric_aggr__"],
                "__ingestion_metric_aggr__"  : record["__ingestion_metric_aggr__"],
                "__include__"                : record["__include__"],
            };
        }
    }
}

function getOldConfig(metricName, attrName, defaultValue)
{
    var oldConfig = oldPivot[metricName];
    if (oldConfig != null && oldConfig[attrName] != null) return oldConfig[attrName];
    return defaultValue;
}

var timestamp  = null;
var dimensions = [];
var measures   = [];
var metric     = null;

var measureTypeIndex = 0;
var MEASURE_TYPES    = ["boolean", "integer", "long", "float", "double"];

var timestamp_count = 0;
var dimension_count = 0;
var measure_count   = 0;
schema = schema || [];
schema.forEach(function(field) {
    if (field.ignore != true) {
        switch (field.attr_type) {
            case "timestamp":
                timestamp_count++;
                break;
            case "dimension":
                dimension_count++;
                break;
            case "measure":
                measure_count++;
                break;
        }
    }
});
var use_attr_type = timestamp_count > 0;

schema.forEach(function(field) {
    if (field.ignore != true) {
        if (use_attr_type) {
            switch (field.attr_type) {
                case "timestamp":
                    timestamp = field;
                    break;
                case "metric":
                    metric = field;
                    break;
                case "dimension":
                    dimensions.push(field);
                    break;
                case "measure":
                    measures.push(field);
                    var typeIndex = MEASURE_TYPES.indexOf(field.data_type);
                    if (measureTypeIndex < typeIndex) {
                        measureTypeIndex = typeIndex;
                    }
                    break;
            }
        }
        else {
            switch (field.data_type) {
                case "datetime":
                    timestamp = field;
                    break;
                case "string":
                    dimensions.push(field);
                    break;
                case "boolean":
                case "integer":
                case "long":
                case "float":
                case "double":
                    measures.push(field);
                    var typeIndex = MEASURE_TYPES.indexOf(field.data_type);
                    if (measureTypeIndex < typeIndex) {
                        measureTypeIndex = typeIndex;
                    }
                    break;
            }
        }
    }
});

if (measures.length != 1) {
    metric = null;
}

var pivot = [];
if (timestamp != null) {
    if (metric != null && measures.length == 1) {
        for (var i=0; i<schema.length; i++) {
            var field = schema[i];
            if (field.name == metric.name) {
                metric.enums = [];
                if (field.meta_data != null && field.meta_data.enums != null) {
                    var regex = /[^a-z0-9+]+/gi;
                    for (var j=0, jN=field.meta_data.enums.length; j<jN; j++) {
                        var metricName = field.meta_data.enums[j];
                        metric.enums.push({
                            actualValue : metricName,
                            metricName  : metricName.replace(regex, "_"),
                        });
                    }
                }
                break;
            }
        }
        
        function comparePivot() {
            if (project.__migration__ == true) return false;
            if (!oldModel) return false;
            
            if (!oldModel.timestamp) return false;
            if (oldModel.timestamp.name != timestamp.name) return false;
            if (oldModel.timestamp.data_type != timestamp.data_type) return false;
            
            if (!oldModel.metric) return false;
            if (oldModel.metric.name != metric.name) return false;
            
            if (!oldModel.measures || oldModel.measures.length != measures.length) return false;
            if (oldModel.measures[0].name != measures[0].name) return false;
            
            
            if (!oldModel.dimensions || oldModel.dimensions.length != dimensions.length) return false;
            var dimensionMap = {};
            oldModel.dimensions.forEach(function (item) {
                dimensionMap[item.name] = item; 
            });
            
            for (var i = 0, iN = dimensions.length; i < iN; i++) {
                var item = dimensions[i];
                if (!dimensionMap[item.name]) return false;
            }
            
            return true;
        }
        
        function compareEnums() {
            var newEnums = metric.enums.map(function (item) {
                return item.actualValue;
            }).sort();
            
            var oldEnums = oldModel.metric.enums.map(function (item) {
                return item.actualValue; 
            }).sort();
            
            if (newEnums.length != oldEnums.length) return false;
            if (JSON.stringify(newEnums) != JSON.stringify(oldEnums)) return false;
            
            return true;
        }
        
        if (comparePivot() && compareEnums()) {
            pivot = oldModel.pivot;
        } else {
            var newPivot = {};
            metric.enums.forEach(function (item) {
                var record = {};
                for (var i=0, n=dimensions.length; i<n; i++) {
                    record[dimensions[i]["name"]] = dimensions[i]["name"];
                    record[dimensions[i]["label"]] = dimensions[i]["label"];
                }
                record["__timestamp_name__"] = timestamp.name;
                record["__timestamp_label__"] = timestamp.label;
                record["__timestamp_type__"] = timestamp.data_type;
                record["__metric_column__"] = metric.name;
                record["__metric_name__"] = metric.name;
                record["__metric_type__"] = MEASURE_TYPES[measureTypeIndex];
                record["__metric_value__"] = measures[0].name;
                record["__metric_uom__"] = getOldConfig(item.actualValue, "__metric_uom__", "Count");
                record["__metric_aggr__"] = getOldConfig(item.actualValue, "__metric_aggr__", "sum");
                record["__ingestion_metric_aggr__"] = getOldConfig(item.actualValue, "__ingestion_metric_aggr__", "sum");
                record["__include__"] = getOldConfig(item.actualValue, "__include__", true);
                record["__source_metric_name__"] = item.actualValue;
                record["__target_metric_name__"] = getOldConfig(item.actualValue, "__target_metric_name__", item.metricName);
                record["__metric_label__"] = getOldConfig(item.actualValue, "__metric_label__", "");
                pivot.push(record);
                newPivot[item.actualValue] = record;
            });
            
            if (comparePivot()) {
                for (var pro in oldPivot) {
                    var oldItem = oldPivot[pro];
                    if (!newPivot[oldItem["__source_metric_name__"]]) {
                        var record = {};
                        for (var i=0, n=dimensions.length; i<n; i++) {
                            record[dimensions[i]["name"]] = dimensions[i]["name"];
                            record[dimensions[i]["label"]] = dimensions[i]["label"];
                        }
                        record["__timestamp_name__"] = timestamp.name;
                        record["__timestamp_label__"] = timestamp.label;
                        record["__timestamp_type__"] = timestamp.data_type;
                        record["__metric_column__"] = metric.name;
                        record["__metric_name__"] = metric.name;
                        record["__metric_type__"] = MEASURE_TYPES[measureTypeIndex];
                        record["__metric_value__"] = measures[0].name;
                        record["__metric_uom__"] = oldItem["__metric_uom__"];
                        record["__metric_aggr__"] = oldItem["__metric_aggr__"];
                        record["__ingestion_metric_aggr__"] = oldItem["__ingestion_metric_aggr__"];
                        record["__include__"] = oldItem["__include__"];
                        record["__source_metric_name__"] = oldItem["__source_metric_name__"];
                        record["__target_metric_name__"] = oldItem["__source_metric_name__"];
                        record["__metric_label__"] = oldItem["__metric_label__"];
                        pivot.push(record);
                    }
                }
            }
        }
    }
    else if (measures.length == 0) {
        // count-based event... each input record is a count of 1
        var record = {};
        for (var i=0, n=dimensions.length; i<n; i++) {
            record[dimensions[i]["name"]] = dimensions[i]["name"];
            record[dimensions[i]["label"]] = dimensions[i]["label"];
        }
        record["__timestamp_name__"] = timestamp.name;
        record["__timestamp_label__"] = timestamp.label;
        record["__timestamp_type__"] = timestamp.data_type;
        record["__metric_name__"] = getOldConfig("EVENT", "__metric_name__", "EVENT");
        record["__metric_label__"] = getOldConfig("EVENT", "__metric_label__", "");
        record["__metric_type__"] = "long";
        record["__metric_uom__"] = getOldConfig("EVENT", "__metric_uom__", "Count");
        record["__metric_aggr__"] = getOldConfig("EVENT", "__metric_aggr__", "sum");
        record["__ingestion_metric_aggr__"] = getOldConfig("EVENT", "__ingestion_metric_aggr__", "sum");
        record["__include__"] = getOldConfig("EVENT", "__include__", true);
        pivot.push(record);
    }
    else {
        function compareMeasurePivot() {
            if (project.__migration__ == true) return false;
            if (!oldModel) return false;
            
            if (!oldModel.timestamp) return false;
            if (oldModel.timestamp.name != timestamp.name) return false;
            if (oldModel.timestamp.data_type != timestamp.data_type) return false;
            
            if (!oldModel.measures || oldModel.measures.length != measures.length) return false;
            for (var i = 0, n = measures.length; i < n; i++) {
                if (oldModel.measures[i].name != measures[i].name) return false;
                if (oldModel.measures[i].data_type != measures[i].data_type) return false;
            }
            
            
            if (!oldModel.dimensions || oldModel.dimensions.length != dimensions.length) return false;
            var dimensionMap = {};
            oldModel.dimensions.forEach(function (item) {
                dimensionMap[item.name] = item; 
            });
            
            for (var i = 0, iN = dimensions.length; i < iN; i++) {
                var item = dimensions[i];
                if (!dimensionMap[item.name]) return false;
            }
            
            return true;
        }
        
        if (compareMeasurePivot()) {
             pivot = oldModel.pivot;
        } else {
            measures.forEach(function(measure) {
                var record = {};
                for (var i=0, n=dimensions.length; i<n; i++) {
                    record[dimensions[i]["name"]] = dimensions[i]["name"];
                    record[dimensions[i]["label"]] = dimensions[i]["label"];
                }
                record["__timestamp_name__"] = timestamp.name;
                record["__timestamp_label__"] = timestamp.label;
                record["__timestamp_type__"] = timestamp.data_type;
                record["__data_type__"] = measure.data_type;
                record["__metric_value__"] = measure.name;
                record["__metric_type__"] = MEASURE_TYPES[measureTypeIndex];
                record["__metric_name__"] = getOldConfig(measure.name, "__metric_name__", measure.label);
                record["__metric_label__"] = getOldConfig(measure.name, "__metric_label__", "");
                record["__metric_uom__"] = getOldConfig(measure.name, "__metric_uom__", "Count");
                record["__metric_aggr__"] = getOldConfig(measure.name, "__metric_aggr__", "sum");
                record["__ingestion_metric_aggr__"] = getOldConfig(measure.name, "__ingestion_metric_aggr__", "sum");
                record["__include__"] = getOldConfig(measure.name, "__include__", true);
                pivot.push(record);
            });
        }
    }
}
var model = {
    timestamp  : timestamp,
    dimensions : dimensions,
    measures   : measures,
    pivot      : pivot,
};
if (metric != null) {
    model.metric = metric;
}
if (model.timestamp != null) {
    delete model.timestamp["__index__"];
}
if (model.metric != null) {
    delete model.metric["__index__"];
}
this._stripIndexAttribute(model.dimensions);
this._stripIndexAttribute(model.measures);
this._stripIndexAttribute(model.pivot);

if (model.timestamp != null) {
    switch (model.timestamp.data_type) {
        case "datetime":
            break;
        case "long":
        case "double":
            if (model.timestamp.meta_data != null && model.timestamp.meta_data.max != null) {
                if (model.timestamp.meta_data.max < 10000000000) {
                    // seconds
                    model.unitOfTime = "second";
                }
                else if (model.timestamp.meta_data.max < 10000000000000) {
                    // milliseconds
                    model.unitOfTime = "millisecond";
                }
                else if (model.timestamp.meta_data.max < 10000000000000000) {
                    // microseconds
                    model.unitOfTime = "microsecond";
                }
                else {
                    // nanoseconds
                    model.unitOfTime = "nanosecond";
                }
            }
            else {
                model.unitOfTime = "second";
            }
            break;
    }
}

return model;
]]>
        </CodeText>
      </Service>
      <Service name="getPreContent" args="project" private="false">
        <CodeText>
          <![CDATA[return this._loadProjectFile(project, 'sample.txt', false);

/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/sample.txt");
var text = Context.getFileAsString(path);
return text;
**/
]]>
        </CodeText>
      </Service>
      <Service name="getPreProcessModelName" args="project" private="false">
        <CodeText>
          <![CDATA[var nameDefaults = this.getNameDefaults(project);
var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
return namePrefix.toUpperCase() + "_PREPROCESS";
]]>
        </CodeText>
      </Service>
      <Service name="getPreProcessModelURL" args="project" private="false">
        <CodeText>
          <![CDATA[var name = this.getPreProcessModelName(project);
var url = "/app/spark/space/" + project.space + "/sparkm/" + name;
if (!this._mrHasModel(url)) {
    url = "/app/spark/user/" + Context.getCurrentUserId() + "/sparkm/" + name;
}
return url;
]]>
        </CodeText>
      </Service>
      <Service name="getPreProcessRuntimeStatus" args="project" private="false">
        <CodeText>
          <![CDATA[var preprocessStatus = "NOT_FOUND";
var uri = this.getPreProcessModelURL(project);
if (this._mrHasModel(uri)) {
    preprocessStatus = Context.GET("/rest"+uri+"?op=getrunningstatus");
    //print("getPreProcessRuntimeStatus: " + uri + "=" + preprocessStatus);
    preprocessStatus = this._getMappedStatus(preprocessStatus);
}
//print("getPreProcessRuntimeStatus: " + uri + "=" + preprocessStatus);
return preprocessStatus;
]]>
        </CodeText>
      </Service>
      <Service name="getPreResult" args="project" private="false">
        <CodeText>
          <![CDATA[//print("getPreResult: project="+__prettyPrintJSON(project));
var result = this._loadProjectFile(project, "preprocess.json", true);
return result;
]]>
        </CodeText>
      </Service>
      <Service name="getPreScript" args="project" private="false">
        <CodeText>
          <![CDATA[return this._loadProjectFile(project, 'preprocess.js', false) || "";

/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/preprocess.js");
var text = Context.getFileAsString(path);
return text || "";
*/
]]>
        </CodeText>
      </Service>
      <Service name="getProject" args="project" private="false">
        <CodeText>
          <![CDATA[//so cli rest
var projectData = this.loadProjectByName(project);
if(projectData == null) return project + ' does not exsit.'
return {
    deployments : this.loadProjectDeploymentList(projectData)
                      .map(function(deployment){ return deployment.name; })
};]]>
        </CodeText>
      </Service>
      <Service name="getQDCModel" args="project,output,oldModel" private="false">
        <CodeText>
          <![CDATA[if (oldModel == null) oldModel = {};

var dimensions = {};
for (var i=0; i<output.length; i++) {
    dimensions[output[i]["name"]] = true;
}

var newQDC = {
};
newQDC["svc:" + project.svc] = {
    "operator": "and",
    "items": []
};
for (var scope in oldModel) {
    var scopeQDC = oldModel[scope].items || [];
    var qdc = [];
    for (var i=0; i<scopeQDC.length; i++) {
        var record = scopeQDC[i];
        if (record.type == "JSON") {
            qdc.push(record);
        } else {
            if (dimensions[record["name"]] == true) {
                qdc.push(record);
            }
        }
    }
    this._stripIndexAttribute(qdc);
    oldModel[scope].items = qdc;
    
    newQDC[scope] = oldModel[scope];
}


//this._stripIndexAttribute(qdc);
return newQDC;
]]>
        </CodeText>
      </Service>
      <Service name="getQuickLinks" args="" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
var queryQuickLink = queryConfig["quick-links"] || {};

var workbenchConfig = this.getWorkbenchConfig();
var workbenchQuickLink = workbenchConfig["quick-links"] || {};

for (var key in workbenchQuickLink) {
    if (queryQuickLink[key] == undefined) {
        queryQuickLink[key] = workbenchQuickLink[key];
    }
}
return queryQuickLink;
]]>
        </CodeText>
      </Service>
      <Service name="getResourceModelName" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

if (deploymentGlobalMap['resource_model_name']) {
    return deploymentGlobalMap['resource_model_name'].value || deploymentGlobalMap['resource_model_name'].defaultValue;
} else {
    var nameDefaults = this.getNameDefaults(project);
    var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
    return namePrefix.toUpperCase() + "_" + deployment.name + "_TABLE";
}
]]>
        </CodeText>
      </Service>
      <Service name="getResourceModelSpace" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['parser_model_space'].value || deploymentGlobalMap['parser_model_space'].defaultValue || project.space;

]]>
        </CodeText>
      </Service>
      <Service name="getResourceModelURL" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var name = this.getResourceModelName(project, deployment);
var space = this.getResourceModelSpace(project, deployment);
var url = "/app/drd/space/" + space + "/drm/" + name;
if (!this._mrHasModel(url)) {
    url = "/app/drd/user/" + Context.getCurrentUserId() + "/drm/" + name;
}
return url;
]]>
        </CodeText>
      </Service>
      <Service name="getRuntimeStatus" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (!deployment) return {};

var notFoundResult = {
    name                  : ((typeof deployment == "string") ? deployment : deployment.name),
    preprocessStatus      : "NOT_FOUND",
    parserStatus          : "NOT_FOUND",
    rtParserStatus        : "NOT_FOUND",
    serviceParserStatus   : "NOT_FOUND",
    rtAnomalyStatus       : "NOT_FOUND",
    anomalyStatus         : "NOT_FOUND",
    baselineScoreStatus   : "NOT_FOUND",
    simpleThresholdStatus : "NOT_FOUND",
    simpleDeviationStatus : "NOT_FOUND",
    declaredEventStatus   : "NOT_FOUND",
    hasIncidentConfig     : false
};

if (!project) {
    return notFoundResult;
}

if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

if (!deployment) {
    return notFoundResult;
}

function getServiceStatus(service)
{
    if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
        var uri = service["adf-model"];
        if (!this._mrHasModel(uri)) {
            return "NOT_FOUND";
        }
        if (this._isRunning(uri)) {
            return "STARTED";
        }
        return "NOT_ACTIVE";
    }
    return "NOT_FOUND";
}

var preprocessStatus = project != null ? this.getPreProcessRuntimeStatus(project) : "NOT_FOUND";
var parserStatus     = project != null ? this.getParserRuntimeStatus(project, deployment)     : "NOT_FOUND";
var rtParserStatus     = project != null ? this.getParserRuntimeStatus(project, deployment, "RT")     : "NOT_FOUND";
var serviceParserStatus = project != null ? this.getParserRuntimeStatus(project, deployment, "Service")     : "NOT_FOUND";
var rtAnomalyStatus    = project != null ? this.getAnomalyRuntimeStatus(project, deployment, "RT")    : "NOT_FOUND";
var anomalyStatus    = project != null ? this.getAnomalyRuntimeStatus(project, deployment)    : "NOT_FOUND";

var workbenchConfig = this.getWorkbenchConfig();

var baselineScoreStatus = getServiceStatus(workbenchConfig["incident-baseline-score"]);
baselineScoreStatus = this._getMappedStatus(baselineScoreStatus);
//print("getRuntimeStatus: baselineScoreStatus=" + baselineScoreStatus);

var simpleThresholdStatus = getServiceStatus(workbenchConfig["incident-simple-threshold"]);
simpleThresholdStatus = this._getMappedStatus(simpleThresholdStatus);
//print("getRuntimeStatus: simpleThresholdStatus=" + simpleThresholdStatus);

var simpleDeviationStatus = getServiceStatus(workbenchConfig["incident-simple-deviation"]);
simpleDeviationStatus = this._getMappedStatus(simpleDeviationStatus);
//print("getRuntimeStatus: simpleDeviationStatus=" + simpleDeviationStatus);

var declaredEventStatus = getServiceStatus(workbenchConfig["incident-declared-event"]);
declaredEventStatus = this._getMappedStatus(declaredEventStatus);
//print("getRuntimeStatus: declaredEventStatus=" + declaredEventStatus);

return {
    deployment            : deployment.name,
    preprocessStatus      : preprocessStatus,
    parserStatus          : parserStatus,
    rtParserStatus        : rtParserStatus,
    serviceParserStatus   : serviceParserStatus,
    rtAnomalyStatus       : rtAnomalyStatus,
    anomalyStatus         : anomalyStatus,
    baselineScoreStatus   : baselineScoreStatus,
    simpleThresholdStatus : simpleThresholdStatus,
    simpleDeviationStatus : simpleDeviationStatus,
    declaredEventStatus   : declaredEventStatus,
    hasIncidentConfig     : project != null ? this.hasIncidentConfig(project) : false,
};
]]>
        </CodeText>
      </Service>
      <Service name="getRuntimeStatuses" args="" private="false">
        <CodeText>
          <![CDATA[var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var statuses = [];
var projects = this.listProjectData();
for (var i=0; i<projects.length; i++) {
    statuses.push({
        project           : projects[i],
        preprocessStatus  : this.getPreProcessRuntimeStatus(projects[i]),
        parserStatus      : this.getParserRuntimeStatus(projects[i]),
        anomalyStatus     : this.getAnomalyRuntimeStatus(projects[i]),
        hasIncidentConfig : this.hasIncidentConfig(projects[i]),
    })
}
//print("getRuntimeStatuses: "+__prettyPrintJSON(statuses));
return statuses;
]]>
        </CodeText>
      </Service>
      <Service name="getSchemaModel" args="schema,result" private="false">
        <CodeText>
          <![CDATA[var System = java.lang.System;
var JavaString = java.lang.String;
var JavaDate = java.util.Date;
var SimpleDateFormat = java.text.SimpleDateFormat;

//print("getSchemaModel: schema="+__prettyPrintJSON(schema));

function makeFieldName(name)
{
    var toks = name.split(/[ \/]+/);
    return toks.join("_");
}

function makeFieldLabel(name)
{
    var toks = name.split(/ +/);
    for (var i=0; i<toks.length; i++) {
        toks[i] = (toks[i]).charAt(0).toUpperCase() + (toks[i]).substring(1);
    }
    return toks.join(" ");
}

for (var j=0, jN=schema.length; j<jN; j++) {
    var field = schema[j];
    field.label = makeFieldLabel(field.name);
    var name = makeFieldName(field.name);
    if (name != field.name) {
        for (var i=0, iN=result.length; i<iN; i++) {
            var record = result[i];
            var value = record[field.name];
            if (value != null) {
                delete record[field.name];
                record[name] = value;
            }
        }
        field.name = name;
    }
    
    switch (field.data_type) {
        case "datetime":
            var min = null;
            var max = null;
            if (field.format != null) {
                var formatter = new SimpleDateFormat(field.format);
                var minEpoch = null;
                var maxEpoch = null;
                for (var i=0, iN=result.length; i<iN; i++) {
                    var dt = null;
                    try {
                        dt = formatter.parse(result[i][field.name]);
                    } catch (ex) {
                        try {
                            dt = new Date(result[i][field.name]);
                        } catch (ex) {
                            
                        }
                    }
                    
                    if (dt != null) {
                        var epoch = dt.getTime();
                        if (minEpoch == null || minEpoch > epoch) {
                            minEpoch = epoch;
                            min = result[i][field.name];
                        }
                        if (maxEpoch == null || maxEpoch < epoch) {
                            maxEpoch = epoch;
                            max = result[i][field.name];
                        }
                    }
                }
            }
            field.meta_data = {
                format   : field.format,
                interval : field.interval,
                min      : min,
                max      : max,
            };
            break;
        case "long":
        case "double":
            var min = null;
            var max = null;
            var enums = [];
            var distinct = {};
            for (var i=0, iN=result.length; i<iN; i++) {
                var value = Number(result[i][field.name]);
                if (!isNaN(value)) {
                    if (min == null || min > value) min = value;
                    if (max == null || max < value) max = value;
                    
                    if (distinct[value] == null) {
                        distinct[value] = value;
                        enums.push(value);
                    }
                }
            }
            field.meta_data = {
                enums : enums,
                min : min,
                max : max,
            };
            break;
        case "boolean":
            var enums = ["true","false"];
            field.meta_data = {
                enums : enums,
            };
            break;
        case "string":
            var distinct = {};
            var enums = [];
            for (var i=0, iN=result.length; i<iN; i++) {
                var value = result[i][field.name];
                if (value != null && typeof value == "string" && value.trim() != "" && distinct[value] == null) {
                    distinct[value] = value;
                    enums.push(value);
                }
            }
            enums.sort();
            field.meta_data = {
                enums : enums,
            };
            break;
    }
}
//print("schema="+__prettyPrintJSON(schema));
return schema;

]]>
        </CodeText>
      </Service>
      <Service name="getSimpleDeviationModelURL" args="project" private="false">
        <CodeText>
          <![CDATA[//print("getSimpleDeviationModelURL: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-simple-deviation"];
if (service != null && service["adf-model"] != null && this._mrHasModel(service["adf-model"])) {
    return service["adf-model"];
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="getSimpleThresholdModelURL" args="project" private="false">
        <CodeText>
          <![CDATA[//print("getSimpleThresholdModelURL: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-simple-threshold"];
if (service != null && service["adf-model"] != null && this._mrHasModel(service["adf-model"])) {
    return service["adf-model"];
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="getSystemModelName" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

if (deploymentGlobalMap['system_model_name']) {
    return deploymentGlobalMap['system_model_name'].value || deploymentGlobalMap['system_model_name'].defaultValue;
} else {
    var nameDefaults = this.getNameDefaults(project);
    var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
    return namePrefix.toUpperCase() + "_" + deployment.name + "_MODEL";
}
]]>
        </CodeText>
      </Service>
      <Service name="getSystemModelSpace" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});

return deploymentGlobalMap['parser_model_space'].value || deploymentGlobalMap['parser_model_space'].defaultValue || project.space;]]>
        </CodeText>
      </Service>
      <Service name="getSystemModelURL" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var name = this.getSystemModelName(project, deployment);
var space = this.getSystemModelSpace(project, deployment);
var url = "/app/dbp/space/" + space + "/dbpm/" + name;
if (!this._mrHasModel(url)) {
    url = "/app/dbp/user/" + Context.getCurrentUserId() + "/dbpm/" + name;
}
return url;
]]>
        </CodeText>
      </Service>
      <Service name="getTestModel" args="project,schema,pivot" private="false">
        <CodeText>
          <![CDATA[var model = {
    name : "Test1",
    fields : {
    }
};
schema.forEach(function(field) {
    if (field.ignore != true) {
        var item = {
            type  : field.data_type,
            value : {
            }
        };
        model.fields[field.name] = item;
        switch (field.data_type) {
            case "datetime":
                item.format = field.format;
                if (field.meta_data != null) {
                    item.value.min = field.meta_data.min;
                    item.value.max = field.meta_data.max;
                }
                break;
            case "long":
            case "double":
                if (field.meta_data != null) {
                    item.value.min = field.meta_data.min;
                    item.value.max = field.meta_data.max;
                }
                break;
            case "string":
                if (field.meta_data != null) {
                    item.value.enums = field.meta_data.enums;
                }
                break;
        }
    }
});
if (pivot.timestamp != null) {
    model.iterator = {
        field : pivot.timestamp.name,
        count : 10,
        step  : 300,
    };
    if (pivot.timestamp.meta_data != null) {
        model.iterator.min = pivot.timestamp.meta_data.min;
        model.iterator.max = pivot.timestamp.meta_data.max;
    }
    switch (pivot.timestamp.data_type) {
        case "datetime":
            model.iterator.step = 300;
            break;
        case "long":
        case "double":
            model.iterator.unitOfTime = pivot.unitOfTime;
            switch (model.iterator.unitOfTime) {
                case "second":
                    model.iterator.step = 300;
                    break;
                case "millisecond":
                    model.iterator.step = 300000;
                    break;
                case "microsecond":
                    model.iterator.step = 300000000;
                    break;
                case "nanosecond":
                    model.iterator.step = 300000000000;
                    break;
            }
            break;
    }
}
if (pivot.measures != null) {
    pivot.measures.forEach(function(measure) {
        model.fields[measure.name]["spike"] = {
            multiplier : 10,
            threshold : 0.97
        };
    });
}
return [model];
]]>
        </CodeText>
      </Service>
      <Service name="getTestSize" args="project" private="false">
        <CodeText>
          <![CDATA[var tests = this.loadProjectTestModel(project);
//print("getTestSize: tests="+__prettyPrintJSON(tests));
if (tests.length > 0) {
    var model = tests[0];
    if (model.fields != null && model.iterator != null) {
        var iterateField = model.fields[model.iterator.field];
        var iterateCount = model.iterator.count;
        var iterateStep  = model.iterator.step;
        var iterateStart = model.iterator.min || iterateField.value.min;
        var iterateEnd   = model.iterator.max || iterateField.value.max;
        switch (iterateField.type) {
            case "datetime":
                var startTime = (new Date(iterateStart)).getTime()/1000;
                var endTime   = (new Date(iterateEnd)).getTime()/1000;
                startTime = Math.floor(startTime/iterateStep)*iterateStep;
                endTime = Math.ceil(endTime/iterateStep)*iterateStep;
                return ((endTime-startTime)/iterateStep)*iterateCount;
            case "long":
                var startTime = Number(iterateStart);
                var endTime   = Number(iterateEnd);
                startTime = Math.floor(startTime/iterateStep)*iterateStep;
                endTime = Math.ceil(endTime/iterateStep)*iterateStep;
                return ((endTime-startTime)/iterateStep)*iterateCount;
            case "double":
                var startTime = Number(iterateStart);
                var endTime   = Number(iterateEnd);
                return ((endTime-startTime)/iterateStep)*iterateCount;
        }
    }
}
return 0;
]]>
        </CodeText>
      </Service>
      <Service name="getTimezoneOffset" args="" private="false">
        <CodeText>
          <![CDATA[var ZoneId = java.time.ZoneId;
var LocalDateTime = java.time.LocalDateTime;
var String = java.lang.String;
var ArrayList = java.util.ArrayList;
var Collections = java.util.Collections;

var PREFERRED_ZONES = {
    "GMT":true,
    "America/New_York":true,
    "America/Chicago":true,
    "America/Denver":true,
    "America/Los_Angeles":true,
    "America/Puerto_Rico":false,
    "America/Anchorage":true,
    "Pacific/Honolulu":true,
};

var allZones = ZoneId.getAvailableZoneIds();
var dt = LocalDateTime.now();

// Create a List using the set of zones and sort it.
var zoneList = new ArrayList(allZones);

var offsets   = {};
var positives = [];
var negatives = [];
var gmt       = [];

function addTimezoneOffset(timezoneAndOffset)
{
    if (offsets[timezoneAndOffset.offset] == null) {
        offsets[timezoneAndOffset.offset] = timezoneAndOffset.zone;
        if (timezoneAndOffset.offset == "Z") {
            gmt.push({
                timezone : timezoneAndOffset.zone,
                offset   : "+00:00",
            });
        }
        else if (timezoneAndOffset.offset.charAt(0) == "+") {
            positives.push({
                timezone : timezoneAndOffset.zone,
                offset   : timezoneAndOffset.offset,
            });
        }
        else if (timezoneAndOffset.offset.charAt(0) == "-") {
            negatives.push({
                timezone : timezoneAndOffset.zone,
                offset   : timezoneAndOffset.offset,
            });
        }
    }
}

var timezonesAndOffsets = [];
for (var i=0, n=zoneList.size(); i<n; i++) {
    var zone = ZoneId.of(zoneList.get(i));
    var zdt = dt.atZone(zone);
    var offset = zdt.getOffset();
    zone = ""+zone;
    offset = ""+offset;
    if (zone.indexOf("Etc/") == 0) continue;
    timezonesAndOffsets.push({
        zone   : zone,
        offset : offset,
    });
}

// add preferred zones first
for (var i=0, n=timezonesAndOffsets.length; i<n; i++) {
    var timezoneAndOffset = timezonesAndOffsets[i];
    if (offsets[timezoneAndOffset.offset] == null && PREFERRED_ZONES[timezoneAndOffset.zone] == true) {
        addTimezoneOffset(timezoneAndOffset);
    }
}

// fill in remaining zones
for (var i=0, n=timezonesAndOffsets.length; i<n; i++) {
    var timezoneAndOffset = timezonesAndOffsets[i];
    if (offsets[timezoneAndOffset.offset] == null) {
        addTimezoneOffset(timezoneAndOffset);
    }
}

positives.sort(function(a,b) {
    return b.offset.localeCompare(a.offset);
});
negatives.sort(function(a,b) {
    return a.offset.localeCompare(b.offset);
});
return [].concat(positives, gmt, negatives);]]>
        </CodeText>
      </Service>
      <Service name="getWorkbenchConfig" args="" private="false">
        <CodeText>
          <![CDATA[var config = JSON.parse(Context.getLocalResource("WorkbenchConfig"));
return config;
]]>
        </CodeText>
      </Service>
      <Service name="hasIncidentConfig" args="project" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
var nameDefaults = this.getNameDefaults(project);

var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
var sourceGroup = (project.sourceGroup || nameDefaults.sourceGroup);
var targetGroup = (project.targetGroup || nameDefaults.targetGroup);

var DATASOURCE = queryConfig["data-source"]["incident-model"];
if (DATASOURCE == null) return false;

var sql = "select count(*) as count "
        + "from viaops_anomaly_sol "
        + "where adm_name=\""+(targetGroup+"-5/5")+"\"";
var ret = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Incident Config", "Select"], DATASOURCE, sql, null);
if (ret == null || ret == "") return false;
//print(sql + "=" + __prettyPrintJSON(ret));
if (ret.total != 1 || ret.items[0]["count"] == 0) return false;

var whereclause = ["  metric_id like \"" + (project.svc+"|"+project.comp+"|"+project.app+"|%") + "\"  "];
if (project.subservices && project.subservices.length > 0) {
    project.subservices.forEach(function(item) {
        whereclause.push("  metric_id like \"" + (item.svc+"|"+item.subSvc+"|"+item.comp+"|%") + "\"  ");
    });
}
var sql = "select count(*) as count "
        + "from viaops_incident_table "
        + "where " + whereclause.join(" or ");
var ret = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Incident Config", "Count"], DATASOURCE, sql, null);
if (ret == null || ret == "") return false;
//print(sql + "=" + __prettyPrintJSON(ret));
if (ret.total != 1 || ret.items[0]["count"] == 0) return false;

return true;
]]>
        </CodeText>
      </Service>
      <Service name="hasSampleData" args="project" private="false">
        <CodeText>
          <![CDATA[//print("hasSampleData: project="+__prettyPrintJSON(project));
this._hasProjectFile(project, 'sample.text');

/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/sample.txt");
var file = new File(path);
return file.exists() && file.isFile();
*/
]]>
        </CodeText>
      </Service>
      <Service name="importProject" args="fileName,overwrite" private="false">
        <CodeText>
          <![CDATA[// so cli rest

var project = this.importProjectData({ uid : fileName }).result;

var existProject = findProject(project.prjName);


if(existProject){
    if(overwrite === 'true' || overwrite == true) this.doImportProject(project.uuid, existProject.uuid); 
    else return existProject.prjName + ' already exists.';
}else{
    this.doImportProject(project.uuid, null);
}


function findProject(name){
    return this.listProjectData().filter(sameName)[0];
    
    function sameName(project){
        return project.prjName === name;
    }
}]]>
        </CodeText>
      </Service>
      <Service name="importProjectData" args="data" private="false">
        <CodeText>
          <![CDATA[var uuid = Context.generateRandomUUID();
var dirName = "nuova_stella/" + uuid;
while (this._fsHasDirectory(dirName)) {
    uuid = Context.generateRandomUUID();
    dirName = "nuova_stella/" + uuid;
}

var queryConfig = this.getQueryConfig();
var self = this;

if (!this._fsCreateDirectory(dirName)) {
    return {
        error : "CannotCreateProjectDirectoryException",
    };
}


print("importProject: uuid="+uuid);
print("importProject: data="+__prettyPrintJSON(data));

var System = java.lang.System;
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;
var FileInputStream = java.io.FileInputStream;
var FileOutputStream = java.io.FileOutputStream;
var BufferedOutputStream = java.io.BufferedOutputStream;
var ByteArray = Java.type("byte[]");
var ZipInputStream = java.util.zip.ZipInputStream;
var ZipEntry = java.util.zip.ZipEntry;

var dataBuffer = new ByteArray(1024);
var projectPath = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + uuid);

function putProjectContent(zi, filename)
{
    var path = projectPath + "/" + filename;
    var bos = new BufferedOutputStream(new FileOutputStream(path));
    var read = 0;
    while ((read = zi.read(dataBuffer)) != -1) {
        bos.write(dataBuffer, 0, read);
    }
    bos.close();
}

var tempDirectory = System.getProperty("java.io.tmpdir");
var uploadedPath = tempDirectory + "/" + data.uid;

var zi = new ZipInputStream(new FileInputStream(uploadedPath));
var ze = zi.getNextEntry();
// iterates over entries in the zip file
while (ze != null) {
    putProjectContent(zi, ze.getName());
    zi.closeEntry();
    ze = zi.getNextEntry();
}
zi.close();

var file = new File(uploadedPath);
file.delete();

// load imported project JSON
// replace uuid
// update and return
var project = this._fsLoadFromFile("nuova_stella/" + uuid + "/project");
if(project == null)
    throw 'Invalid project file.'
project.uuid = uuid;
if (project.prjName == null) {
    project.prjName = project.svc + "|" + project.comp + "|" + project.app;
}

return {
    uuid:  uuid,
    result: project
};]]>
        </CodeText>
      </Service>
      <Service name="listProjectData" args="" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    var EnvLib = com.vitria.fc.utils.EnvLib;
    var File = java.io.File;
    
    var projects = [];
    var uuids = this._fsListDirectories("nuova_stella");
    if (uuids != null) {
        for (var i=0; i<uuids.length; i++) {
            if (uuids[i] != "system_models") {
                var project = this._fsLoadFromFile("nuova_stella/"+uuids[i]+"/project");
                if (project != null) {
                    if (project.uuid == null) project.uuid = uuids[i];
                    this._initProject(project);
                    projects.push(project);
                }
            }
        }
    }
    return projects;
} else {
    var projects = [];
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_TABLE_SELECT_SQL");
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project", "Select"], DS, sql, null);
    var self = this;
    if (result != null && result.items != null) {
        result.items.forEach(function (item) {
            var project = self._loadProjectFile(item, 'project.json', true);
            project.uuid = item.uuid;
            self._initProject(project);
            projects.push(project);
        });
    }
    return projects;
}]]>
        </CodeText>
      </Service>
      <Service name="listProjects" args="" private="false">
        <CodeText>
          <![CDATA[//so cli rest
return this.listProjectData().map(function(p){ return p.prjName; }).filter(function(name){ return name; }).sort();
]]>
        </CodeText>
      </Service>
      <Service name="loadProject" args="project" private="false">
        <CodeText>
          <![CDATA[var sample = this.loadProjectSample(project);
var schema = this.loadProjectSchema(project);
var pivot  = this.loadProjectPivot(project);
var count  = this.loadProjectCount(project);
var enrich = this.loadProjectEnrich(project);
var output = this.loadProjectOutput(project);
var qdc    = this.loadProjectQDC(project);
var metric = this.loadProjectMetric(project);

return {
    schema : schema,
    sample : sample,
    pivot  : pivot,
    count  : count,
    enrich : enrich,
    output : output,
    qdc    : qdc,
    metric : metric,
};

]]>
        </CodeText>
      </Service>
      <Service name="loadProjectCount" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectCount: project="+__prettyPrintJSON(project));
var count = this._loadProjectFile(project, "count.json", true) || [];

// migration
this._stripIndexAttribute(count);

return count;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectEnrich" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectEnrich: project="+__prettyPrintJSON(project));
var enrich = this._loadProjectFile(project, "enrich.json", true);

// migration
if (enrich != null && enrich.joinClause != null) {
    this._stripIndexAttribute(enrich.joinClause);
}

return enrich;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectMetric" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectMetric: project="+__prettyPrintJSON(project));
var metric = this._loadProjectFile(project, "metric.json", true) || [];

// migration
this._stripIndexAttribute(metric);

return metric;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectOutput" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectOutput: project="+__prettyPrintJSON(project));
var output = this._loadProjectFile(project, "output.json", true);

// migration
var base = this._getBaseOutputModel();
if (output != null) {
    var reserved = {};
    for (var i=0; i<base.length; i++) {
        reserved[base[i]["name"]] = true;
    }
    for (var i=0; i<base.length; i++) {
        if (reserved[output[i]["name"]] == true) {
            output[i]["__reserved__"] = true;
        }
    }
}
else {
    output = base;
}

this._stripIndexAttribute(output);

return output;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectPivot" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectPivot: project="+__prettyPrintJSON(project));
var pivot = this._loadProjectFile(project, "pivot.json", true);
if (pivot == null) return null;

// migration
if (pivot.pivot == null && pivot.schema != null) {
    pivot.pivot = pivot.schema;
    delete pivot.schema;
}
if (pivot.pivot != null) {
    pivot.pivot.forEach(function(item) {
        if (item["__metric_uom__"] == null) {
            item["__metric_uom__"] = "Count";
        }
        if (item["__metric_aggr__"] == null) {
            item["__metric_aggr__"] = "sum";
        }
        if (item["__ingestion_metric_aggr__"] == null) {
            item["__ingestion_metric_aggr__"] = "sum";
        }
    });
}
else {
    pivot.pivot = [];
}
if (pivot.dimensions == null) {
    pivot.dimensions = [];
}
if (pivot.measures == null) {
    pivot.measures = [];
}
if (pivot.metric != null) {
    delete pivot.metric["__index__"];
}
if (pivot.timestamp != null) {
    delete pivot.timestamp["__index__"];
}
this._stripIndexAttribute(pivot.dimensions);
this._stripIndexAttribute(pivot.measures);
this._stripIndexAttribute(pivot.pivot);

if (pivot.timestamp && pivot.timestamp.data_type) {
    switch (pivot.timestamp.data_type) {
        case "datetime":
            delete pivot.unitOfTime;
            break;
        case "long":
        case "double":
            if (pivot.timestamp.meta_data != null && pivot.timestamp.meta_data.max != null) {
                if (pivot.timestamp.meta_data.max < 10000000000) {
                    // seconds
                    pivot.unitOfTime = "second";
                }
                else if (pivot.timestamp.meta_data.max < 10000000000000) {
                    // milliseconds
                    pivot.unitOfTime = "millisecond";
                }
                else if (pivot.timestamp.meta_data.max < 10000000000000000) {
                    // microseconds
                    pivot.unitOfTime = "microsecond";
                }
                else {
                    // nanoseconds
                    pivot.unitOfTime = "nanosecond";
                }
            }
            else {
                pivot.unitOfTime = "second";
            }
            break;
        default:
            delete pivot.unitOfTime;
            break;
    }
}
else {
    delete pivot.unitOfTime;
}

return pivot;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectQDC" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectQDC: project="+__prettyPrintJSON(project));
var qdc = this._loadProjectFile(project, "qdc.json", true);
if (!qdc) {
    qdc = {};
    qdc["svc:" + project.svc] = {
        "operator": "and",
        "items": []
    };
}

function removeQDCDisplayAttributes(arr)
{
    if (arr != null) {
        for (var i=0; i<arr.length; i++) {
            var qdc = arr[i];
            delete qdc._scope_;
            delete qdc._oper_;
            delete qdc._value_;
        }
    }
}

// migration
// this._stripIndexAttribute(qdc);
// removeQDCDisplayAttributes(qdc);

return qdc;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectSample" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectSample: project="+__prettyPrintJSON(project));
var result = this._loadProjectFile(project, "sample.json", true);

// migration
if (result != null && !this._hasProjectFile(project, "original-sample.json")) {
    this._saveProjectFile(project, "original-sample.json", result, true);
    if (result.length > 100) {
        result = result.slice(0, 100);
        this._saveProjectFile(project, "sample.json", result, true);
    }
}

return result;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectSchema" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectSchema: project="+__prettyPrintJSON(project));
var schema = this._loadProjectFile(project, "schema.json", true) || [];

// migration
for (var i=0, n=schema.length; i<n; i++) {
    var field = schema[i];
    if (field.ignore === undefined) field.ignore = false;
    if (field.meta_data === undefined) field.meta_data = null;
    if (field.format === undefined) field.format = "";
}
this._stripIndexAttribute(schema);

return schema;
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectTestModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectTestModel: project="+__prettyPrintJSON(project));
return this._loadProjectFile(project, "tests.json", true);
]]>
        </CodeText>
      </Service>
      <Service name="loadProjectTestScript" args="project" private="false">
        <CodeText>
          <![CDATA[//print("loadProjectTestScript: project="+__prettyPrintJSON(project));
var script = this._loadProjectFile(project, "tests.js", false);

// migration for JSON stringified to raw text
if (script != null && script != "" && script.charAt(0) == '"' && script.charAt(script.length-1) == '"') {
    script = JSON.parse(script);
}
return script;

]]>
        </CodeText>
      </Service>
      <Service name="needResetProject" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var resetOptions = {
    needResetParserSource: false,
    needResetParserTarget: false,
    needResetOutput: false,
};

var output = this.loadProjectOutput(project);

var queryConfig = this.getQueryConfig();
var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
var sql = Context.getLocalResource("MODEL_INFO_SELECT_SQL");
sql = this._doValueSubstitution(sql, {
    uuid: project.uuid,
    name: deployment.name
});
var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Model Info Item", "Select"], DS, sql, null);
if (result != null && result.items != null && result.items.length > 0) {
    var item = result.items[0];
    //handle hive table and hdfs directory
    var defaultValues = this._getDefaultValues();
    
    var deploymentGlobalMap = {};
    deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
        deploymentGlobalMap[item.id] = item;
    });
    
    var anomalyGlobalMap = {};
    deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
        anomalyGlobalMap[item.id] = item;
    });
    
    var oldHdfsServerURL = item["hdfs_server_url"];
    var oldSourcePath = item["source_path"];
    var oldSparkSqlTablePath = item["spark_sql_table_path"];
    var oldSparkSqlTable = item["spark_sql_table"];
    var oldAnomalyFilePath = item["anomaly_file_path"];
    
    var newHdfsServerURL = project.hdfsServerURL;
    var newSourcePath = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
    var newSparkSqlTablePath = (deploymentGlobalMap["spark_sql_table_url"].value || deploymentGlobalMap["spark_sql_table_url"].defaultValue).substring(project.hdfsServerURL.length);
    var newSparkSqlTable = deploymentGlobalMap["spark_sql_table"].value || deploymentGlobalMap["spark_sql_table"].defaultValue;
    var newAnomalyFileUrl = project.anomalyFileUrl || (project.hdfsServerURL + defaultValues["anomaly-path"] + project.sourceGroup);
    var newAnomalyFilePath = newAnomalyFileUrl.substring(project.hdfsServerURL.length);
   
    if (oldHdfsServerURL != newHdfsServerURL || oldSourcePath != newSourcePath) {
        if (oldHdfsServerURL != null && oldSourcePath != null && oldSourcePath.indexOf(defaultValues["source-path"]) != -1) {
            resetOptions.needResetParserSource = true;
        }
    }
    if (oldSparkSqlTable != newSparkSqlTable && oldSparkSqlTable != null) {
        resetOptions.needResetParserTarget = true;
    }
    if (oldHdfsServerURL != newHdfsServerURL || oldSparkSqlTablePath != newSparkSqlTablePath) {
        if (oldHdfsServerURL != null && oldSparkSqlTablePath != null) {
            resetOptions.needResetParserTarget = true;
        }
    }
    if (oldHdfsServerURL != newHdfsServerURL || oldAnomalyFilePath != newAnomalyFilePath) {
        if (oldHdfsServerURL != null && oldAnomalyFilePath != null) {
            resetOptions.needResetParserTarget = true;
        }
    }
    
    var outputNames = [];
    if (output) {
        output.forEach(function(record){
            outputNames.push(record["name"]);
        });
    }
    var outputNameList = outputNames.join(",");
    if (item["output_name_list"] != null && item["output_name_list"] != "" && item["output_name_list"] != outputNameList) {
        resetOptions.needResetOutput = true;
    }
    return resetOptions;
} else {
    return resetOptions;
}]]>
        </CodeText>
      </Service>
      <Service name="parseSampleData" args="project" private="false">
        <CodeText>
          <![CDATA[/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/sample.txt");
var text = Context.getFileAsString(path);
*/

var text = this._loadProjectFile(project, "sample.txt", false);
var parserName = this._getTemplate(project, "parse-sample");
if (parserName != null) {
    var parserFunc = this[parserName];
    if (parserFunc != null) {
        this._parseText(project, parserFunc, text);
    }
    else {
        print("ERROR: parser function not implemented - " + parserName);
    }
}
else {
    switch (project.sample.type) {
        case "application/json":
            // try parsing individual lines
            try {
                var lines = text.trim().split("\n");
                var buf = [];
                for (var i=0, n=lines.length; i<n; i++) {
                    if ((lines[i]).trim() != "") {
                        var obj = JSON.parse(lines[i]);
                    }
                }
                project.sample.jsonEncoding = "LINE";
            }
            catch (err1) {
                try {
                    // if parse failed... try parsing whole file
                    var obj = JSON.parse(text);
                    project.sample.jsonEncoding = "FILE";
                }
                catch (err2) {
                    // still failed... invalid JSON
                    project.sample.jsonEncoding = "INVALID";
                }
            }
            break;
    }
}
]]>
        </CodeText>
      </Service>
      <Service name="purgeModel" args="project,deployment,model,purge" private="false">
        <CodeText>
          <![CDATA[//so cli rest

var projectData = this.loadProjectByName(project);
if(projectData == null){
    throw "Project " + project + " does not exist.";
}
var status = this.getRuntimeStatus(projectData, deployment);
print('purge model', purge);

switch(model){
    case 'Anomaly':
        if(status.rtAnomalyStatus != "NOT_ACTIVE" || status.rtAnomalyStatus == "NOT_FOUND")
            throw 'Anomaly is ' + status.rtAnomalyStatus;
        this.purgeAnomalyModel(projectData, deployment, 'RT', purgeRuntime(), purgeCheckpoint());
        break;
    case 'CustomIngestion':
        if(status.serviceParserStatus != "NOT_ACTIVE" || status.serviceParserStatus == "NOT_FOUND")
            throw 'CustomIngestion is ' + status.serviceParserStatus;
        this.purgeParserModel(projectData, deployment, 'SERVICE', purgeRuntime(), purgeCheckpoint(), purgeInputOutput(), purgeInputOutput());
        break;
    case 'ContinuousIngestion':
        if(status.rtParserStatus != "NOT_ACTIVE" || status.rtParserStatus == "NOT_FOUND")
            throw 'Continuous Ingestion is ' + status.rtParserStatus;
        this.purgeParserModel(projectData, deployment, 'RT', purgeRuntime(), purgeCheckpoint(), purgeInputOutput(), purgeInputOutput());
        break;
    default :
        throw "Don't know model " + model;
}
//return ['purge model ', project, deployment, model, purgeRuntime(), purgeCheckpoint(), purge];

function purgeRuntime(){
    return option('purgeRuntime') ? option('purgeRuntime')[1] === 'true' : false;
}

function purgeCheckpoint(){
    return option('purgeCheckpoint') ? option('purgeCheckpoint')[1] === 'true' : false;
}

function purgeInputOutput(){
    return option('purgeInputOutput') ? option('purgeInputOutput')[1] === 'true' : false;
}

function option(name){
    if(!purge) return null;
    return purge.split('&')
            .map(function(o){ return o.split('=');  })
            .filter(function(o){ return o[0] === name; })[0]
}]]>
        </CodeText>
      </Service>
      <Service name="resetAnomalyModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var uri = this.getAnomalyModelURL(project, deployment);

var rtAnomalyStatus = this.getAnomalyRuntimeStatus(project, deployment, "RT");
if (rtAnomalyStatus == "ACTIVE" || rtAnomalyStatus == "STARTED") {
    this.stopAnomalyModel(project, deployment, "RT");
}

if (this._mrHasModel(uri)) {
    var status = this._doPurge(uri);
    print("resetAnomalyModel: " + uri + "=" + status);
    
    if (rtAnomalyStatus != "NOT_FOUND") {
        this._doUndeploy(uri, "RT");
    }
    
    this._mrDeleteModel(uri);
}]]>
        </CodeText>
      </Service>
      <Service name="resetIncidentConfig" args="project" private="false">
        <CodeText>
          <![CDATA[if (project.configs != null) {
    var queryConfig = this.getQueryConfig();
    var algorithm = project.detectionAlgorithm;
    var threshold_policy = project.thresholdPolicy;
    var metricIds = [];
    project.configs.forEach(function(config) {
        metricIds.push(config.metricId);
    });
    this._deleteIncidentConfig(queryConfig, metricIds, algorithm, threshold_policy);
}
return true;
]]>
        </CodeText>
      </Service>
      <Service name="resetIncidentSummary" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var queryConfig = this.getQueryConfig();

var obj = this.generateSystemModel(project, deployment, "demo", project.detail.schema, project.detail.pivot, project.detail.count, 
                                   project.detail.enrich, project.detail.output, project.detail.qdc, project.detail.metric);
if (obj != null) {
    var metrics = this._getMetricsInSystemModel(obj);
    var deleteMetrics = [];
    metrics.forEach(function(metric) {
        deleteMetrics.push([metric]);
    });
    this._cleanupIncidentSummary(queryConfig, deleteMetrics);
}
]]>
        </CodeText>
      </Service>
      <Service name="resetParserModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var rtParserStatus = this.getParserRuntimeStatus(project, deployment, "RT");
if (rtParserStatus == "ACTIVE" || rtParserStatus == "STARTED") {
    this.stopParserModel(project, deployment, "RT");
}

var serviceParserStatus = this.getParserRuntimeStatus(project, deployment, "Service");
if (serviceParserStatus == "ACTIVE" || serviceParserStatus == "STARTED") {
    this.stopParserModel(project, deployment, "Service");
}

var uri = this.getParserModelURL(project, deployment);

if (this._mrHasModel(uri)) {
    var status = this._doPurge(uri);
    print("resetParserModel: " + uri + "=" + status);
    
    if (rtParserStatus != "NOT_FOUND") {
        this._doUndeploy(uri, "RT");
    }
    
    if (serviceParserStatus != "NOT_FOUND") {
        this._doUndeploy(uri, "Service");
    }
    
    this._mrDeleteModel(uri);
}]]>
        </CodeText>
      </Service>
      <Service name="resetPreProcessModel" args="project" private="false">
        <CodeText>
          <![CDATA[var uri = this.getPreProcessModelURL(project);
if (this._mrHasModel(uri)) {
    var status = this._doPurge(uri);
    print("resetPreProcessModel: " + uri + "=" + status);
    
    this._mrDeleteModel(uri);
}
]]>
        </CodeText>
      </Service>
      <Service name="resetProject" args="project,deployment,options" private="false">
        <CodeText>
          <![CDATA[if (!deployment) return;

if (!options) {
    options = {
        resetParserModel: true,
        resetParserSource: true,
        resetParserTarget: true,
        resetAnomalyModel: true,
        resetDataResourceModel: true,
        resetSystemModel: true,
    };
}

if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deploymnet ' + deploymentName + ' does not exist.';
}

var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var defaultValues = this._getDefaultValues();
project.detail = this.loadProject(project);


// delete generated models and artifacts
var resetOldOptions = {
    resetParserSource: options.resetParserSource,
    resetParserTarget: options.resetParserTarget,
    resetDataResourceModel: options.resetDataResourceModel
};

try {
    this.cleanupOldArtifacts(project, deployment, resetOldOptions);
} catch (ex) {
    ex.printStackTrace();
}

if (options.resetDataResourceModel) {
    try {
        this.resetResourceModel(project, deployment);
    } catch (ex) {
        ex.printStackTrace();
    }
}

try {
    this.resetPreProcessModel(project);
} catch (ex) {
    ex.printStackTrace();
}

if (options.resetParserModel) {
    try {
        this.resetParserModel(project, deployment);
    } catch (ex) {
        ex.printStackTrace();
    }
}
if (options.resetAnomalyModel) {
    try {
        this.resetAnomalyModel(project, deployment);
        this.resetIncidentSummary(project, deployment);
    } catch (ex) {
        ex.printStackTrace();
    }
}

if (options.resetSystemModel) {
    try {
        this.resetSystemModel(project, deployment);
        this.resetIncidentConfig(project);
    } catch (ex) {
        ex.printStackTrace();
    }
}

if (options.resetParserModel) {
    var parserModelName = this.getParserModelName(project, deployment);
    var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + Context.getCurrentUserId() + "/" + parserModelName + "/parserContext.json");
    var file = new File(path);
    if (file.exists()) {
        file.delete();
    
        path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + Context.getCurrentUserId() + "/" + parserModelName);
        file = new File(path);
        file.delete();
    }
}

if (options.resetAnomalyModel) {
    var anomalyModelName = this.getAnomalyModelName(project, deployment);
    path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + Context.getCurrentUserId() + "/" + anomalyModelName + "/anomalyContext.json");
    file = new File(path);
    if (file.exists()) {
        file.delete();
    
        path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + Context.getCurrentUserId() + "/" + anomalyModelName);
        file = new File(path);
        file.delete();
    }
}

var fs = null;
try {
    fs = HDFS.getFileSystem(project.hdfsServerURL);
} catch (ex) {
    ex.printStackTrace();
}
if (fs != null) {
    
    var deploymentGlobalMap = {};
    deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
        deploymentGlobalMap[item.id] = item;
    });

    if (options.resetParserSource) {
        // delete source data directory on HDFS server
        var path = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
        if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
            this._purgeInput(project, deployment);
        }
    }

    if (options.resetParserTarget) {
        // delete target data directory on HDFS server
        path = (deploymentGlobalMap["spark_sql_table_url"].defaultValue || deploymentGlobalMap["spark_sql_table_url"].value).substring(project.hdfsServerURL.length);
        if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
            HDFS.deleteDirectory(fs, path, true);
        }
    }

    HDFS.closeFileSystem(project.hdfsServerURL, fs);
}

]]>
        </CodeText>
      </Service>
      <Service name="resetResourceModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var obj = this.generateResourceModel(project, deployment, project.detail.output);
if (obj != null) {
    this._hiveDeleteTable(obj.model);
}

var uri = this.getResourceModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    this._mrDeleteModel(uri);
}
]]>
        </CodeText>
      </Service>
      <Service name="resetSystemModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var queryConfig = this.getQueryConfig();

var obj = this.generateSystemModel(project, deployment, "demo", project.detail.schema, project.detail.pivot, project.detail.count, 
                                   project.detail.enrich, project.detail.output, project.detail.qdc, project.detail.metric);
if (obj != null) {
    this._updateParseTable(queryConfig, obj, true);
    this._updateMetricInfo(queryConfig, obj, true);
    this._updateQdcTable(queryConfig, obj, true);
    
    var metrics = this._getMetricsInSystemModel(obj);
    var deleteMetrics = [];
    metrics.forEach(function(metric) {
        deleteMetrics.push([metric]);
    });
    this._clenupMetricInfo(queryConfig, deleteMetrics);
    this._cleanupMetricQDC(queryConfig, deleteMetrics);
    this._cleanupIncidentConfig(queryConfig, deleteMetrics);
    this._cleanupParseTable(queryConfig, deleteMetrics);
    var anomalyGlobalMap = {};
    deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
        anomalyGlobalMap[item.id] = item;
    });
    var admName = anomalyGlobalMap["adm_name_m"].value || anomalyGlobalMap["adm_name_m"].defaultValue;
    this._cleanupAnomalySOL(queryConfig, admName);
}

var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var uri = this.getSystemModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    this._mrDeleteModel(uri);
}

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/system_models/" + project.uuid + ".json");
//print("resetSystemModel: path="+path);
var file = new File(path);
file.delete();

this._deleteProjectFile(project, 'system-model');

// force re-caching of ServiceConfig, FilterConfig,... to drop metrics
this._updateSystemModelLastModified();
this._updateCachedConfig(queryConfig);

return true;
]]>
        </CodeText>
      </Service>
      <Service name="runBaselineGeneration" args="project,deployment,startDate,endDate,waitForStop" private="false">
        <CodeText>
          <![CDATA[//print("runBaselineGeneration: project="+__prettyPrintJSON(project));
//print("runBaselineGeneration: startDate="+startDate);
//print("runBaselineGeneration: endDate="+endDate);

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var anomalyGlobalMap = {};
deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
    anomalyGlobalMap[item.id] = item;
});

var Thread = java.lang.Thread;
var nameDefaults = this.getNameDefaults(project);

var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
var sourceGroup = (project.sourceGroup || nameDefaults.sourceGroup);
var targetGroup = (project.targetGroup || nameDefaults.targetGroup);
var defaultValues = this._getDefaultValues();

var service = this.getWorkbenchConfig()["baseline-generation-service"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("runBaselineGeneration: " + uri + " not found");
    }
    if (this._isRunning(uri)) {
        print("runBaselineGeneration: " + uri + " is busy");
    }
    var profile = service["adf-profile"];
    //this._setADFProfileValue(profile.common.global, "name", targetGroup + "-5/5");
    this._setADFProfileValue(profile.common.global, "name", anomalyGlobalMap["adm_name_m"].value || anomalyGlobalMap["adm_name_m"].defaultValue);
    this._setADFProfileValue(profile.common.global, "startDate", startDate);
    this._setADFProfileValue(profile.common.global, "endDate", endDate);
    this._setADFProfileValue(profile.common.global, "baselineTable", anomalyGlobalMap["baseline_table_name"].value || anomalyGlobalMap["baseline_table_name"].defaultValue);
    this._setADFProfileValue(profile.common.global, "overrideBaselineTable", anomalyGlobalMap["override_baseline_table_name"].value || anomalyGlobalMap["override_baseline_table_name"].defaultValue);
    this._setADFProfileValue(profile.common.global, "systemModelTable", anomalyGlobalMap["p_system_model"].value || anomalyGlobalMap["p_system_model"].defaultValue);
    
    if (defaultValues.historyBaselineTable) {
        this._setADFProfileValue(profile.common.global, "historyBaselineTable", defaultValues.historyBaselineTable);
    }
    
    var ret = this._doStart(uri, profile);
    if (ret != "STARTED" && ret != "PARTIALLYSTARTED") {
        throw "BaselineGenerationNotStarted:"+ret;
    }

    if (!waitForStop) return ret;
    var maxWaitCount = 60;
    while (this._isRunning(uri) && maxWaitCount > 0) {
        Thread.sleep(1000);
        maxWaitCount--;
    }
    return !this._isRunning(uri);
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="runBatchProcess" args="project,deployment,startEpoch,endEpoch" private="false">
        <CodeText>
          <![CDATA[//print("runBatchProcess: project="+__prettyPrintJSON(project));
//print("runBatchProcess: startEpoch="+startEpoch);
//print("runBatchProcess: endEpoch="+endEpoch);

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

function padStr(num, len)
{
    var str = String(num);
    while (str.length < len) {
        str = "0" + str;
    }
    return str;
}

function getShortDate(dt)
{
    return dt.getUTCFullYear() + "-" + padStr(dt.getUTCMonth()+1, 2) + "-" + padStr(dt.getUTCDate(), 2);
}

var waitForStop = true;

var startDate = new Date(startEpoch*1000);
var endDate = new Date(endEpoch*1000);

var value = this.runBaselineGeneration(project, deployment, getShortDate(startDate), getShortDate(endDate), waitForStop);

// IDEALLY, we want to compute statistics and percentile using as much data as possible
// to get the best analysis of the data stream
// BUT reality is, we are not currently using these information... but we DO NOT some data
// for the process to run.. so we just compute using the same time range as baseline
// var maxDate = new Date(endEpoch*1000);
// var minDate = new Date(endEpoch*1000);
// minDate.setDate(minDate.getDate() - (12*7));
var minDate = startDate;
var maxDate = endDate;

var value = this.runPercentileGeneration(project, deployment, getShortDate(minDate), getShortDate(maxDate), waitForStop);

var value = this.runStatisticsGeneration(project, deployment, getShortDate(minDate), getShortDate(maxDate), waitForStop);

return true;
]]>
        </CodeText>
      </Service>
      <Service name="runPercentileGeneration" args="project,deployment,startDate,endDate,waitForStop" private="false">
        <CodeText>
          <![CDATA[//print("runPercentileGeneration: project="+__prettyPrintJSON(project));
//print("runPercentileGeneration: startDate="+startDate);
//print("runPercentileGeneration: endDate="+endDate);

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var anomalyGlobalMap = {};
deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
    anomalyGlobalMap[item.id] = item;
});

var Thread = java.lang.Thread;
var nameDefaults = this.getNameDefaults(project);

var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
var sourceGroup = (project.sourceGroup || nameDefaults.sourceGroup);
var targetGroup = (project.targetGroup || nameDefaults.targetGroup);

var service = this.getWorkbenchConfig()["percentile-generation-service"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("runPercentileGeneration: " + uri + " not found");
    }
    if (this._isRunning(uri)) {
        print("runPercentileGeneration: " + uri + " is busy");
    }
    var profile = service["adf-profile"];
    //this._setADFProfileValue(profile.common.global, "name", targetGroup + "-5/5");
    this._setADFProfileValue(profile.common.global, "name", anomalyGlobalMap["adm_name_m"].value || anomalyGlobalMap["adm_name_m"].defaultValue);
    this._setADFProfileValue(profile.common.global, "from", startDate);
    this._setADFProfileValue(profile.common.global, "to", endDate);
    this._setADFProfileValue(profile.common.global, "systemModelTable", anomalyGlobalMap["p_system_model"].value || anomalyGlobalMap["p_system_model"].defaultValue);
    this._setADFProfileValue(profile.common.global, "tableName", anomalyGlobalMap["percentile"].value || anomalyGlobalMap["percentile"].defaultValue);
    
    var ret = this._doStart(uri, profile);
    if (ret != "STARTED" && ret != "PARTIALLYSTARTED") {
        throw "PercentileGenerationNotStarted:"+ret;
    }

    if (!waitForStop) return ret;
    var maxWaitCount = 60;
    while (this._isRunning(uri) && maxWaitCount > 0) {
        Thread.sleep(1000);
        maxWaitCount--;
    }
    return !this._isRunning(uri);
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="runStatisticsGeneration" args="project,deployment,startDate,endDate,waitForStop" private="false">
        <CodeText>
          <![CDATA[//print("runStatisticsGeneration: project="+__prettyPrintJSON(project));
//print("runStatisticsGeneration: startDate="+startDate);
//print("runStatisticsGeneration: endDate="+endDate);
if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var anomalyGlobalMap = {};
deployment.anomalyProfile.common["Anomaly Properties"].forEach(function (item) {
    anomalyGlobalMap[item.id] = item;
});

var Thread = java.lang.Thread;
var nameDefaults = this.getNameDefaults(project);

var namePrefix = (project.safePrefix || nameDefaults.namePrefix);
var sourceGroup = (project.sourceGroup || nameDefaults.sourceGroup);
var targetGroup = (project.targetGroup || nameDefaults.targetGroup);

var service = this.getWorkbenchConfig()["statistics-generation-service"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("runStatisticsGeneration: " + uri + " not found");
    }
    if (this._isRunning(uri)) {
        print("runStatisticsGeneration: " + uri + " is busy");
    }
    var profile = service["adf-profile"];
    //this._setADFProfileValue(profile.common.global, "adm", targetGroup + "-5/5");
    this._setADFProfileValue(profile.common.global, "adm", anomalyGlobalMap["adm_name_m"].value || anomalyGlobalMap["adm_name_m"].defaultValue);
    this._setADFProfileValue(profile.common.global, "dailyFrom", startDate);
    this._setADFProfileValue(profile.common.global, "dailyTo", endDate);
    this._setADFProfileValue(profile.common.global, "weekHourlyFrom", startDate);
    this._setADFProfileValue(profile.common.global, "weekHourlyTo", endDate);
    this._setADFProfileValue(profile.common.global, "weeklyFrom", startDate);
    this._setADFProfileValue(profile.common.global, "weeklyTo", endDate);
    this._setADFProfileValue(profile.common.global, "from", startDate);
    this._setADFProfileValue(profile.common.global, "to", endDate);
    this._setADFProfileValue(profile.common.global, "systemModelTable", anomalyGlobalMap["p_system_model"].value || anomalyGlobalMap["p_system_model"].defaultValue);
    this._setADFProfileValue(profile.common.global, "tableName", anomalyGlobalMap["statistic"].value || anomalyGlobalMap["statistic"].defaultValue);
    
    var ret = this._doStart(uri, profile);
    if (ret != "STARTED" && ret != "PARTIALLYSTARTED") {
        throw "StatisticsGenerationNotStarted:"+ret;
    }

    if (!waitForStop) return ret;
    var maxWaitCount = 60;
    while (this._isRunning(uri) && maxWaitCount > 0) {
        Thread.sleep(1000);
        maxWaitCount--;
    }
    return !this._isRunning(uri);
}
return null;
]]>
        </CodeText>
      </Service>
      <Service name="saveProject" args="project,schema,pivot,count,enrich,output,qdc,metric" private="false">
        <CodeText>
          <![CDATA[project.prjName = project.svc + "|" + project.comp + "|" + project.app;

var projectList = this.listProjectPickerList();
projectList = projectList.filter(function (item) {
    return item.uuid != project.uuid && item.prjName == project.prjName;
});

if (projectList.length > 0) {
    throw "Project " + project.prjName + " already exists, please change the service, sub-service or component name..."
}

if (project.__prjname_changed__ == true) {
    project.prefix = (project.svc + "_" + project.comp + "_" + project.app).replace(/\s|-/g, "_");
}
this._updateSafePrefix(project);
this._updateProjectOutputHash(project, output);

//this._fsSaveToFile("nuova_stella/" + project.uuid + "/project", JSON.stringify(project));

if (schema != null) {
    this.saveProjectSchema(project, schema);
}
if (pivot != null) {
    this.saveProjectPivot(project, pivot);
}
if (count != null) {
    this.saveProjectCount(project, count);
}
if (enrich != null) {
    this.saveProjectEnrich(project, enrich);
}
if (output != null) {
    this.saveProjectOutput(project, output);
}
if (qdc != null) {
    this.saveProjectQDC(project, qdc);
}
if (metric != null) {
    this.saveProjectMetric(project, metric);
}
if (schema != null && pivot != null) {
    var tests = this.getTestModel(project, schema, pivot);
    this.saveProjectTestModel(project, tests);
}

this.updateProjectAndDeploymentDefaultValues(project, enrich);

this.saveProjectModel(project);

return true;
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectCount" args="project,count" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectCount: project="+__prettyPrintJSON(project));
//print("saveProjectCount: count="+__prettyPrintJSON(count));
this._stripIndexAttribute(count);
return this._saveProjectFile(project, "count.json", count, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectEnrich" args="project,enrich" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectEnrich: project="+__prettyPrintJSON(project));
//print("saveProjectEnrich: enrich="+__prettyPrintJSON(enrich));
this._stripIndexAttribute(enrich.leftFields);
this._stripIndexAttribute(enrich.rightFields);
this._stripIndexAttribute(enrich.joinClause);
return this._saveProjectFile(project, "enrich.json", enrich, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectMetric" args="project,metric" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectMetric: project="+__prettyPrintJSON(project));
//print("saveProjectMetric: metric"+__prettyPrintJSON(metric));

this._stripIndexAttribute(metric);

return this._saveProjectFile(project, "metric.json", metric, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectModel" args="project" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
if (queryConfig['storage_type'] == 'local-file') {
    this._saveProjectFile(project, "project.json", project);
} else {
    var DS = queryConfig['data-source']['storage-model'] || 'viaops_runtime_db';
    var sql = Context.getLocalResource("PROJECT_TABLE_EXIST_SQL");
    sql = this._doValueSubstitution(sql, {
        uuid: project.uuid
    });
    var result = this.executeSQLQuery(queryConfig, [], ["Signal Onboarding", "Project", "Exist"], DS, sql, null);
    project.prjName = project.svc + "|" + project.comp + "|" + project.app;
    if (result != null && result.items != null && result.items.length > 0) {
        sql = Context.getLocalResource("PROJECT_TABLE_UPDATE_SQL");
        this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project", "Update"], DS, sql, [[project.svc, project.svcLabel, project.comp, 
            project.compLabel, project.app, project.appLabel, '', Context.getCurrentUserId(), 
            project.anomalyModelType, project.outputHash, project.prjName, project.anomalyReference, project.uuid]]);
    } else {
        sql = Context.getLocalResource("PROJECT_TABLE_INSERT_SQL");
        this.executeSQLUpdate(queryConfig, [], ["Signal Onboarding", "Project", "Insert"], DS, sql, [[project.uuid, project.svc, project.svcLabel, project.comp, 
            project.compLabel, project.app, project.appLabel, '', Context.getCurrentUserId(), Context.getCurrentUserId(), 
            project.anomalyModelType, project.outputHash, project.prjName, project.anomalyReference]]);
    }
    
    this._saveProjectFile(project, "project.json", project, true);
}
return true;]]>
        </CodeText>
      </Service>
      <Service name="saveProjectOutput" args="project,output" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectOutput: project="+__prettyPrintJSON(project));
//print("saveProjectOutput: output"+__prettyPrintJSON(output));
this._stripIndexAttribute(output);
return this._saveProjectFile(project, "output.json", output, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectPivot" args="project,pivot" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectPivot: project="+__prettyPrintJSON(project));
//print("saveProjectPivot: pivot"+__prettyPrintJSON(pivot));
if (pivot.timestamp != null) {
    delete pivot.timestamp["__index__"];
}
this._stripIndexAttribute(pivot.dimensions);
this._stripIndexAttribute(pivot.measures);
this._stripIndexAttribute(pivot.pivot);
return this._saveProjectFile(project, "pivot.json", pivot, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectQDC" args="project,qdc" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectQDC: project="+__prettyPrintJSON(project));
//print("saveProjectQDC: qdc"+__prettyPrintJSON(qdc));

function removeQDCDisplayAttributes(arr)
{
    if (arr != null) {
        for (var i=0; i<arr.length; i++) {
            var qdc = arr[i];
            delete qdc._scope_;
            delete qdc._oper_;
            delete qdc._value_;
        }
    }
}

for (var scope in qdc) {
    var scopeQDC = qdc[scope];
    this._stripIndexAttribute(scopeQDC.items);
    removeQDCDisplayAttributes(scopeQDC.items);
}

return this._saveProjectFile(project, "qdc.json", qdc, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectSample" args="project,result" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectSample: project="+__prettyPrintJSON(project));
//print("saveProjectSample: result"+__prettyPrintJSON(result));
this._saveProjectFile(project, "original-sample.json", result, true);
if (result.length > 100) {
    result = result.slice(0, 100);
}
return this._saveProjectFile(project, "sample.json", result, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectSchema" args="project,schema" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectSchema: project="+__prettyPrintJSON(project));
//print("saveProjectSchema: schema"+__prettyPrintJSON(schema));
this._stripIndexAttribute(schema);
return this._saveProjectFile(project, "schema.json", schema, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectTestModel" args="project,tests" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectTest: project="+__prettyPrintJSON(project));
//print("saveProjectTest: tests="+__prettyPrintJSON(tests));
if (tests == null) {
    var schema = this.loadProjectSchema(project);
    var pivot  = this.loadProjectPivot(project);
    tests = this.getTestModel(project, schema, pivot);
}
return this._saveProjectFile(project, "tests.json", tests, true);
]]>
        </CodeText>
      </Service>
      <Service name="saveProjectTestScript" args="project,script" private="false">
        <CodeText>
          <![CDATA[//print("saveProjectTestScript: project="+__prettyPrintJSON(project));
//print("saveProjectTestScript: script="+script);
return this._saveProjectFile(project, "tests.js", script, false);
]]>
        </CodeText>
      </Service>
      <Service name="showDebugTabs" args="" private="false">
        <CodeText>
          <![CDATA[var queryConfig = this.getQueryConfig();
if (queryConfig == null) return false;

//print("queryConfig="+__prettyPrintJSON(queryConfig));
return queryConfig["show-debug-tabs"] == true;
]]>
        </CodeText>
      </Service>
      <Service name="startAnomalyModel" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

var uri = this.getAnomalyModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri, instance)) {
        print("startAnomalyModel: " + uri + " is already running");
        return "ACTIVE";
    }
    else {
        var profile = this.getAnomalyProfile(project, deployment, instance);
        var value = this._doStart(uri, profile);
        
        if (typeof value == "string") {
            print("startAnomalyModel: " + uri + "=" + value);
            this._notifyStatusChange(project, deployment, 'Anomaly');
            return this._getMappedStatus(value);
        } else {
            return value;
        }
    }
}
else {
    print("startAnomalyModel: " + uri + " not found");
    return "NOT_FOUND";
}
]]>
        </CodeText>
      </Service>
      <Service name="startBaselineScoreModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("startBaselineScoreModel: project="+__prettyPrintJSON(project));

var defaultValues = this._getDefaultValues();
var service = this.getWorkbenchConfig()["incident-baseline-score"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("startBaselineScoreModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (this._isRunning(uri)) {
        print("startBaselineScoreModel: " + uri + " is already running");
        return "ACTIVE";
    }
    var profile = service["adf-profile"];
    this._setADFProfileValue(profile.common.global, "p_anomaly_source", project.hdfsServerURL + defaultValues["incident-path"]);
    this._setADFProfileValue(profile.common.global, "p_incident_plus_da", project.hdfsServerURL + defaultValues["grouping-path"]);
    
    var value = this._doStart(uri, profile);
    if (typeof value == "string") {
        return this._getMappedStatus(value);
    } else {
        return value;
    }
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="startDeclaredEventModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("startDeclaredEventModel: project="+__prettyPrintJSON(project));

var defaultValues = this._getDefaultValues();
var service = this.getWorkbenchConfig()["incident-declared-event"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("startDeclaredEventModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (this._isRunning(uri)) {
        print("startDeclaredEventModel: " + uri + " is already running");
        return "ACTIVE";
    }
    var profile = service["adf-profile"];
    this._setADFProfileValue(profile.common.global, "p_event_source", project.hdfsServerURL + defaultValues["declared-path"]);
    this._setADFProfileValue(profile.common.global, "p_incident_plus_da", project.hdfsServerURL + defaultValues["grouping-path"]);
    
    var value = this._doStart(uri, profile);
    if (typeof value == "string") {
        return this._getMappedStatus(value);
    } else {
        return value;
    }
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="startModel" args="project,model,deployment,start,end,stopBatches" private="false">
        <CodeText>
          <![CDATA[// so cli rest
var projectData = this.loadProjectByName(project);
checkRuntimeStatuses(this.getProjectRuntimeStatuses(projectData), deployment);
var toIsoDate = this._toDateString.bind(this);

switch(model){
    case 'CustomIngestion' : 
        return this.startServiceParserModel(projectData, deployment, "Service", customConfig());
    case 'ContinuousIngestion' :
        if(start)
            return this.startServiceParserModel(projectData, deployment, "RT", {'start_date' : start });
        else 
            return this.startParserModel(projectData, deployment, "RT");
        break;
    case 'Anomaly' :
        return this.startAnomalyModel(projectData, deployment, "RT");
    default :
        throw "Don't know model " + model;
}

function customConfig(){
    return {
        'stop_after_batch': isNaN(parseInt(stopBatches)) ? 1 : parseInt(stopBatches),
        'start_date': start || toIsoDate(new Date()),
        'end_date': end || toIsoDate(new Date(Date.now() + 24 * 60 * 60 * 1000))
    }
}

function checkRuntimeStatuses(statuses, deployment){
    var checkFields = [
        "preprocessStatus",
        "rtParserStatus",
        "serviceParserStatus",
        "rtAnomalyStatus"
    ];
    
    for (var i = 0; i < statuses.length; i++) {
        var item = statuses[i];
        
        if (item.deployment == deployment) continue;
        for (var j = 0; j < checkFields.length; j++) {
            var field = checkFields[j];
            if (item[field] == "ACTIVE") {
                throw "Deployment " + item.deployment + " is running, please stop it......"
            }
        }
    }
}

    


]]>
        </CodeText>
      </Service>
      <Service name="startParserModel" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

var uri = this.getParserModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri, instance)) {
        print("startParserModel: " + uri + " is already running");
        return "ACTIVE";
    }
    else {
        var profile = this.getParserProfile(project, deployment, instance);
        var value = this._doStart(uri, profile);
        
        if (typeof value == "string") {
            print("startParserModel: " + uri + "=" + value);
            this._notifyStatusChange(project, deployment, 'Continuous Ingestion');
            return this._getMappedStatus(value);
        } else {
            return value;
        }
    }
}
else {
    print("startParserModel: " + uri + " not found");
    return "NOT_FOUND";
}
]]>
        </CodeText>
      </Service>
      <Service name="startPreProcessModel" args="project" private="false">
        <CodeText>
          <![CDATA[var uri = this.getPreProcessModelURL(project);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri)) {
        print("startPreProcessModel: " + uri + " is already running");
        return "ACTIVE";
    }
    else {
        var value = this._doStart(uri, null);
        print("startPreProcessModel: " + uri + "=" + value);
        return this._getMappedStatus(value);
    }
}
else {
    print("startPreProcessModel: " + uri + " not found");
    return "NOT_FOUND";
}
]]>
        </CodeText>
      </Service>
      <Service name="startServiceParserModel" args="project,deployment,instance,customConfig" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

var uri = this.getParserModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri, instance)) {
        print("startParserModel: " + uri + " is already running");
        return "ACTIVE";
    }
    else {
        var profile = this.getParserProfile(project, deployment, instance, customConfig);
        var value = this._doStart(uri, profile);
        
        if (typeof value == "string") {
            print("startParserModel: " + uri + "=" + value);
            this._notifyStatusChange(project, deployment, 'Custom Ingestion');
            return this._getMappedStatus(value);
        } else {
            return value;
        }
    }
}
else {
    print("startParserModel: " + uri + " not found");
    return "NOT_FOUND";
}
]]>
        </CodeText>
      </Service>
      <Service name="startSimpleDeviationModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("startSimpleDeviationModel: project="+__prettyPrintJSON(project));

var defaultValues = this._getDefaultValues();
var service = this.getWorkbenchConfig()["incident-simple-deviation"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("startSimpleDeviationModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (this._isRunning(uri)) {
        print("startSimpleDeviationModel: " + uri + " is already running");
        return "ACTIVE";
    }
    var profile = service["adf-profile"];
    this._setADFProfileValue(profile.common.global, "p_source", project.hdfsServerURL + defaultValues["incident-path"]);
    this._setADFProfileValue(profile.common.global, "p_incident_plus_da", project.hdfsServerURL + defaultValues["grouping-path"]);
    
    var value = this._doStart(uri, profile);
    if (typeof value == "string") {
        return this._getMappedStatus(value);
    } else {
        return value;
    }
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="startSimpleThresholdModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("startSimpleThresholdModel: project="+__prettyPrintJSON(project));

var defaultValues = this._getDefaultValues();
var service = this.getWorkbenchConfig()["incident-simple-threshold"];
if (service != null && service["adf-model"] != null && service["adf-profile"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("startSimpleThresholdModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (this._isRunning(uri)) {
        print("startSimpleThresholdModel: " + uri + " is already running");
        return "ACTIVE";
    }
    var profile = service["adf-profile"];
    this._setADFProfileValue(profile.common.global, "p_source", project.hdfsServerURL + defaultValues["incident-path"]);
    this._setADFProfileValue(profile.common.global, "p_incident_plus_da", project.hdfsServerURL + defaultValues["grouping-path"]);
    
    var value = this._doStart(uri, profile);
    if (typeof value == "string") {
        return this._getMappedStatus(value);
    } else {
        return value;
    }
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="stopAnomalyModel" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

var uri = this.getAnomalyModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri, instance)) {
        var value = this._doStop(uri, instance);
        print("stopAnomalyModel: " + uri + "=" + value);
        this._notifyStatusChange(project, deployment, 'Anomaly');
        return this._getMappedStatus(value);
    }
    else {
        print("stopAnomalyModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
}
else {
    print("stopAnomalyModel: " + uri + " not found");
    return "NOT_FOUND";
}

]]>
        </CodeText>
      </Service>
      <Service name="stopBaselineScoreModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("stopIncidentBaselineScoreModel: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-baseline-score"];
if (service != null && service["adf-model"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("stopIncidentBaselineScoreModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (!this._isRunning(uri)) {
        print("stopIncidentBaselineScoreModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
    var value = this._doStop(uri);
    print("stopBaselineScoreModel: " + uri + "=" + value);
    return this._getMappedStatus(value);
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="stopDeclaredEventModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("stopDeclaredEventModel: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-declared-event"];
if (service != null && service["adf-model"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("stopDeclaredEventModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (!this._isRunning(uri)) {
        print("stopDeclaredEventModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
    var value = this._doStop(uri);
    print("stopDeclaredEventModel: " + uri + "=" + value);
    return this._getMappedStatus(value);
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="stopModel" args="project,model,deployment" private="false">
        <CodeText>
          <![CDATA[// so cli rest
switch(model){
    case 'CustomIngestion' : 
        return this.stopParserModel(this.loadProjectByName(project), deployment, "Service");
    case 'ContinuousIngestion' :
        return this.stopParserModel(this.loadProjectByName(project), deployment, "RT");
    case 'Anomaly' :
        return this.stopAnomalyModel(this.loadProjectByName(project), deployment, "RT");
    default :
        return "Don't know model " + model;
}
]]>
        </CodeText>
      </Service>
      <Service name="stopParserModel" args="project,deployment,instance" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    var deploymentName = deployment;
    deployment = this.loadProjectDeployment(project, deployment);
    if(deployment == null)
        throw 'Deployment ' + deploymentName + ' does not exist.'
}

var uri = this.getParserModelURL(project, deployment);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri, instance)) {
        var value = this._doStop(uri, instance);
        print("stopParserModel: " + uri + "=" + value);
        this._notifyStatusChange(project, deployment, 'Serivce');
        return this._getMappedStatus(value);
    }
    else {
        print("stopParserModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
}
else {
    print("stopParserModel: " + uri + " not found");
    return "NOT_FOUND";
}

]]>
        </CodeText>
      </Service>
      <Service name="stopPreProcessModel" args="project" private="false">
        <CodeText>
          <![CDATA[var uri = this.getPreProcessModelURL(project);
if (this._mrHasModel(uri)) {
    if (this._isRunning(uri)) {
        var value = this._doStop(uri);
        print("stopPreProcessModel: " + uri + "=" + value);
        return this._getMappedStatus(value);
    }
    else {
        print("stopPreProcessModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
}
else {
    print("stopPreProcessModel: " + uri + " not found");
    return "NOT_FOUND";
}

]]>
        </CodeText>
      </Service>
      <Service name="stopSimpleDeviationModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("stopIncidentSimpleDeviationModel: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-simple-deviation"];
if (service != null && service["adf-model"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("stopIncidentSimpleDeviationModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (!this._isRunning(uri)) {
        print("stopIncidentSimpleDeviationModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
    var value = this._doStop(uri);
    print("stopIncidentSimpleDeviationModel: " + uri + "=" + value);
    return this._getMappedStatus(value);
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="stopSimpleThresholdModel" args="project" private="false">
        <CodeText>
          <![CDATA[//print("stopIncidentSimpleThresholdModel: project="+__prettyPrintJSON(project));

var service = this.getWorkbenchConfig()["incident-simple-threshold"];
if (service != null && service["adf-model"] != null) {
    var uri = service["adf-model"];
    if (!this._mrHasModel(uri)) {
        print("stopIncidentSimpleThresholdModel: " + uri + " not found");
        return "NOT_FOUND";
    }
    if (!this._isRunning(uri)) {
        print("stopIncidentSimpleThresholdModel: " + uri + " is not running");
        return "NOT_ACTIVE";
    }
    var value = this._doStop(uri);
    print("stopIncidentSimpleThresholdModel: " + uri + "=" + value);
    return this._getMappedStatus(value);
}
return "NOT_FOUND";
]]>
        </CodeText>
      </Service>
      <Service name="undeployProject" args="project,deployment,purge" private="false">
        <CodeText>
          <![CDATA[// so cli rest

var projectData = this.loadProjectByName(project);
if(projectData == null){
    throw "Project " + project + " does not exist.";
}
this.stopParserModel(projectData, deployment, "RT");
this.stopAnomalyModel(projectData, deployment, "RT");
this.stopParserModel(projectData, deployment, "Service");
this.resetProject(projectData, deployment);
]]>
        </CodeText>
      </Service>
      <Service name="updateAnomalyModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

return this.generateAnomalyModel(project, deployment, project.detail.output);
]]>
        </CodeText>
      </Service>
      <Service name="updateIncidentConfig" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (project.configs == null) {
    throw "IncidentConfigNotDefined";
}

if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var deploymentGlobalMap = {};
deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
    deploymentGlobalMap[item.id] = item;
});


var sparkTable = deploymentGlobalMap["spark_sql_table"].value || deploymentGlobalMap["spark_sql_table"].defaultValue;

var queryConfig = this.getQueryConfig();
var algorithm = project.detectionAlgorithm;
var threshold_policy = project.thresholdPolicy;
project.configs.forEach(function(config) {
    var A = config.incidentAlgorithm;
    var P = config.incidentThresholdPolicy;
    var HT = config.incidentHighThreshold;
    var MT = config.incidentMediumThreshold;
    var LT = config.incidentLowThreshold;
    var WT = config.incidentWarmupThreshold;
    var WP = config.incidentWarmupPeriod;
    var CP = config.incidentCooldownPeriod;
    if (A && P && (HT || MT || LT || WT)) {
        // at least ONE must be non-null
        this._createIncidentConfig(queryConfig, config.metricId, sparkTable, A, P, HT, MT, LT, WT, WP, CP);
    }
});
return true;
]]>
        </CodeText>
      </Service>
      <Service name="updateParserModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

return this.generateParserModel(project, deployment, project.detail.schema, project.detail.pivot, project.detail.count, project.detail.enrich, project.detail.output);]]>
        </CodeText>
      </Service>
      <Service name="updatePreResult" args="project,result" private="false">
        <CodeText>
          <![CDATA[//print("updatePreResult: project="+__prettyPrintJSON(project));
//print("updatePreResult: result="+__prettyPrintJSON(result));
return this._saveProjectFile(project, "preprocess.json", result, true);
]]>
        </CodeText>
      </Service>
      <Service name="updatePreScript" args="project,script" private="false">
        <CodeText>
          <![CDATA[this._saveProjectFile(project, 'preprocess.js', script, false);

/**
var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/" + project.uuid + "/preprocess.js");
Context.writeToFile(path, script);
*/
]]>
        </CodeText>
      </Service>
      <Service name="updateProject" args="project,deployment,options" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

if (!project.subservices) {
    project.subservices = [];
}

if (!options) {
    options = {
        updateParserModel: true,
        resetParserSource: false,
        resetParserTarget: false,
        purgeParserModel: false,
        updateAnomalyModel: true,
        purgeAnomalyModel: false,
        updateDataResourceModel: false,
        updateSystemModel: true,
        preRelease: true,
    };
}

this._updateSafePrefix(project);

project.detail = this.loadProject(project);

var RESERVED_FIELD_NAME = ["val", "var", "type", "for", "LONG", "abstract", "case", "catch", "class", "def", "do", "else", "extends", 
    "false", "final", "finally", "for", "forSome", "if", "implicit", "import", "lazy", "match", "new", "null", "object", "override", 
    "package", "private", "protected", "return", "sealed", "super", "this", "throw", "trait", "try", "true", "type", "val", "var", 
    "while", "with", "yield",
];
var invalidFields = [];

// check for invalid field name, etc
for (var i=0, n=project.detail.schema.length; i<n; i++) {
    var field = project.detail.schema[i];
    if (field.ignore != true) {
        if (RESERVED_FIELD_NAME.indexOf(field.name) != -1) {
            invalidFields.push(field.name);
        }
    }
}
if (invalidFields.length > 0) {
    throw "INVALID_FIELD_NAME: " + invalidFields.join(", ");
}

//purge/reset models and artifacts
var resetOldOptions = {
    resetParserSource: options.resetParserSource,
    resetParserTarget: options.resetParserTarget,
    resetDataResourceModel: options.updateDataResourceModel
};
this.cleanupOldArtifacts(project, deployment, resetOldOptions);

if (options.purgeParserModel) {
    var parserModelURI = this.getParserModelURL(project, deployment);
    if (this._mrHasModel(parserModelURI)) {
        var status = this._doPurge(parserModelURI);
        print("resetParserModel: " + parserModelURI + "=" + status);
    }
}

if (options.purgeAnomalyModel) {
    var anomalyModelURI = this.getAnomalyModelURL(project, deployment);
    if (this._mrHasModel(anomalyModelURI)) {
        var status = this._doPurge(anomalyModelURI);
        print("resetAnomalyModel: " + anomalyModelURI + "=" + status);
    }
}
// generate/update models and artifacts
this.preGenerateDeploymentModels(project, deployment, options);
if (options.updateParserModel) {
    this.updateParserModel(project, deployment);
}
if (project['anomalyModelType'] == 'own-anomaly' || project['anomalyModelType'] == null) {
    if (options.updateAnomalyModel) {
        this.updateAnomalyModel(project, deployment);
    }
}

if(options.updateDataResourceModel && project['anomalyModelType'] != "share-anomaly") {
    this.updateResourceModel(project, deployment);
}

if (options.updateSystemModel) {
    if (options.preRelease) {
        this.updateSystemModel(project, deployment, "demo");
    } else {
        this.updateSystemModel(project, deployment, "deploy");
    }
}

this.afterGenerateDeploymentModels(project, deployment, options);

// create source data directory on HDFS server
var fs = HDFS.getFileSystem(project.hdfsServerURL);
if (fs != null && deployment.datasourceProfile.type == "hdfs") {
    var deploymentGlobalMap = {};
    deployment.parserProfile.common["Parser Properties"].forEach(function (item) {
        deploymentGlobalMap[item.id] = item;
    });
    
    if (options.resetParserSource) {
        // delete source data directory on HDFS server
        var path = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length);
        if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
            this._purgeInput(project, deployment);
        }
    }

    if (options.resetParserTarget) {
        // delete target data directory on HDFS server
        var path = (deploymentGlobalMap["spark_sql_table_url"].defaultValue || deploymentGlobalMap["spark_sql_table_url"].value).substring(project.hdfsServerURL.length);
        if (path != null && path.length > 0 && HDFS.exists(fs, path) && HDFS.isDirectory(fs, path)) {
            HDFS.deleteDirectory(fs, path, true);
        }
    }
    
    var path = deployment.datasourceProfile.config.path.substring(project.hdfsServerURL.length)
    if (!HDFS.exists(fs, path)) {
        HDFS.createDirectory(fs, path);
    }
    HDFS.closeFileSystem(project.hdfsServerURL, fs);
}
]]>
        </CodeText>
      </Service>
      <Service name="updateResourceModel" args="project,deployment" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}

var obj = this.generateResourceModel(project, deployment, project.detail.output);

var name = this.getResourceModelName(project, deployment);
var uri = this.getResourceModelURL(project, deployment);
var space = this.getResourceModelSpace(project, deployment);

if (!this._mrHasSpace(space)) {
    this._mrCreateSpace(space);
}

if (this._mrHasModel(uri)) {
    this._mrCopyModel(obj.template, name, space);
}
this._mrSaveResourceModel(uri, JSON.stringify(obj.model));

this._hiveCreateTable(obj.model);
]]>
        </CodeText>
      </Service>
      <Service name="updateSystemModel" args="project,deployment,mode" private="false">
        <CodeText>
          <![CDATA[if (typeof deployment == "string") {
    deployment = this.loadProjectDeployment(project, deployment);
}
//print("updateSystemModel: mode="+mode);
if (project.detail == null) {
    project.detail = this.loadProject(project);
}
var obj = this.generateSystemModel(project, deployment, mode, project.detail.schema, project.detail.pivot, project.detail.count,
                                   project.detail.enrich, project.detail.output, project.detail.qdc, project.detail.metric);

var queryConfig = this.getQueryConfig();

this._updateParseTable(queryConfig, obj, false);
this._updateMetricInfo(queryConfig, obj, false);
this._updateQdcTable(queryConfig, obj, false);

var EnvLib = com.vitria.fc.utils.EnvLib;
var File = java.io.File;

var path = EnvLib.expandVars("${VTBA_HOME}/tmp/" + "nuova_stella/system_models/" + project.uuid + ".json");
//print("updateSystemModel: path="+path);
Context.writeToFile(path, JSON.stringify(obj));

this._saveProjectFile(project, 'system-model', obj, true);

var name = this.getSystemModelName(project, deployment);
var uri = this.getSystemModelURL(project, deployment);
var space = this.getSystemModelSpace(project, deployment);
this._mrSaveSystemModel(uri, space, obj, project);

// force re-caching of ServiceConfig, FilterConfig,... to include new metrics
this._updateSystemModelLastModified();
this._updateCachedConfig(queryConfig);

this._notifyStatusChange(project, deployment, 'Update Model');

return true;
]]>
        </CodeText>
      </Service>
    </Services>
    <Resources>
      <Resource uuid="e859ad95-76c0-40fa-8c4e-9ea500ffff74" name="ANOMALY_BASELINE_META_STORE_DELETE_SQL" type="text/plain" size="63" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="ddd7c4e6-34df-43d7-8057-d4b2a283ca4c" name="ANOMALY_SOL_DELETE_SQL" type="text/plain" size="47" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="9b0e6cba-208b-4dc1-8000-f2777a1e03b5" name="AUDIT_PARSER_SELECT_SQL" type="application/sql" size="300" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="58c25d92-0801-4765-8b8f-fed6af5d4f39" name="BASE_OUTPUT_MODEL" type="application/json" size="1715" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="417cd06a-d281-45c0-80fa-0e66ab145bb2" name="INCIDENT_MODEL_DELETE_SQL" type="text/plain" size="0" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="23296a09-4528-4464-8133-c86e97137b06" name="INCIDENT_SUMMARY_DELETE_SQL" type="text/plain" size="0" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="4d2b63e6-3075-4aaf-8c00-2ee2102adc58" name="JSON_FILE_SPARK_PROPERTIES" type="text/plain" size="1056" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="d0b096ec-e821-460e-856f-bbdb1de1ae41" name="JSON_SCRIPT_0" type="text/plain" size="371" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="86708c4c-170f-4475-8d70-a118b55b037e" name="JSON_SCRIPT_0_BAK" type="text/plain" size="320" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="fcb067ce-d7c9-45dd-8af7-7383f1bc9d99" name="JSON_SCRIPT_1" type="text/plain" size="1510" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="d0f99a65-c8b4-40b0-87ea-941f164ca792" name="JSON_SCRIPT_1_BAK" type="text/plain" size="997" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="2d03f60c-206e-48df-89b5-e0297184ba90" name="PROJECT_ITEM_TABLE_DELETE_ALL_SQL" type="application/sql" size="62" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="7010b0c5-d607-4c20-8188-60af7c8f58b6" name="PROJECT_ITEM_TABLE_DELETE_SQL" type="application/sql" size="73" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="612a771b-00c1-4fd8-80cb-9b82745a97a8" name="PROJECT_ITEM_TABLE_EXIST_SQL" type="application/sql" size="96" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="b4e76bc2-5c74-48a9-88ad-5ca0f1644c2b" name="PROJECT_ITEM_TABLE_INSERT_SQL" type="application/sql" size="252" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="aba111dc-21c6-408f-8855-b52449d304e0" name="PROJECT_ITEM_TABLE_SELECT_SQL" type="application/sql" size="87" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="493a5291-c21a-41ee-8e71-6f6a6845b528" name="PROJECT_ITEM_TABLE_UPDATE_SQL" type="application/sql" size="119" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="5842c7c6-c376-4cb9-8e7d-408afd9d03c1" name="PROJECT_TABLE_DELETE_SQL" type="application/sql" size="56" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="3f42c9d1-dcd1-46f2-85d7-fe8ca7a00fbd" name="PROJECT_TABLE_EXIST_SQL" type="application/sql" size="70" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="f2752834-45d8-4285-832a-62095d41dd57" name="PROJECT_TABLE_INSERT_SQL" type="application/sql" size="440" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="6eb69979-867f-444a-87b4-745ec1feeb00" name="PROJECT_TABLE_SELECT_SQL" type="application/sql" size="73" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="3a70c4a7-e4e7-4e7d-8fdc-d92226f04490" name="PROJECT_TABLE_UPDATE_SQL" type="application/sql" size="331" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="179bb3a2-ad75-4a96-8c89-ba0cf726c9cd" name="QueryConfig_SAMPLE" type="application/json" size="1557" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="33c78b0f-b90b-4173-8a0d-6de13a3401f2" name="SQL Scripts" type="application/sql" size="3120" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="b8614be7-dda0-47c0-8935-e6d95a225d1d" name="SYSTEM_MODEL_CONTENT_CREATE" type="application/xml" size="354" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="597d61ac-5ca6-49a6-817c-2589625755ff" name="SYSTEM_MODEL_CONTENT_UPDATE" type="application/xml" size="574" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="8c6a5ebe-6507-452e-82c5-095785de7544" name="TODO" type="text/plain" size="1837" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="914e9dfc-2312-4969-8953-fb7637aac23b" name="WorkbenchConfig" type="application/json" size="17401" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
    </Resources>
    <Plugins>
      <Plugin uri="/app/dbp/space/VIA Digital Operations/dbpm/VIAOps - Base Service"/>
      <Plugin uri="/app/dbp/space/VIA Common Library/dbpm/VIA - File Service"/>
      <Plugin uri="/app/dbp/space/VIA Common Library/dbpm/VIA - Parser Library"/>
      <Plugin uri="/app/dbp/space/VIAOps Signal Onboarding/dbpm/VIAOps - Signal Onboarding Deployment Service"/>
      <Plugin uri="/app/dbp/space/VIA Digital Operations/dbpm/VIAOps - Config Property"/>
      <Plugin uri="/app/dbp/space/VIAOps Signal Onboarding/dbpm/VIAOps - Signal Onboarding System Model Service"/>
    </Plugins>
  </ModelInfo>
</DashboardPluginModel>